var tipuesearch = {"pages":[{"text":"Photodissociation of water Note 3D LZ Surface Hopping Bug CODE TO BE TESTED Developer Info Nicolas SISOURAT None","tags":"home","loc":"index.html","title":" Photodissociation of water "},{"text":"Contents Modules bspline_sub_module Source Code bspline_sub_module.f90 Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !# Description ! !  Multidimensional (1D-6D) B-spline interpolation of data on a regular grid. !  Basic pure subroutine interface. ! !# Notes ! !  This module is based on the B-spline and spline routines from [1]. !  The original Fortran 77 routines were converted to free-form source. !  Some of them are relatively unchanged from the originals, but some have !  been extensively refactored. In addition, new routines for !  1d, 4d, 5d, and 6d interpolation were also created (these are simply !  extensions of the same algorithm into higher dimensions). ! !# See also !  * An object-oriented interface can be found in [[bspline_oo_module]]. ! !# References ! !  1. DBSPLIN and DTENSBS from the !     [NIST Core Math Library](http://www.nist.gov/itl/math/mcsd-software.cfm). !     Original code is public domain. !  2. Carl de Boor, \"A Practical Guide to Splines\", !     Springer-Verlag, New York, 1978. !  3. Carl de Boor, [Efficient Computer Manipulation of Tensor !     Products](http://dl.acm.org/citation.cfm?id=355831), !     ACM Transactions on Mathematical Software, !     Vol. 5 (1979), p. 173-182. !  4. D.E. Amos, \"Computation with Splines and B-Splines\", !     SAND78-1968, Sandia Laboratories, March, 1979. !  5. Carl de Boor, !     [Package for calculating with B-splines](http://epubs.siam.org/doi/abs/10.1137/0714026), !     SIAM Journal on Numerical Analysis 14, 3 (June 1977), p. 441-472. module bspline_sub_module use , intrinsic :: iso_fortran_env , only : real64 use , intrinsic :: iso_fortran_env , only : error_unit implicit none private integer , parameter :: wp = real64 !! Real precision !main routines: public :: db1ink , db1val public :: db2ink , db2val public :: db3ink , db3val public :: db4ink , db4val public :: db5ink , db5val public :: db6ink , db6val public :: get_status_message contains !***************************************************************************************** !***************************************************************************************** !> Determines the parameters of a function that interpolates !  the one-dimensional gridded data !   [x(i),\\mathrm{fcn}(i)] ~\\mathrm{for}~ i=1,..,n_x  !  The interpolating function and its derivatives may !  subsequently be evaluated by the function [[db1val]]. ! !# History ! !  * Jacob Williams, 10/30/2015 : Created 1D routine. pure subroutine db1ink ( x , nx , fcn , kx , iknot , tx , bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! Number of x abcissae integer , intent ( in ) :: kx !! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) real ( wp ), dimension (:), intent ( in ) :: x !! `nx` array of x abcissae. Must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: fcn !! `(nx)` array of function values to interpolate. `fcn(i)` should !!    contain the function value at the point `x(i)` integer , intent ( in ) :: iknot !! 0 = knot sequence chosen by [[db1ink]]. !! 1 = knot sequence chosen by user. real ( wp ), dimension (:), intent ( inout ) :: tx !! The `nx+kx` knots in the `x` direction for the spline interpolant. !!   If `iknot=0` these are chosen by [[db1ink]]. !!   If `iknot=1` these are specified by the user. !!   Must be non-decreasing. real ( wp ), dimension (:), intent ( out ) :: bcoef !! `(nx)` array of coefficients of the b-spline interpolant. integer , intent ( out ) :: iflag !! 0 = successful execution. !! 2 = iknot out of range. !! 3 = nx out of range. !! 4 = kx out of range. !! 5 = x not strictly increasing. !! 6 = tx not non-decreasing. !! 700 = size(x) /= size(fcn,1). !! 706 = size(x) /= nx. !! 712 = size(tx) /= nx+kx. !! 800 = size(x) /= size(bcoef,1). real ( wp ), dimension ( 2 * kx * ( nx + 1 )) :: work logical :: status_ok !check validity of inputs call check_inputs ( 'db1ink' ,& iknot ,& iflag ,& nx = nx ,& kx = kx ,& x = x ,& f1 = fcn ,& bcoef1 = bcoef ,& tx = tx ,& status_ok = status_ok ) if ( status_ok ) then !choose knots if ( iknot == 0 ) then call dbknot ( x , nx , kx , tx ) end if !construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , 1 , tx , kx , bcoef , work , iflag ) end if end subroutine db1ink !***************************************************************************************** !***************************************************************************************** !> Evaluates the tensor product piecewise polynomial !  interpolant constructed by the routine [[db1ink]] or one of its !  derivatives at the point xval. ! !  To evaluate the interpolant itself, set idx=0, !  to evaluate the first partial with respect to x, set idx=1, and so on. ! !  db1val returns 0.0 if (xval,yval) is out of range. that is, if !```fortran !   xval < tx(1) .or. xval > tx(nx+kx) !``` !  if the knots tx were chosen by [[db1ink]], then this is equivalent to: !```fortran !   xval < x(1) .or. xval > x(nx)+epsx !``` !  where !```fortran !   epsx = 0.1*(x(nx)-x(nx-1)) !``` ! !  The input quantities tx, nx, kx, and bcoef should be !  unchanged since the last call of [[db1ink]]. ! !# History ! !  * Jacob Williams, 10/30/2015 : Created 1D routine. pure subroutine db1val ( xval , idx , tx , nx , kx , bcoef , f , iflag , inbvx ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db1ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db1ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db1ink]]) real ( wp ), dimension ( nx ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db1ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. real ( wp ), dimension ( 3 * kx ) :: work f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then !write(error_unit,'(A)') 'db1val - x value out of bounds' iflag = 601 return end if call dbvalu ( tx , bcoef , nx , kx , idx , xval , inbvx , work , iflag , f ) end subroutine db1val !***************************************************************************************** !***************************************************************************************** !> Determines the parameters of a function that interpolates !  the two-dimensional gridded data !   [x(i),y(j),\\mathrm{fcn}(i,j)] ~\\mathrm{for}~ i=1,..,n_x ~\\mathrm{and}~ j=1,..,n_y  !  The interpolating function and its derivatives may !  subsequently be evaluated by the function [[db2val]]. ! !  The interpolating function is a piecewise polynomial function !  represented as a tensor product of one-dimensional b-splines. the !  form of this function is ! !   s(x,y) = \\sum_{i=1}&#94;{n_x} \\sum_{j=1}&#94;{n_y} a_{ij} u_i(x) v_j(y)  ! !  where the functions u_i and v_j are one-dimensional b-spline !  basis functions. the coefficients  a_{ij}  are chosen so that ! !   s(x(i),y(j)) = \\mathrm{fcn}(i,j) ~\\mathrm{for}~ i=1,..,n_x ~\\mathrm{and}~ j=1,..,n_y  ! !  Note that for each fixed value of y,  s(x,y)  is a piecewise !  polynomial function of x alone, and for each fixed value of x,  s(x,y)  !  is a piecewise polynomial function of y alone. in one dimension !  a piecewise polynomial may be created by partitioning a given !  interval into subintervals and defining a distinct polynomial piece !  on each one. the points where adjacent subintervals meet are called !  knots. each of the functions u_i and v_j above is a piecewise !  polynomial. ! !  Users of db2ink choose the order (degree+1) of the polynomial !  pieces used to define the piecewise polynomial in each of the x and !  y directions (kx and ky). users also may define their own knot !  sequence in x and y separately (tx and ty). if iflag=0, however, !  db2ink will choose sequences of knots that result in a piecewise !  polynomial interpolant with kx-2 continuous partial derivatives in !  x and ky-2 continuous partial derivatives in y. (kx knots are taken !  near each endpoint in the x direction, not-a-knot end conditions !  are used, and the remaining knots are placed at data points if kx !  is even or at midpoints between data points if kx is odd. the y !  direction is treated similarly.) ! !  After a call to db2ink, all information necessary to define the !  interpolating function are contained in the parameters nx, ny, kx, !  ky, tx, ty, and bcoef. These quantities should not be altered until !  after the last call of the evaluation routine [[db2val]]. ! !# History ! !  * Boisvert, Ronald, NBS : 25 may 1982 : Author of original routine. !  * JEC : 000330 modified array declarations. !  * Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. pure subroutine db2ink ( x , nx , y , ny , fcn , kx , ky , iknot , tx , ty , bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! Number of x abcissae integer , intent ( in ) :: ny !! Number of y abcissae integer , intent ( in ) :: kx !! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer , intent ( in ) :: ky !! The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) real ( wp ), dimension (:), intent ( in ) :: x !! `nx` array of x abcissae. Must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: y !! `ny` array of y abcissae. Must be strictly increasing. real ( wp ), dimension (:,:), intent ( in ) :: fcn !! `(nx,ny)` matrix of function values to interpolate. `fcn(i,j)` should !!    contain the function value at the point `(x(i),y(j))` integer , intent ( in ) :: iknot !! 0 = knot sequence chosen by [[db1ink]]. !! 1 = knot sequence chosen by user. real ( wp ), dimension (:), intent ( inout ) :: tx !! The `nx+kx` knots in the `x` direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db2ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: ty !! The `ny+ky` knots in the `y` direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db2ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:,:), intent ( out ) :: bcoef !! `(nx,ny)` matrix of coefficients of the b-spline interpolant. integer , intent ( out ) :: iflag !!  0 = successful execution. !!  2 = iknot out of range. !!  3 = nx out of range. !!  4 = kx out of range. !!  5 = x not strictly increasing. !!  6 = tx not non-decreasing. !!  7 = ny out of range. !!  8 = ky out of range. !!  9 = y not strictly increasing. !! 10 = ty not non-decreasing. !! 700 = size(x) /= size(fcn,1). !! 701 = size(y) /= size(fcn,2). !! 706 = size(x) /= nx. !! 707 = size(y) /= ny. !! 712 = size(tx) /= nx+kx. !! 713 = size(ty) /= ny+ky. !! 800 = size(x) /= size(bcoef,1). !! 801 = size(y) /= size(bcoef,2). real ( wp ), dimension ( nx * ny ) :: temp real ( wp ), dimension ( max ( 2 * kx * ( nx + 1 ), 2 * ky * ( ny + 1 ))) :: work logical :: status_ok !check validity of inputs call check_inputs ( 'db2ink' ,& iknot ,& iflag ,& nx = nx , ny = ny ,& kx = kx , ky = ky ,& x = x , y = y ,& tx = tx , ty = ty ,& f2 = fcn ,& bcoef2 = bcoef ,& status_ok = status_ok ) if ( status_ok ) then !choose knots if ( iknot == 0 ) then call dbknot ( x , nx , kx , tx ) call dbknot ( y , ny , ky , ty ) end if !construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , ny , tx , kx , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( y , ny , temp , ny , nx , ty , ky , bcoef , work , iflag ) end if end subroutine db2ink !***************************************************************************************** !***************************************************************************************** !> Evaluates the tensor product piecewise polynomial !  interpolant constructed by the routine [[db2ink]] or one of its !  derivatives at the point (xval,yval). ! !  To evaluate the interpolant !  itself, set idx=idy=0, to evaluate the first partial with respect !  to x, set idx=1,idy=0, and so on. ! !  db2val returns 0.0 if (xval,yval) is out of range. that is, if !```fortran !   xval < tx(1) .or. xval > tx(nx+kx) .or. !   yval < ty(1) .or. yval > ty(ny+ky) !``` !  if the knots tx and ty were chosen by [[db2ink]], then this is equivalent to: !```fortran !   xval < x(1) .or. xval > x(nx)+epsx .or. !   yval < y(1) .or. yval > y(ny)+epsy !``` !  where !```fortran !   epsx = 0.1*(x(nx)-x(nx-1)) !   epsy = 0.1*(y(ny)-y(ny-1)) !``` ! !  The input quantities tx, ty, nx, ny, kx, ky, and bcoef should be !  unchanged since the last call of [[db2ink]]. ! !# History ! !  * Boisvert, Ronald, NBS : 25 may 1982 : Author of original routine. !  * JEC : 000330 modified array declarations. !  * Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. pure subroutine db2val ( xval , yval , idx , idy , tx , ty , nx , ny , kx , ky , bcoef , f , iflag , inbvx , inbvy , iloy ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idy !! y derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db2ink]]) integer , intent ( in ) :: ny !! the number of interpolation points in y. (same as in last call to [[db2ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db2ink]]) integer , intent ( in ) :: ky !! order of polynomial pieces in y. (same as in last call to [[db2ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), intent ( in ) :: yval !! y coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db2ink]]) real ( wp ), dimension ( ny + ky ), intent ( in ) :: ty !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db2ink]]) real ( wp ), dimension ( nx , ny ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db2ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer :: k , lefty , mflag , kcol real ( wp ), dimension ( ky ) :: temp real ( wp ), dimension ( 3 * max ( kx , ky )) :: work f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then !write(error_unit,'(A)') 'db2val - x value out of bounds' iflag = 601 return end if if ( yval < ty ( 1 ) . or . yval > ty ( ny + ky )) then !write(error_unit,'(A)') 'db2val - y value out of bounds' iflag = 602 return end if iflag = - 1 call dintrv ( ty , ny + ky , yval , iloy , lefty , mflag ); if ( mflag /= 0 ) return kcol = lefty - ky do k = 1 , ky kcol = kcol + 1 call dbvalu ( tx , bcoef (:, kcol ), nx , kx , idx , xval , inbvx , work , iflag , temp ( k )) if ( iflag /= 0 ) return !error end do kcol = lefty - ky + 1 call dbvalu ( ty ( kcol :), temp , ky , ky , idy , yval , inbvy , work , iflag , f ) end subroutine db2val !***************************************************************************************** !***************************************************************************************** !> Determines the parameters of a function that interpolates !  the three-dimensional gridded data !   [x(i),y(j),z(k),\\mathrm{fcn}(i,j,k)] ~\\mathrm{for}~ !     i=1,..,n_x ~\\mathrm{and}~ j=1,..,n_y, ~\\mathrm{and}~ k=1,..,n_z  !  The interpolating function and !  its derivatives may subsequently be evaluated by the function !  [[db3val]]. ! !  The interpolating function is a piecewise polynomial function !  represented as a tensor product of one-dimensional b-splines. the !  form of this function is !   s(x,y,z) = \\sum_{i=1}&#94;{n_x} \\sum_{j=1}&#94;{n_y} \\sum_{k=1}&#94;{n_z} !                a_{ijk} u_i(x) v_j(y) w_k(z)  ! !  where the functions u_i, v_j, and w_k are one-dimensional b- !  spline basis functions. the coefficients a_{ijk} are chosen so that: ! !   s(x(i),y(j),z(k)) = \\mathrm{fcn}(i,j,k) !     ~\\mathrm{for}~ i=1,..,n_x , j=1,..,n_y , k=1,..,n_z  ! !  Note that for fixed values of y and z s(x,y,z) is a piecewise !  polynomial function of x alone, for fixed values of x and z s(x,y,z) !  is a piecewise polynomial function of y alone, and for fixed !  values of x and y s(x,y,z) is a function of z alone. in one !  dimension a piecewise polynomial may be created by partitioning a !  given interval into subintervals and defining a distinct polynomial !  piece on each one. the points where adjacent subintervals meet are !  called knots. each of the functions u_i, v_j, and w_k above is a !  piecewise polynomial. ! !  Users of db3ink choose the order (degree+1) of the polynomial !  pieces used to define the piecewise polynomial in each of the x, y, !  and z directions (kx, ky, and kz). users also may define their own !  knot sequence in x, y, and z separately (tx, ty, and tz). if iflag= !  0, however, db3ink will choose sequences of knots that result in a !  piecewise polynomial interpolant with kx-2 continuous partial !  derivatives in x, ky-2 continuous partial derivatives in y, and kz- !  2 continuous partial derivatives in z. (kx knots are taken near !  each endpoint in x, not-a-knot end conditions are used, and the !  remaining knots are placed at data points if kx is even or at !  midpoints between data points if kx is odd. the y and z directions !  are treated similarly.) ! !  After a call to db3ink, all information necessary to define the !  interpolating function are contained in the parameters nx, ny, nz, !  kx, ky, kz, tx, ty, tz, and bcoef. these quantities should not be !  altered until after the last call of the evaluation routine [[db3val]]. ! !# History ! !  * Boisvert, Ronald, NBS : 25 may 1982 : Author of original routine. !  * JEC : 000330 modified array declarations. !  * Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. pure subroutine db3ink ( x , nx , y , ny , z , nz , fcn , kx , ky , kz , iknot , tx , ty , tz , bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! number of x abcissae (>= 3) integer , intent ( in ) :: ny !! number of y abcissae (>= 3) integer , intent ( in ) :: nz !! number of z abcissae (>= 3) integer , intent ( in ) :: kx !! the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer , intent ( in ) :: ky !! the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer , intent ( in ) :: kz !! the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) real ( wp ), dimension (:), intent ( in ) :: x !! `nx` array of x abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: y !! `ny` array of y abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: z !! `nz` array of z abcissae. must be strictly increasing. real ( wp ), dimension (:,:,:), intent ( in ) :: fcn !! `(nx,ny,nz)` matrix of function values to interpolate. fcn(i,j,k) should !!   contain the function value at the point (x(i),y(j),z(k)) integer , intent ( in ) :: iknot !! 0 = knot sequence chosen by [[db1ink]]. !! 1 = knot sequence chosen by user. real ( wp ), dimension (:), intent ( inout ) :: tx !! The `nx+kx` knots in the `x` direction for the spline interpolant. !!   If `iknot=0` these are chosen by [[db3ink]]. !!   If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: ty !! The `ny+ky` knots in the `y` direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db3ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tz !! The `nz+kz` knots in the `z` direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db3ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:,:,:), intent ( out ) :: bcoef !! '(nx,ny,nz)' matrix of coefficients of the b-spline interpolant. integer , intent ( out ) :: iflag !!  0 = successful execution. !!  2 = iknot out of range. !!  3 = nx out of range. !!  4 = kx out of range. !!  5 = x not strictly increasing. !!  6 = tx not non-decreasing. !!  7 = ny out of range. !!  8 = ky out of range. !!  9 = y not strictly increasing. !! 10 = ty not non-decreasing. !! 11 = nz out of range. !! 12 = kz out of range. !! 13 = z not strictly increasing. !! 14 = ty not non-decreasing. !! 700 = size(x) /= size(fcn,1). !! 701 = size(y) /= size(fcn,2). !! 702 = size(z) /= size(fcn,3). !! 706 = size(x) /= nx. !! 707 = size(y) /= ny. !! 708 = size(z) /= nz. !! 712 = size(tx) /= nx+kx. !! 713 = size(ty) /= ny+ky. !! 714 = size(tz) /= nz+kz. !! 800 = size(x) /= size(bcoef,1). !! 801 = size(y) /= size(bcoef,2). !! 802 = size(z) /= size(bcoef,3). real ( wp ), dimension ( nx * ny * nz ) :: temp real ( wp ), dimension ( max ( 2 * kx * ( nx + 1 ), 2 * ky * ( ny + 1 ), 2 * kz * ( nz + 1 ))) :: work logical :: status_ok ! check validity of input call check_inputs ( 'db3ink' ,& iknot ,& iflag ,& nx = nx , ny = ny , nz = nz ,& kx = kx , ky = ky , kz = kz ,& x = x , y = y , z = z ,& tx = tx , ty = ty , tz = tz ,& f3 = fcn ,& bcoef3 = bcoef ,& status_ok = status_ok ) if ( status_ok ) then ! choose knots if ( iknot == 0 ) then call dbknot ( x , nx , kx , tx ) call dbknot ( y , ny , ky , ty ) call dbknot ( z , nz , kz , tz ) end if ! copy fcn to work in packed for dbtpcf temp ( 1 : nx * ny * nz ) = reshape ( fcn , [ nx * ny * nz ] ) ! construct b-spline coefficients call dbtpcf ( x , nx , temp , nx , ny * nz , tx , kx , bcoef , work , iflag ) if ( iflag == 0 ) call dbtpcf ( y , ny , bcoef , ny , nx * nz , ty , ky , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( z , nz , temp , nz , nx * ny , tz , kz , bcoef , work , iflag ) end if end subroutine db3ink !***************************************************************************************** !***************************************************************************************** !> Evaluates the tensor product piecewise polynomial !  interpolant constructed by the routine [[db3ink]] or one of its !  derivatives at the point (xval,yval,zval). ! !  To evaluate the !  interpolant itself, set idx=idy=idz=0, to evaluate the first !  partial with respect to x, set idx=1,idy=idz=0, and so on. ! !  db3val returns 0.0 if (xval,yval,zval) is out of range. that is, !```fortran ! xval<tx(1) .or. xval>tx(nx+kx) .or. ! yval<ty(1) .or. yval>ty(ny+ky) .or. ! zval<tz(1) .or. zval>tz(nz+kz) !``` !  if the knots tx, ty, and tz were chosen by [[db3ink]], then this is !  equivalent to !```fortran ! xval<x(1) .or. xval>x(nx)+epsx .or. ! yval<y(1) .or. yval>y(ny)+epsy .or. ! zval<z(1) .or. zval>z(nz)+epsz !``` !  where !```fortran ! epsx = 0.1*(x(nx)-x(nx-1)) ! epsy = 0.1*(y(ny)-y(ny-1)) ! epsz = 0.1*(z(nz)-z(nz-1)) !``` ! !  The input quantities tx, ty, tz, nx, ny, nz, kx, ky, kz, and bcoef !  should remain unchanged since the last call of [[db3ink]]. ! !# History ! !  * Boisvert, Ronald, NBS : 25 may 1982 : Author of original routine. !  * JEC : 000330 modified array declarations. !  * Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. pure subroutine db3val ( xval , yval , zval , idx , idy , idz ,& tx , ty , tz ,& nx , ny , nz , kx , ky , kz , bcoef , f , iflag ,& inbvx , inbvy , inbvz , iloy , iloz ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idy !! y derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idz !! z derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db3ink]]) integer , intent ( in ) :: ny !! the number of interpolation points in y. (same as in last call to [[db3ink]]) integer , intent ( in ) :: nz !! the number of interpolation points in z. (same as in last call to [[db3ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db3ink]]) integer , intent ( in ) :: ky !! order of polynomial pieces in y. (same as in last call to [[db3ink]]) integer , intent ( in ) :: kz !! order of polynomial pieces in z. (same as in last call to [[db3ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), intent ( in ) :: yval !! y coordinate of evaluation point. real ( wp ), intent ( in ) :: zval !! z coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db3ink]]) real ( wp ), dimension ( ny + ky ), intent ( in ) :: ty !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db3ink]]) real ( wp ), dimension ( nz + kz ), intent ( in ) :: tz !! sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to [[db3ink]]) real ( wp ), dimension ( nx , ny , nz ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db3ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. real ( wp ), dimension ( ky , kz ) :: temp1 real ( wp ), dimension ( kz ) :: temp2 real ( wp ), dimension ( 3 * max ( kx , ky , kz )) :: work integer :: lefty , leftz , mflag ,& kcoly , kcolz , j , k f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then !write(error_unit,'(A)') 'db3val - x value out of bounds' iflag = 601 return end if if ( yval < ty ( 1 ) . or . yval > ty ( ny + ky )) then !write(error_unit,'(A)') 'db3val - y value out of bounds' iflag = 602 return end if if ( zval < tz ( 1 ) . or . zval > tz ( nz + kz )) then !write(error_unit,'(A)') 'db3val - z value out of bounds' iflag = 603 return end if iflag = - 1 call dintrv ( ty , ny + ky , yval , iloy , lefty , mflag ); if ( mflag /= 0 ) return call dintrv ( tz , nz + kz , zval , iloz , leftz , mflag ); if ( mflag /= 0 ) return iflag = 0 kcolz = leftz - kz do k = 1 , kz kcolz = kcolz + 1 kcoly = lefty - ky do j = 1 , ky kcoly = kcoly + 1 call dbvalu ( tx , bcoef (:, kcoly , kcolz ), nx , kx , idx , xval , inbvx , work , iflag , temp1 ( j , k )) if ( iflag /= 0 ) return end do end do kcoly = lefty - ky + 1 do k = 1 , kz call dbvalu ( ty ( kcoly :), temp1 (:, k ), ky , ky , idy , yval , inbvy , work , iflag , temp2 ( k )) if ( iflag /= 0 ) return end do kcolz = leftz - kz + 1 call dbvalu ( tz ( kcolz :), temp2 , kz , kz , idz , zval , inbvz , work , iflag , f ) end subroutine db3val !***************************************************************************************** !***************************************************************************************** !> Determines the parameters of a function that interpolates !  the four-dimensional gridded data !   [x(i),y(j),z(k),q(l),\\mathrm{fcn}(i,j,k,l)] ~\\mathrm{for}~ !     i=1,..,n_x ~\\mathrm{and}~ j=1,..,n_y, ~\\mathrm{and}~ k=1,..,n_z, !     ~\\mathrm{and}~ l=1,..,n_q  !  The interpolating function and its derivatives may !  subsequently be evaluated by the function [[db4val]]. ! !  See [[db3ink]] header for more details. ! !# History ! !  * Jacob Williams, 2/24/2015 : Created this routine. pure subroutine db4ink ( x , nx , y , ny , z , nz , q , nq ,& fcn ,& kx , ky , kz , kq ,& iknot ,& tx , ty , tz , tq ,& bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! number of x abcissae (>= 3) integer , intent ( in ) :: ny !! number of y abcissae (>= 3) integer , intent ( in ) :: nz !! number of z abcissae (>= 3) integer , intent ( in ) :: nq !! number of q abcissae (>= 3) integer , intent ( in ) :: kx !! the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer , intent ( in ) :: ky !! the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer , intent ( in ) :: kz !! the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) integer , intent ( in ) :: kq !! the order of spline pieces in q (>= 2, < nq). (order = polynomial degree + 1) real ( wp ), dimension (:), intent ( in ) :: x !! `nx` array of x abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: y !! `ny` array of y abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: z !! `nz` array of z abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: q !! `nq` array of q abcissae. must be strictly increasing. real ( wp ), dimension (:,:,:,:), intent ( in ) :: fcn !! `(nx,ny,nz,nq)` matrix of function values to interpolate. fcn(i,j,k,q) should !!   contain the function value at the point (x(i),y(j),z(k),q(l)) integer , intent ( in ) :: iknot !! 0 = knot sequence chosen by [[db1ink]]. !! 1 = knot sequence chosen by user. real ( wp ), dimension (:), intent ( inout ) :: tx !! The `nx+kx` knots in the x direction for the spline interpolant. !!   If `iknot=0` these are chosen by [[db4ink]]. !!   If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: ty !! The `ny+ky` knots in the y direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db4ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tz !! The `nz+kz` knots in the z direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db4ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tq !! The `nq+kq` knots in the q direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db4ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:,:,:,:), intent ( out ) :: bcoef !! `(nx,ny,nz,nq)` matrix of coefficients of the b-spline interpolant. integer , intent ( out ) :: iflag !!  0 = successful execution. !!  2 = iknot out of range. !!  3 = nx out of range. !!  4 = kx out of range. !!  5 = x not strictly increasing. !!  6 = tx not non-decreasing. !!  7 = ny out of range. !!  8 = ky out of range. !!  9 = y not strictly increasing. !! 10 = ty not non-decreasing. !! 11 = nz out of range. !! 12 = kz out of range. !! 13 = z not strictly increasing. !! 14 = tz not non-decreasing. !! 15 = nq out of range. !! 16 = kq out of range. !! 17 = q not strictly increasing. !! 18 = tq not non-decreasing. !! 700 = size(x) /= size(fcn,1). !! 701 = size(y) /= size(fcn,2). !! 702 = size(z) /= size(fcn,3). !! 703 = size(q) /= size(fcn,4). !! 706 = size(x) /= nx. !! 707 = size(y) /= ny. !! 708 = size(z) /= nz. !! 709 = size(q) /= nq. !! 712 = size(tx) /= nx+kx. !! 713 = size(ty) /= ny+ky. !! 714 = size(tz) /= nz+kz. !! 715 = size(tq) /= nq+kq. !! 800 = size(x) /= size(bcoef,1). !! 801 = size(y) /= size(bcoef,2). !! 802 = size(z) /= size(bcoef,3). !! 803 = size(q) /= size(bcoef,4). real ( wp ), dimension ( nx * ny * nz * nq ) :: temp real ( wp ), dimension ( max ( 2 * kx * ( nx + 1 ), 2 * ky * ( ny + 1 ), 2 * kz * ( nz + 1 ), 2 * kq * ( nq + 1 ))) :: work logical :: status_ok ! check validity of input call check_inputs ( 'db4ink' ,& iknot ,& iflag ,& nx = nx , ny = ny , nz = nz , nq = nq ,& kx = kx , ky = ky , kz = kz , kq = kq ,& x = x , y = y , z = z , q = q ,& tx = tx , ty = ty , tz = tz , tq = tq ,& f4 = fcn ,& bcoef4 = bcoef ,& status_ok = status_ok ) if ( status_ok ) then ! choose knots if ( iknot == 0 ) then call dbknot ( x , nx , kx , tx ) call dbknot ( y , ny , ky , ty ) call dbknot ( z , nz , kz , tz ) call dbknot ( q , nq , kq , tq ) end if ! construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , ny * nz * nq , tx , kx , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( y , ny , temp , ny , nx * nz * nq , ty , ky , bcoef , work , iflag ) if ( iflag == 0 ) call dbtpcf ( z , nz , bcoef , nz , nx * ny * nq , tz , kz , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( q , nq , temp , nq , nx * ny * nz , tq , kq , bcoef , work , iflag ) end if end subroutine db4ink !***************************************************************************************** !***************************************************************************************** !> Evaluates the tensor product piecewise polynomial !  interpolant constructed by the routine [[db4ink]] or one of its !  derivatives at the point (xval,yval,zval,qval). ! !  To evaluate the !  interpolant itself, set idx=idy=idz=idq=0, to evaluate the first !  partial with respect to x, set idx=1,idy=idz=idq=0, and so on. ! !  See [[db3val]] header for more information. ! !# History ! !  * Jacob Williams, 2/24/2015 : Created this routine. pure subroutine db4val ( xval , yval , zval , qval ,& idx , idy , idz , idq ,& tx , ty , tz , tq ,& nx , ny , nz , nq ,& kx , ky , kz , kq ,& bcoef , f , iflag ,& inbvx , inbvy , inbvz , inbvq , iloy , iloz , iloq ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idy !! y derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idz !! z derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idq !! q derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db4ink]]) integer , intent ( in ) :: ny !! the number of interpolation points in y. (same as in last call to [[db4ink]]) integer , intent ( in ) :: nz !! the number of interpolation points in z. (same as in last call to [[db4ink]]) integer , intent ( in ) :: nq !! the number of interpolation points in q. (same as in last call to [[db4ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db4ink]]) integer , intent ( in ) :: ky !! order of polynomial pieces in y. (same as in last call to [[db4ink]]) integer , intent ( in ) :: kz !! order of polynomial pieces in z. (same as in last call to [[db4ink]]) integer , intent ( in ) :: kq !! order of polynomial pieces in q. (same as in last call to [[db4ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), intent ( in ) :: yval !! y coordinate of evaluation point. real ( wp ), intent ( in ) :: zval !! z coordinate of evaluation point. real ( wp ), intent ( in ) :: qval !! q coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db4ink]]) real ( wp ), dimension ( ny + ky ), intent ( in ) :: ty !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db4ink]]) real ( wp ), dimension ( nz + kz ), intent ( in ) :: tz !! sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to [[db4ink]]) real ( wp ), dimension ( nq + kq ), intent ( in ) :: tq !! sequence of knots defining the piecewise polynomial in the q direction. (same as in last call to [[db4ink]]) real ( wp ), dimension ( nx , ny , nz , nq ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db4ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvq !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloq !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. real ( wp ), dimension ( ky , kz , kq ) :: temp1 real ( wp ), dimension ( kz , kq ) :: temp2 real ( wp ), dimension ( kq ) :: temp3 real ( wp ), dimension ( 3 * max ( kx , ky , kz , kq )) :: work integer :: lefty , leftz , leftq , mflag ,& kcoly , kcolz , kcolq , j , k , q f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then !write(error_unit,'(A)') 'db4val - x value out of bounds' iflag = 601 return end if if ( yval < ty ( 1 ) . or . yval > ty ( ny + ky )) then !write(error_unit,'(A)') 'db4val - y value out of bounds' iflag = 602 return end if if ( zval < tz ( 1 ) . or . zval > tz ( nz + kz )) then !write(error_unit,'(A)') 'db4val - z value out of bounds' iflag = 603 return end if if ( qval < tq ( 1 ) . or . qval > tq ( nq + kq ) ) then !write(error_unit,'(A)') 'db4val - q value out of bounds' iflag = 604 return end if iflag = - 1 call dintrv ( ty , ny + ky , yval , iloy , lefty , mflag ); if ( mflag /= 0 ) return call dintrv ( tz , nz + kz , zval , iloz , leftz , mflag ); if ( mflag /= 0 ) return call dintrv ( tq , nq + kq , qval , iloq , leftq , mflag ); if ( mflag /= 0 ) return iflag = 0 ! x -> y, z, q kcolq = leftq - kq do q = 1 , kq kcolq = kcolq + 1 kcolz = leftz - kz do k = 1 , kz kcolz = kcolz + 1 kcoly = lefty - ky do j = 1 , ky kcoly = kcoly + 1 call dbvalu ( tx , bcoef (:, kcoly , kcolz , kcolq ),& nx , kx , idx , xval , inbvx , work , iflag , temp1 ( j , k , q )) if ( iflag /= 0 ) return end do end do end do ! y -> z, q kcoly = lefty - ky + 1 do q = 1 , kq do k = 1 , kz call dbvalu ( ty ( kcoly :), temp1 (:, k , q ), ky , ky , idy , yval , inbvy , work , iflag , temp2 ( k , q )) if ( iflag /= 0 ) return end do end do ! z -> q kcolz = leftz - kz + 1 do q = 1 , kq call dbvalu ( tz ( kcolz :), temp2 (:, q ), kz , kz , idz , zval , inbvz , work , iflag , temp3 ( q )) if ( iflag /= 0 ) return end do ! q kcolq = leftq - kq + 1 call dbvalu ( tq ( kcolq :), temp3 , kq , kq , idq , qval , inbvq , work , iflag , f ) end subroutine db4val !***************************************************************************************** !***************************************************************************************** !> Determines the parameters of a function that interpolates !  the five-dimensional gridded data (x(i),y(j),z(k),q(l),r(m),fcn(i,j,k,l,m)) for !  i=1,..,nx, j=1,..,ny, k=1,..,nz, l=1,..,nq, and m=1,..,nr. !  The interpolating function and its derivatives may subsequently be evaluated !  by the function [[db5val]]. ! !  See [[db3ink]] header for more details. ! !# History ! !  * Jacob Williams, 2/24/2015 : Created this routine. pure subroutine db5ink ( x , nx , y , ny , z , nz , q , nq , r , nr ,& fcn ,& kx , ky , kz , kq , kr ,& iknot ,& tx , ty , tz , tq , tr ,& bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! number of x abcissae (>= 3) integer , intent ( in ) :: ny !! number of y abcissae (>= 3) integer , intent ( in ) :: nz !! number of z abcissae (>= 3) integer , intent ( in ) :: nq !! number of q abcissae (>= 3) integer , intent ( in ) :: nr !! number of r abcissae (>= 3) integer , intent ( in ) :: kx !! the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer , intent ( in ) :: ky !! the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer , intent ( in ) :: kz !! the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) integer , intent ( in ) :: kq !! the order of spline pieces in q (>= 2, < nq). (order = polynomial degree + 1) integer , intent ( in ) :: kr !! the order of spline pieces in r (>= 2, < nr). (order = polynomial degree + 1) real ( wp ), dimension (:), intent ( in ) :: x !! `nx` array of x abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: y !! `ny` array of y abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: z !! `nz` array of z abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: q !! `nq` array of q abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: r !! `nr` array of r abcissae. must be strictly increasing. real ( wp ), dimension (:,:,:,:,:), intent ( in ) :: fcn !! `(nx,ny,nz,nq,nr)` matrix of function values to interpolate. fcn(i,j,k,q,r) should !!   contain the function value at the point (x(i),y(j),z(k),q(l),r(m)) integer , intent ( in ) :: iknot !! 0 = knot sequence chosen by [[db1ink]]. !! 1 = knot sequence chosen by user. real ( wp ), dimension (:), intent ( inout ) :: tx !! The `nx+kx` knots in the x direction for the spline interpolant. !!   If `iknot=0` these are chosen by [[db5ink]]. !!   If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: ty !! The `ny+ky` knots in the y direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db5ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tz !! The `nz+kz` knots in the z direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db5ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tq !! The `nq+kq` knots in the q direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db5ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tr !! The `nr+kr` knots in the r direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db5ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:,:,:,:,:), intent ( out ) :: bcoef !! `(nx,ny,nz,nq,nr)` matrix of coefficients of the b-spline interpolant. integer , intent ( out ) :: iflag !!  0 = successful execution. !!  2 = iknot out of range. !!  3 = nx out of range. !!  4 = kx out of range. !!  5 = x not strictly increasing. !!  6 = tx not non-decreasing. !!  7 = ny out of range. !!  8 = ky out of range. !!  9 = y not strictly increasing. !! 10 = ty not non-decreasing. !! 11 = nz out of range. !! 12 = kz out of range. !! 13 = z not strictly increasing. !! 14 = tz not non-decreasing. !! 15 = nq out of range. !! 16 = kq out of range. !! 17 = q not strictly increasing. !! 18 = tq not non-decreasing. !! 19 = nr out of range. !! 20 = kr out of range. !! 21 = r not strictly increasing. !! 22 = tr not non-decreasing. !! 700 = size(x) /= size(fcn,1). !! 701 = size(y) /= size(fcn,2). !! 702 = size(z) /= size(fcn,3). !! 703 = size(q) /= size(fcn,4). !! 704 = size(r) /= size(fcn,5). !! 706 = size(x) /= nx. !! 707 = size(y) /= ny. !! 708 = size(z) /= nz. !! 709 = size(q) /= nq. !! 710 = size(r) /= nr. !! 712 = size(tx) /= nx+kx. !! 713 = size(ty) /= ny+ky. !! 714 = size(tz) /= nz+kz. !! 715 = size(tq) /= nq+kq. !! 716 = size(tr) /= nr+kr. !! 800 = size(x) /= size(bcoef,1). !! 801 = size(y) /= size(bcoef,2). !! 802 = size(z) /= size(bcoef,3). !! 803 = size(q) /= size(bcoef,4). !! 804 = size(r) /= size(bcoef,5). real ( wp ), dimension ( nx * ny * nz * nq * nr ) :: temp real ( wp ), dimension ( max ( 2 * kx * ( nx + 1 ),& 2 * ky * ( ny + 1 ),& 2 * kz * ( nz + 1 ),& 2 * kq * ( nq + 1 ),& 2 * kr * ( nr + 1 ) )) :: work logical :: status_ok !  check validity of input call check_inputs ( 'db5ink' ,& iknot ,& iflag ,& nx = nx , ny = ny , nz = nz , nq = nq , nr = nr ,& kx = kx , ky = ky , kz = kz , kq = kq , kr = kr ,& x = x , y = y , z = z , q = q , r = r ,& tx = tx , ty = ty , tz = tz , tq = tq , tr = tr ,& f5 = fcn ,& bcoef5 = bcoef ,& status_ok = status_ok ) if ( status_ok ) then !  choose knots if ( iknot == 0 ) then call dbknot ( x , nx , kx , tx ) call dbknot ( y , ny , ky , ty ) call dbknot ( z , nz , kz , tz ) call dbknot ( q , nq , kq , tq ) call dbknot ( r , nr , kr , tr ) end if ! copy fcn to work in packed for dbtpcf temp ( 1 : nx * ny * nz * nq * nr ) = reshape ( fcn , [ nx * ny * nz * nq * nr ] ) !  construct b-spline coefficients call dbtpcf ( x , nx , temp , nx , ny * nz * nq * nr , tx , kx , bcoef , work , iflag ) if ( iflag == 0 ) call dbtpcf ( y , ny , bcoef , ny , nx * nz * nq * nr , ty , ky , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( z , nz , temp , nz , nx * ny * nq * nr , tz , kz , bcoef , work , iflag ) if ( iflag == 0 ) call dbtpcf ( q , nq , bcoef , nq , nx * ny * nz * nr , tq , kq , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( r , nr , temp , nr , nx * ny * nz * nq , tr , kr , bcoef , work , iflag ) end if end subroutine db5ink !***************************************************************************************** !***************************************************************************************** !> Evaluates the tensor product piecewise polynomial !  interpolant constructed by the routine [[db5ink]] or one of its !  derivatives at the point (xval,yval,zval,qval,rval). ! !  To evaluate the !  interpolant itself, set idx=idy=idz=idq=idr=0, to evaluate the first !  partial with respect to x, set idx=1,idy=idz=idq=idr=0, and so on. ! !  See [[db3val]] header for more information. ! !# History ! !  * Jacob Williams, 2/24/2015 : Created this routine. pure subroutine db5val ( xval , yval , zval , qval , rval ,& idx , idy , idz , idq , idr ,& tx , ty , tz , tq , tr ,& nx , ny , nz , nq , nr ,& kx , ky , kz , kq , kr ,& bcoef , f , iflag ,& inbvx , inbvy , inbvz , inbvq , inbvr , iloy , iloz , iloq , ilor ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idy !! y derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idz !! z derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idq !! q derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idr !! r derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db5ink]]) integer , intent ( in ) :: ny !! the number of interpolation points in y. (same as in last call to [[db5ink]]) integer , intent ( in ) :: nz !! the number of interpolation points in z. (same as in last call to [[db5ink]]) integer , intent ( in ) :: nq !! the number of interpolation points in q. (same as in last call to [[db5ink]]) integer , intent ( in ) :: nr !! the number of interpolation points in r. (same as in last call to [[db5ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db5ink]]) integer , intent ( in ) :: ky !! order of polynomial pieces in y. (same as in last call to [[db5ink]]) integer , intent ( in ) :: kz !! order of polynomial pieces in z. (same as in last call to [[db5ink]]) integer , intent ( in ) :: kq !! order of polynomial pieces in q. (same as in last call to [[db5ink]]) integer , intent ( in ) :: kr !! order of polynomial pieces in r. (same as in last call to [[db5ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), intent ( in ) :: yval !! y coordinate of evaluation point. real ( wp ), intent ( in ) :: zval !! z coordinate of evaluation point. real ( wp ), intent ( in ) :: qval !! q coordinate of evaluation point. real ( wp ), intent ( in ) :: rval !! r coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db5ink]]) real ( wp ), dimension ( ny + ky ), intent ( in ) :: ty !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db5ink]]) real ( wp ), dimension ( nz + kz ), intent ( in ) :: tz !! sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to [[db5ink]]) real ( wp ), dimension ( nq + kq ), intent ( in ) :: tq !! sequence of knots defining the piecewise polynomial in the q direction. (same as in last call to [[db5ink]]) real ( wp ), dimension ( nr + kr ), intent ( in ) :: tr !! sequence of knots defining the piecewise polynomial in the r direction. (same as in last call to [[db5ink]]) real ( wp ), dimension ( nx , ny , nz , nq , nr ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db5ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvq !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvr !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloq !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: ilor !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. real ( wp ), dimension ( ky , kz , kq , kr ) :: temp1 real ( wp ), dimension ( kz , kq , kr ) :: temp2 real ( wp ), dimension ( kq , kr ) :: temp3 real ( wp ), dimension ( kr ) :: temp4 real ( wp ), dimension ( 3 * max ( kx , ky , kz , kq , kr )) :: work integer :: lefty , leftz , leftq , leftr , mflag ,& kcoly , kcolz , kcolq , kcolr , j , k , q , r f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then !write(error_unit,'(A)') 'db5val - x value out of bounds' iflag = 601 return end if if ( yval < ty ( 1 ) . or . yval > ty ( ny + ky )) then !write(error_unit,'(A)') 'db5val - y value out of bounds' iflag = 602 return end if if ( zval < tz ( 1 ) . or . zval > tz ( nz + kz )) then !write(error_unit,'(A)') 'db5val - z value out of bounds' iflag = 603 return end if if ( qval < tq ( 1 ) . or . qval > tq ( nq + kq ) ) then !write(error_unit,'(A)') 'db5val - q value out of bounds' iflag = 604 return end if if ( rval < tr ( 1 ) . or . rval > tr ( nr + kr ) ) then !write(error_unit,'(A)') 'db5val - r value out of bounds' iflag = 605 return end if iflag = - 1 call dintrv ( ty , ny + ky , yval , iloy , lefty , mflag ); if ( mflag /= 0 ) return call dintrv ( tz , nz + kz , zval , iloz , leftz , mflag ); if ( mflag /= 0 ) return call dintrv ( tq , nq + kq , qval , iloq , leftq , mflag ); if ( mflag /= 0 ) return call dintrv ( tr , nr + kr , rval , ilor , leftr , mflag ); if ( mflag /= 0 ) return iflag = 0 ! x -> y, z, q, r kcolr = leftr - kr do r = 1 , kr kcolr = kcolr + 1 kcolq = leftq - kq do q = 1 , kq kcolq = kcolq + 1 kcolz = leftz - kz do k = 1 , kz kcolz = kcolz + 1 kcoly = lefty - ky do j = 1 , ky kcoly = kcoly + 1 call dbvalu ( tx , bcoef (:, kcoly , kcolz , kcolq , kcolr ),& nx , kx , idx , xval , inbvx , work , iflag , temp1 ( j , k , q , r )) if ( iflag /= 0 ) return end do end do end do end do ! y -> z, q, r kcoly = lefty - ky + 1 do r = 1 , kr do q = 1 , kq do k = 1 , kz call dbvalu ( ty ( kcoly :), temp1 (:, k , q , r ), ky , ky , idy , yval , inbvy , work , iflag , temp2 ( k , q , r )) if ( iflag /= 0 ) return end do end do end do ! z -> q, r kcolz = leftz - kz + 1 do r = 1 , kr do q = 1 , kq call dbvalu ( tz ( kcolz :), temp2 (:, q , r ), kz , kz , idz , zval , inbvz , work , iflag , temp3 ( q , r )) if ( iflag /= 0 ) return end do end do ! q -> r kcolq = leftq - kq + 1 do r = 1 , kr call dbvalu ( tq ( kcolq :), temp3 (:, r ), kq , kq , idq , qval , inbvq , work , iflag , temp4 ( r )) if ( iflag /= 0 ) return end do ! r kcolr = leftr - kr + 1 call dbvalu ( tr ( kcolr :), temp4 , kr , kr , idr , rval , inbvr , work , iflag , f ) end subroutine db5val !***************************************************************************************** !***************************************************************************************** !> Determines the parameters of a function that interpolates !  the six-dimensional gridded data (x(i),y(j),z(k),q(l),r(m),s(n),fcn(i,j,k,l,m,n)) for !  i=1,..,nx, j=1,..,ny, k=1,..,nz, l=1,..,nq, m=1,..,nr, n=1,..,ns. !  the interpolating function and its derivatives may subsequently be evaluated !  by the function [[db6val]]. ! !  See [[db3ink]] header for more details. ! !# History ! !  * Jacob Williams, 2/24/2015 : Created this routine. pure subroutine db6ink ( x , nx , y , ny , z , nz , q , nq , r , nr , s , ns ,& fcn ,& kx , ky , kz , kq , kr , ks ,& iknot ,& tx , ty , tz , tq , tr , ts ,& bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! number of x abcissae (>= 3) integer , intent ( in ) :: ny !! number of y abcissae (>= 3) integer , intent ( in ) :: nz !! number of z abcissae (>= 3) integer , intent ( in ) :: nq !! number of q abcissae (>= 3) integer , intent ( in ) :: nr !! number of r abcissae (>= 3) integer , intent ( in ) :: ns !! number of s abcissae (>= 3) integer , intent ( in ) :: kx !! the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer , intent ( in ) :: ky !! the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer , intent ( in ) :: kz !! the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) integer , intent ( in ) :: kq !! the order of spline pieces in q (>= 2, < nq). (order = polynomial degree + 1) integer , intent ( in ) :: kr !! the order of spline pieces in r (>= 2, < nr). (order = polynomial degree + 1) integer , intent ( in ) :: ks !! the order of spline pieces in s (>= 2, < ns). (order = polynomial degree + 1) real ( wp ), dimension (:), intent ( in ) :: x !! `nx` array of x abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: y !! `ny` array of y abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: z !! `nz` array of z abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: q !! `nq` array of q abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: r !! `nr` array of r abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: s !! `ns` array of s abcissae. must be strictly increasing. real ( wp ), dimension (:,:,:,:,:,:), intent ( in ) :: fcn !! `(nx,ny,nz,nq,nr,ns)` matrix of function values to interpolate. fcn(i,j,k,q,r,s) should !!   contain the function value at the point (x(i),y(j),z(k),q(l),r(m),s(n)) integer , intent ( in ) :: iknot !! 0 = knot sequence chosen by [[db1ink]]. !! 1 = knot sequence chosen by user. real ( wp ), dimension (:), intent ( inout ) :: tx !! The `nx+kx` knots in the x direction for the spline interpolant. !!   If `iknot=0` these are chosen by [[db6ink]]. !!   If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: ty !! The `ny+ky` knots in the y direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db6ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tz !! The `nz+kz` knots in the z direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db6ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tq !! The `nq+kq` knots in the q direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db6ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tr !! The `nr+kr` knots in the r direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db6ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: ts !! The `ns+ks` knots in the s direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db6ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:,:,:,:,:,:), intent ( out ) :: bcoef !! `(nx,ny,nz,nq,nr,ns)` matrix of coefficients of the b-spline interpolant. integer , intent ( out ) :: iflag !!  0 = successful execution. !!  2 = iknot out of range. !!  3 = nx out of range. !!  4 = kx out of range. !!  5 = x not strictly increasing. !!  6 = tx not non-decreasing. !!  7 = ny out of range. !!  8 = ky out of range. !!  9 = y not strictly increasing. !! 10 = ty not non-decreasing. !! 11 = nz out of range. !! 12 = kz out of range. !! 13 = z not strictly increasing. !! 14 = tz not non-decreasing. !! 15 = nq out of range. !! 16 = kq out of range. !! 17 = q not strictly increasing. !! 18 = tq not non-decreasing. !! 19 = nr out of range. !! 20 = kr out of range. !! 21 = r not strictly increasing. !! 22 = tr not non-decreasing. !! 23 = ns out of range. !! 24 = ks out of range. !! 25 = s not strictly increasing. !! 26 = ts not non-decreasing. !! 700 = size(x) /= size(fcn,1). !! 701 = size(y) /= size(fcn,2). !! 702 = size(z) /= size(fcn,3). !! 703 = size(q) /= size(fcn,4). !! 704 = size(r) /= size(fcn,5). !! 705 = size(s) /= size(fcn,6). !! 706 = size(x) /= nx. !! 707 = size(y) /= ny. !! 708 = size(z) /= nz. !! 709 = size(q) /= nq. !! 710 = size(r) /= nr. !! 711 = size(s) /= ns. !! 712 = size(tx) /= nx+kx. !! 713 = size(ty) /= ny+ky. !! 714 = size(tz) /= nz+kz. !! 715 = size(tq) /= nq+kq. !! 716 = size(tr) /= nr+kr. !! 717 = size(ts) /= ns+ks. !! 800 = size(x) /= size(bcoef,1). !! 801 = size(y) /= size(bcoef,2). !! 802 = size(z) /= size(bcoef,3). !! 803 = size(q) /= size(bcoef,4). !! 804 = size(r) /= size(bcoef,5). !! 805 = size(s) /= size(bcoef,6). real ( wp ), dimension ( nx * ny * nz * nq * nr * ns ) :: temp real ( wp ), dimension ( max ( 2 * kx * ( nx + 1 ),& 2 * ky * ( ny + 1 ),& 2 * kz * ( nz + 1 ),& 2 * kq * ( nq + 1 ),& 2 * kr * ( nr + 1 ),& 2 * ks * ( ns + 1 ))) :: work logical :: status_ok ! check validity of input call check_inputs ( 'db6ink' ,& iknot ,& iflag ,& nx = nx , ny = ny , nz = nz , nq = nq , nr = nr , ns = ns ,& kx = kx , ky = ky , kz = kz , kq = kq , kr = kr , ks = ks ,& x = x , y = y , z = z , q = q , r = r , s = s ,& tx = tx , ty = ty , tz = tz , tq = tq , tr = tr , ts = ts ,& f6 = fcn ,& bcoef6 = bcoef ,& status_ok = status_ok ) if ( status_ok ) then ! choose knots if ( iknot == 0 ) then call dbknot ( x , nx , kx , tx ) call dbknot ( y , ny , ky , ty ) call dbknot ( z , nz , kz , tz ) call dbknot ( q , nq , kq , tq ) call dbknot ( r , nr , kr , tr ) call dbknot ( s , ns , ks , ts ) end if ! construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , ny * nz * nq * nr * ns , tx , kx , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( y , ny , temp , ny , nx * nz * nq * nr * ns , ty , ky , bcoef , work , iflag ) if ( iflag == 0 ) call dbtpcf ( z , nz , bcoef , nz , nx * ny * nq * nr * ns , tz , kz , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( q , nq , temp , nq , nx * ny * nz * nr * ns , tq , kq , bcoef , work , iflag ) if ( iflag == 0 ) call dbtpcf ( r , nr , bcoef , nr , nx * ny * nz * nq * ns , tr , kr , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( s , ns , temp , ns , nx * ny * nz * nq * nr , ts , ks , bcoef , work , iflag ) end if end subroutine db6ink !***************************************************************************************** !***************************************************************************************** !> Evaluates the tensor product piecewise polynomial !  interpolant constructed by the routine [[db6ink]] or one of its !  derivatives at the point (xval,yval,zval,qval,rval,sval). ! !  To evaluate the !  interpolant itself, set idx=idy=idz=idq=idr=ids=0, to evaluate the first !  partial with respect to x, set idx=1,idy=idz=idq=idr=ids=0, and so on. ! !  See [[db3val]] header for more information. ! !# History ! !  * Jacob Williams, 2/24/2015 : Created this routine. pure subroutine db6val ( xval , yval , zval , qval , rval , sval ,& idx , idy , idz , idq , idr , ids ,& tx , ty , tz , tq , tr , ts ,& nx , ny , nz , nq , nr , ns ,& kx , ky , kz , kq , kr , ks ,& bcoef , f , iflag ,& inbvx , inbvy , inbvz , inbvq , inbvr , inbvs , iloy , iloz , iloq , ilor , ilos ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idy !! y derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idz !! z derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idq !! q derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idr !! r derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: ids !! s derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db6ink]]) integer , intent ( in ) :: ny !! the number of interpolation points in y. (same as in last call to [[db6ink]]) integer , intent ( in ) :: nz !! the number of interpolation points in z. (same as in last call to [[db6ink]]) integer , intent ( in ) :: nq !! the number of interpolation points in q. (same as in last call to [[db6ink]]) integer , intent ( in ) :: nr !! the number of interpolation points in r. (same as in last call to [[db6ink]]) integer , intent ( in ) :: ns !! the number of interpolation points in s. (same as in last call to [[db6ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db6ink]]) integer , intent ( in ) :: ky !! order of polynomial pieces in y. (same as in last call to [[db6ink]]) integer , intent ( in ) :: kz !! order of polynomial pieces in z. (same as in last call to [[db6ink]]) integer , intent ( in ) :: kq !! order of polynomial pieces in q. (same as in last call to [[db6ink]]) integer , intent ( in ) :: kr !! order of polynomial pieces in r. (same as in last call to [[db6ink]]) integer , intent ( in ) :: ks !! order of polynomial pieces in s. (same as in last call to [[db6ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), intent ( in ) :: yval !! y coordinate of evaluation point. real ( wp ), intent ( in ) :: zval !! z coordinate of evaluation point. real ( wp ), intent ( in ) :: qval !! q coordinate of evaluation point. real ( wp ), intent ( in ) :: rval !! r coordinate of evaluation point. real ( wp ), intent ( in ) :: sval !! s coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db6ink]]) real ( wp ), dimension ( ny + ky ), intent ( in ) :: ty !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db6ink]]) real ( wp ), dimension ( nz + kz ), intent ( in ) :: tz !! sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to [[db6ink]]) real ( wp ), dimension ( nq + kq ), intent ( in ) :: tq !! sequence of knots defining the piecewise polynomial in the q direction. (same as in last call to [[db6ink]]) real ( wp ), dimension ( nr + kr ), intent ( in ) :: tr !! sequence of knots defining the piecewise polynomial in the r direction. (same as in last call to [[db6ink]]) real ( wp ), dimension ( ns + ks ), intent ( in ) :: ts !! sequence of knots defining the piecewise polynomial in the s direction. (same as in last call to [[db6ink]]) real ( wp ), dimension ( nx , ny , nz , nq , nr , ns ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db6ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvq !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvr !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvs !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloq !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: ilor !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: ilos !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. real ( wp ), dimension ( ky , kz , kq , kr , ks ) :: temp1 real ( wp ), dimension ( kz , kq , kr , ks ) :: temp2 real ( wp ), dimension ( kq , kr , ks ) :: temp3 real ( wp ), dimension ( kr , ks ) :: temp4 real ( wp ), dimension ( ks ) :: temp5 real ( wp ), dimension ( 3 * max ( kx , ky , kz , kq , kr , ks )) :: work integer :: lefty , leftz , leftq , leftr , lefts ,& mflag ,& kcoly , kcolz , kcolq , kcolr , kcols ,& j , k , q , r , s f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then !write(error_unit,'(A)') 'db6val - x value out of bounds' iflag = 601 return end if if ( yval < ty ( 1 ) . or . yval > ty ( ny + ky )) then !write(error_unit,'(A)') 'db6val - y value out of bounds' iflag = 602 return end if if ( zval < tz ( 1 ) . or . zval > tz ( nz + kz )) then !write(error_unit,'(A)') 'db6val - z value out of bounds' iflag = 603 return end if if ( qval < tq ( 1 ) . or . qval > tq ( nq + kq ) ) then !write(error_unit,'(A)') 'db6val - q value out of bounds' iflag = 604 return end if if ( rval < tr ( 1 ) . or . rval > tr ( nr + kr ) ) then !write(error_unit,'(A)') 'db6val - r value out of bounds' iflag = 605 return end if if ( sval < ts ( 1 ) . or . sval > ts ( ns + ks ) ) then !write(error_unit,'(A)') 'db6val - s value out of bounds' iflag = 606 return end if iflag = - 1 call dintrv ( ty , ny + ky , yval , iloy , lefty , mflag ); if ( mflag /= 0 ) return call dintrv ( tz , nz + kz , zval , iloz , leftz , mflag ); if ( mflag /= 0 ) return call dintrv ( tq , nq + kq , qval , iloq , leftq , mflag ); if ( mflag /= 0 ) return call dintrv ( tr , nr + kr , rval , ilor , leftr , mflag ); if ( mflag /= 0 ) return call dintrv ( ts , ns + ks , sval , ilos , lefts , mflag ); if ( mflag /= 0 ) return iflag = 0 ! x -> y, z, q, r, s kcols = lefts - ks do s = 1 , ks kcols = kcols + 1 kcolr = leftr - kr do r = 1 , kr kcolr = kcolr + 1 kcolq = leftq - kq do q = 1 , kq kcolq = kcolq + 1 kcolz = leftz - kz do k = 1 , kz kcolz = kcolz + 1 kcoly = lefty - ky do j = 1 , ky kcoly = kcoly + 1 call dbvalu ( tx , bcoef (:, kcoly , kcolz , kcolq , kcolr , kcols ),& nx , kx , idx , xval , inbvx , work , iflag , temp1 ( j , k , q , r , s )) if ( iflag /= 0 ) return end do end do end do end do end do ! y -> z, q, r, s kcoly = lefty - ky + 1 do s = 1 , ks do r = 1 , kr do q = 1 , kq do k = 1 , kz call dbvalu ( ty ( kcoly :), temp1 (:, k , q , r , s ), ky , ky , idy , yval , inbvy , work , iflag , temp2 ( k , q , r , s )) if ( iflag /= 0 ) return end do end do end do end do ! z -> q, r, s kcolz = leftz - kz + 1 do s = 1 , ks do r = 1 , kr do q = 1 , kq call dbvalu ( tz ( kcolz :), temp2 (:, q , r , s ), kz , kz , idz , zval , inbvz , work , iflag , temp3 ( q , r , s )) if ( iflag /= 0 ) return end do end do end do ! q -> r, s kcolq = leftq - kq + 1 do s = 1 , ks do r = 1 , kr call dbvalu ( tq ( kcolq :), temp3 (:, r , s ), kq , kq , idq , qval , inbvq , work , iflag , temp4 ( r , s )) if ( iflag /= 0 ) return end do end do ! r -> s kcolr = leftr - kr + 1 do s = 1 , ks call dbvalu ( tr ( kcolr :), temp4 (:, s ), kr , kr , idr , rval , inbvr , work , iflag , temp5 ( s )) if ( iflag /= 0 ) return end do ! s kcols = lefts - ks + 1 call dbvalu ( ts ( kcols :), temp5 , ks , ks , ids , sval , inbvs , work , iflag , f ) end subroutine db6val !***************************************************************************************** !***************************************************************************************** !> Check the validity of the inputs to the \"ink\" routines. !  Prints warning message if there is an error, !  and also sets iflag and status_ok. ! !  Supports up to 6D: x,y,z,q,r,s ! !# Notes ! !  The code is new, but the logic is based on the original !  logic in the CMLIB routines db2ink and db3ink. ! !# History ! !  * Jacob Williams, 2/24/2015 : Created this routine. pure subroutine check_inputs ( routine ,& iknot ,& iflag ,& nx , ny , nz , nq , nr , ns ,& kx , ky , kz , kq , kr , ks ,& x , y , z , q , r , s ,& tx , ty , tz , tq , tr , ts ,& f1 , f2 , f3 , f4 , f5 , f6 ,& bcoef1 , bcoef2 , bcoef3 , bcoef4 , bcoef5 , bcoef6 ,& status_ok ) implicit none character ( len =* ), intent ( in ) :: routine integer , intent ( in ) :: iknot !! = 0 if the INK routine is computing the knots. integer , intent ( out ) :: iflag integer , intent ( in ), optional :: nx , ny , nz , nq , nr , ns integer , intent ( in ), optional :: kx , ky , kz , kq , kr , ks real ( wp ), dimension (:), intent ( in ), optional :: x , y , z , q , r , s real ( wp ), dimension (:), intent ( in ), optional :: tx , ty , tz , tq , tr , ts real ( wp ), dimension (:), intent ( in ), optional :: f1 , bcoef1 real ( wp ), dimension (:,:), intent ( in ), optional :: f2 , bcoef2 real ( wp ), dimension (:,:,:), intent ( in ), optional :: f3 , bcoef3 real ( wp ), dimension (:,:,:,:), intent ( in ), optional :: f4 , bcoef4 real ( wp ), dimension (:,:,:,:,:), intent ( in ), optional :: f5 , bcoef5 real ( wp ), dimension (:,:,:,:,:,:), intent ( in ), optional :: f6 , bcoef6 logical , intent ( out ) :: status_ok logical :: error status_ok = . false . if (( iknot < 0 ) . or . ( iknot > 1 )) then !write(error_unit,'(A,1X,I5)') & !    trim(routine)//' - iknot is out of range: ',iflag iflag = 2 else call check ( 'x' , nx , kx , x , tx ,[ 3 , 4 , 5 , 6 , 706 , 712 ], iflag , error ); if ( error ) return call check ( 'y' , ny , ky , y , ty ,[ 7 , 8 , 9 , 10 , 707 , 713 ], iflag , error ); if ( error ) return call check ( 'z' , nz , kz , z , tz ,[ 11 , 12 , 13 , 14 , 708 , 714 ], iflag , error ); if ( error ) return call check ( 'q' , nq , kq , q , tq ,[ 15 , 16 , 17 , 18 , 709 , 715 ], iflag , error ); if ( error ) return call check ( 'r' , nr , kr , r , tr ,[ 19 , 20 , 21 , 22 , 710 , 716 ], iflag , error ); if ( error ) return call check ( 's' , ns , ks , s , ts ,[ 23 , 24 , 25 , 26 , 711 , 717 ], iflag , error ); if ( error ) return if ( present ( x ) . and . present ( f1 ) . and . present ( bcoef1 )) then if ( size ( x ) /= size ( f1 , 1 )) then ; iflag = 700 ; return ; end if if ( size ( x ) /= size ( bcoef1 , 1 )) then ; iflag = 800 ; return ; end if end if if ( present ( x ) . and . present ( y ) . and . present ( f2 ) . and . present ( bcoef2 )) then if ( size ( x ) /= size ( f2 , 1 )) then ; iflag = 700 ; return ; end if if ( size ( y ) /= size ( f2 , 2 )) then ; iflag = 701 ; return ; end if if ( size ( x ) /= size ( bcoef2 , 1 )) then ; iflag = 800 ; return ; end if if ( size ( y ) /= size ( bcoef2 , 2 )) then ; iflag = 801 ; return ; end if end if if ( present ( x ) . and . present ( y ) . and . present ( z ) . and . present ( f3 ) . and . & present ( bcoef3 )) then if ( size ( x ) /= size ( f3 , 1 )) then ; iflag = 700 ; return ; end if if ( size ( y ) /= size ( f3 , 2 )) then ; iflag = 701 ; return ; end if if ( size ( z ) /= size ( f3 , 3 )) then ; iflag = 702 ; return ; end if if ( size ( x ) /= size ( bcoef3 , 1 )) then ; iflag = 800 ; return ; end if if ( size ( y ) /= size ( bcoef3 , 2 )) then ; iflag = 801 ; return ; end if if ( size ( z ) /= size ( bcoef3 , 3 )) then ; iflag = 802 ; return ; end if end if if ( present ( x ) . and . present ( y ) . and . present ( z ) . and . present ( q ) . and . & present ( f4 ) . and . present ( bcoef4 )) then if ( size ( x ) /= size ( f4 , 1 )) then ; iflag = 700 ; return ; end if if ( size ( y ) /= size ( f4 , 2 )) then ; iflag = 701 ; return ; end if if ( size ( z ) /= size ( f4 , 3 )) then ; iflag = 702 ; return ; end if if ( size ( q ) /= size ( f4 , 4 )) then ; iflag = 703 ; return ; end if if ( size ( x ) /= size ( bcoef4 , 1 )) then ; iflag = 800 ; return ; end if if ( size ( y ) /= size ( bcoef4 , 2 )) then ; iflag = 801 ; return ; end if if ( size ( z ) /= size ( bcoef4 , 3 )) then ; iflag = 802 ; return ; end if if ( size ( q ) /= size ( bcoef4 , 4 )) then ; iflag = 803 ; return ; end if end if if ( present ( x ) . and . present ( y ) . and . present ( z ) . and . present ( q ) . and . & present ( r ) . and . present ( f5 ) . and . present ( bcoef5 )) then if ( size ( x ) /= size ( f5 , 1 )) then ; iflag = 700 ; return ; end if if ( size ( y ) /= size ( f5 , 2 )) then ; iflag = 701 ; return ; end if if ( size ( z ) /= size ( f5 , 3 )) then ; iflag = 702 ; return ; end if if ( size ( q ) /= size ( f5 , 4 )) then ; iflag = 703 ; return ; end if if ( size ( r ) /= size ( f5 , 5 )) then ; iflag = 704 ; return ; end if if ( size ( x ) /= size ( bcoef5 , 1 )) then ; iflag = 800 ; return ; end if if ( size ( y ) /= size ( bcoef5 , 2 )) then ; iflag = 801 ; return ; end if if ( size ( z ) /= size ( bcoef5 , 3 )) then ; iflag = 802 ; return ; end if if ( size ( q ) /= size ( bcoef5 , 4 )) then ; iflag = 803 ; return ; end if if ( size ( r ) /= size ( bcoef5 , 5 )) then ; iflag = 804 ; return ; end if end if if ( present ( x ) . and . present ( y ) . and . present ( z ) . and . present ( q ) . and . & present ( r ) . and . present ( s ) . and . present ( f6 ) . and . present ( bcoef6 )) then if ( size ( x ) /= size ( f6 , 1 )) then ; iflag = 700 ; return ; end if if ( size ( y ) /= size ( f6 , 2 )) then ; iflag = 701 ; return ; end if if ( size ( z ) /= size ( f6 , 3 )) then ; iflag = 702 ; return ; end if if ( size ( q ) /= size ( f6 , 4 )) then ; iflag = 703 ; return ; end if if ( size ( r ) /= size ( f6 , 5 )) then ; iflag = 704 ; return ; end if if ( size ( s ) /= size ( f6 , 6 )) then ; iflag = 705 ; return ; end if if ( size ( x ) /= size ( bcoef6 , 1 )) then ; iflag = 800 ; return ; end if if ( size ( y ) /= size ( bcoef6 , 2 )) then ; iflag = 801 ; return ; end if if ( size ( z ) /= size ( bcoef6 , 3 )) then ; iflag = 802 ; return ; end if if ( size ( q ) /= size ( bcoef6 , 4 )) then ; iflag = 803 ; return ; end if if ( size ( r ) /= size ( bcoef6 , 5 )) then ; iflag = 804 ; return ; end if if ( size ( s ) /= size ( bcoef6 , 6 )) then ; iflag = 805 ; return ; end if end if status_ok = . true . iflag = 0 end if contains pure subroutine check ( s , n , k , x , t , ierrs , iflag , error ) !check t,x,n,k for validity implicit none character ( len = 1 ), intent ( in ) :: s !! coordinate string: 'x','y','z','q','r','s' integer , intent ( in ) , optional :: n !! size of `x` integer , intent ( in ) , optional :: k !! order real ( wp ), dimension (:), intent ( in ), optional :: x !! abcissae vector real ( wp ), dimension (:), intent ( in ), optional :: t !! knot vector size(n+k) integer , dimension (:), intent ( in ) :: ierrs !! int error codes for n,k,x,t,size(x),size(t) checks integer , intent ( out ) :: iflag !! status return code logical , intent ( out ) :: error !! true if there was an error if ( present ( n ) . and . present ( k ) . and . present ( x ) . and . present ( t )) then call check_n ( 'n' // s , n , x ,[ ierrs ( 1 ), ierrs ( 5 )], iflag , error ); if ( error ) return call check_k ( 'k' // s , k , n , ierrs ( 2 ), iflag , error ); if ( error ) return call check_x ( s , n , x , ierrs ( 3 ), iflag , error ); if ( error ) return if ( iknot /= 0 ) then call check_t ( 't' // s , n , k , t ,[ ierrs ( 4 ), ierrs ( 6 )], iflag , error ); if ( error ) return end if end if end subroutine check pure subroutine check_n ( s , n , x , ierr , iflag , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: n real ( wp ), dimension (:), intent ( in ) :: x !! abcissae vector integer , dimension ( 2 ), intent ( in ) :: ierr ![n<3 check, size(x)==n check] integer , intent ( out ) :: iflag !! status return code logical , intent ( out ) :: error if ( n < 3 ) then !write(error_unit,'(A,1X,I5)') & !    trim(routine)//' - '//trim(s)//' is out of range: ',n iflag = ierr ( 1 ) error = . true . else if ( size ( x ) /= n ) then !write(error_unit,'(A,1X,I5)') & !    trim(routine)//' - '//trim(s)//' is not abscissa vector size' iflag = ierr ( 2 ) error = . true . else error = . false . end if end if end subroutine check_n pure subroutine check_k ( s , k , n , ierr , iflag , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: k integer , intent ( in ) :: n integer , intent ( in ) :: ierr integer , intent ( out ) :: iflag !! status return code logical , intent ( out ) :: error if (( k < 2 ) . or . ( k >= n )) then !write(error_unit,'(A,1X,I5)') & !    trim(routine)//' - '//trim(s)//' is out of range: ',k iflag = ierr error = . true . else error = . false . end if end subroutine check_k pure subroutine check_x ( s , n , x , ierr , iflag , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: n real ( wp ), dimension (:), intent ( in ) :: x integer , intent ( in ) :: ierr integer , intent ( out ) :: iflag !! status return code logical , intent ( out ) :: error integer :: i error = . true . do i = 2 , n if ( x ( i ) <= x ( i - 1 )) then iflag = ierr !write(error_unit,'(A)') trim(routine)//' - '//trim(s)//& !            ' array must be strictly increasing' return end if end do error = . false . end subroutine check_x pure subroutine check_t ( s , n , k , t , ierr , iflag , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: n integer , intent ( in ) :: k real ( wp ), dimension (:), intent ( in ) :: t integer , dimension ( 2 ), intent ( in ) :: ierr !! [non-decreasing check, size check] integer , intent ( out ) :: iflag !! status return code logical , intent ( out ) :: error integer :: i error = . true . if ( size ( t ) /= ( n + k )) then !write(error_unit,'(A)') trim(routine)//' - '//trim(s)//& !            ' array is not the correct size' iflag = ierr ( 2 ) return end if do i = 2 , n + k if ( t ( i ) < t ( i - 1 )) then iflag = ierr ( 1 ) !write(error_unit,'(A)') trim(routine)//' - '//trim(s)//& !            ' array must be non-decreasing' return end if end do error = . false . end subroutine check_t end subroutine check_inputs !***************************************************************************************** !***************************************************************************************** !> dbknot chooses a knot sequence for interpolation of order k at the !  data points x(i), i=1,..,n.  the n+k knots are placed in the array !  t.  k knots are placed at each endpoint and not-a-knot end !  conditions are used.  the remaining knots are placed at data points !  if n is even and between data points if n is odd.  the rightmost !  knot is shifted slightly to the right to insure proper interpolation !  at x(n) (see page 350 of the reference). ! !# History ! !  * Jacob Williams, 2/24/2015 : Refactored this routine. pure subroutine dbknot ( x , n , k , t ) implicit none integer , intent ( in ) :: n integer , intent ( in ) :: k real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: t integer :: i , j , ipj , npj , ip1 , jstrt real ( wp ) :: rnot !put k knots at each endpoint !(shift right endpoints slightly -- see pg 350 of reference) rnot = x ( n ) + 0.1_wp * ( x ( n ) - x ( n - 1 ) ) do j = 1 , k t ( j ) = x ( 1 ) npj = n + j t ( npj ) = rnot end do !distribute remaining knots if ( mod ( k , 2 ) == 1 ) then !case of odd k --  knots between data points i = ( k - 1 ) / 2 - k ip1 = i + 1 jstrt = k + 1 do j = jstrt , n ipj = i + j t ( j ) = 0.5_wp * ( x ( ipj ) + x ( ipj + 1 ) ) end do else !case of even k --  knots at data points i = ( k / 2 ) - k jstrt = k + 1 do j = jstrt , n ipj = i + j t ( j ) = x ( ipj ) end do end if end subroutine dbknot !***************************************************************************************** !***************************************************************************************** !> dbtpcf computes b-spline interpolation coefficients for nf sets !  of data stored in the columns of the array fcn. the b-spline !  coefficients are stored in the rows of bcoef however. !  each interpolation is based on the n abcissa stored in the !  array x, and the n+k knots stored in the array t. the order !  of each interpolation is k. ! !# History ! !  * Jacob Williams, 2/24/2015 : Refactored this routine. pure subroutine dbtpcf ( x , n , fcn , ldf , nf , t , k , bcoef , work , iflag ) integer , intent ( in ) :: n integer , intent ( in ) :: nf integer , intent ( in ) :: ldf integer , intent ( in ) :: k real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension ( ldf , nf ), intent ( in ) :: fcn real ( wp ), dimension ( * ), intent ( in ) :: t real ( wp ), dimension ( nf , n ), intent ( out ) :: bcoef real ( wp ), dimension ( * ), intent ( out ) :: work !! work array of size >= `2*k*(n+1)` integer , intent ( out ) :: iflag !!   0: no errors !! 301: n should be >0 integer :: i , j , m1 , m2 , iq , iw ! check for null input if ( nf > 0 ) then ! partition work array m1 = k - 1 m2 = m1 + k iq = 1 + n iw = iq + m2 * n + 1 ! compute b-spline coefficients ! first data set call dbintk ( x , fcn , t , n , k , work , work ( iq ), work ( iw ), iflag ) if ( iflag == 0 ) then do i = 1 , n bcoef ( 1 , i ) = work ( i ) end do !  all remaining data sets by back-substitution if ( nf == 1 ) return do j = 2 , nf do i = 1 , n work ( i ) = fcn ( i , j ) end do call dbnslv ( work ( iq ), m2 , n , m1 , m1 , work ) do i = 1 , n bcoef ( j , i ) = work ( i ) end do end do end if else !write(error_unit,'(A)') 'dbtpcf - n should be >0' iflag = 301 end if end subroutine dbtpcf !***************************************************************************************** !***************************************************************************************** !> dbintk produces the b-spline coefficients, bcoef, of the !  b-spline of order k with knots t(i), i=1,...,n+k, which !  takes on the value y(i) at x(i), i=1,...,n.  the spline or !  any of its derivatives can be evaluated by calls to [[dbvalu]]. ! !  the i-th equation of the linear system a*bcoef = b for the !  coefficients of the interpolant enforces interpolation at !  x(i), i=1,...,n.  hence, b(i) = y(i), for all i, and a is !  a band matrix with 2k-1 bands if a is invertible.  the matrix !  a is generated row by row and stored, diagonal by diagonal, !  in the rows of q, with the main diagonal going into row k. !  the banded system is then solved by a call to dbnfac (which !  constructs the triangular factorization for a and stores it !  again in q), followed by a call to dbnslv (which then !  obtains the solution bcoef by substitution).  dbnfac does no !  pivoting, since the total positivity of the matrix a makes !  this unnecessary.  the linear system to be solved is !  (theoretically) invertible if and only if !          t(i) < x(i) < t(i+k),        for all i. !  equality is permitted on the left for i=1 and on the right !  for i=n when k knots are used at x(1) or x(n).  otherwise, !  violation of this condition is certain to lead to an error. ! !# Error conditions ! !  * improper input !  * singular system of equations ! !# History ! !  * splint written by carl de boor [5] !  * dbintk author: amos, d. e., (snla) : date written 800901 !  * revision date 820801 !  * 000330 modified array declarations. (jec) !  * Jacob Williams, 5/10/2015 : converted to free-form Fortran. pure subroutine dbintk ( x , y , t , n , k , bcoef , q , work , iflag ) implicit none integer , intent ( in ) :: n !! number of data points, n >= k real ( wp ), dimension ( n ), intent ( in ) :: x !! vector of length n containing data point abscissa !! in strictly increasing order. real ( wp ), dimension ( n ), intent ( in ) :: y !! corresponding vector of length n containing data !! point ordinates. real ( wp ), dimension ( * ), intent ( in ) :: t !! knot vector of length n+k !! since t(1),..,t(k) <= x(1) and t(n+1),..,t(n+k) !! >= x(n), this leaves only n-k knots (not !! necessarily x(i) values) interior to (x(1),x(n)) integer , intent ( in ) :: k !! order of the spline, k >= 1 real ( wp ), dimension ( n ), intent ( out ) :: bcoef !! a vector of length n containing the b-spline coefficients real ( wp ), dimension ( * ), intent ( out ) :: q !! a work vector of length (2*k-1)*n, containing !! the triangular factorization of the coefficient !! matrix of the linear system being solved.  the !! coefficients for the interpolant of an !! additional data set (x(i),yy(i)), i=1,...,n !! with the same abscissa can be obtained by loading !! yy into bcoef and then executing !! call dbnslv(q,2k-1,n,k-1,k-1,bcoef) real ( wp ), dimension ( * ), intent ( out ) :: work !! work vector of length 2*k integer , intent ( out ) :: iflag !!   0: no errors. !! 100: k does not satisfy k>=1. !! 101: n does not satisfy n>=k. !! 102: x(i) does not satisfy x(i)<x(i+1) for some i. !! 103: some abscissa was not in the support of the. !! corresponding basis function and the system is singular. !! 104: the system of solver detects a singular system. !! although the theoretical conditions for a solution were satisfied. integer :: iwork , i , ilp1mx , j , jj , km1 , kpkm2 , left , lenq , np1 real ( wp ) :: xi logical :: found if ( k < 1 ) then !write(error_unit,'(A)') 'dbintk - k does not satisfy k>=1' iflag = 100 return end if if ( n < k ) then !write(error_unit,'(A)') 'dbintk - n does not satisfy n>=k' iflag = 101 return end if jj = n - 1 if ( jj /= 0 ) then do i = 1 , jj if ( x ( i ) >= x ( i + 1 )) then !write(error_unit,'(A)') 'dbintk - x(i) does not satisfy x(i)<x(i+1) for some i' iflag = 102 return end if end do end if np1 = n + 1 km1 = k - 1 kpkm2 = 2 * km1 left = k ! zero out all entries of q lenq = n * ( k + km1 ) do i = 1 , lenq q ( i ) = 0.0_wp end do ! loop over i to construct the n interpolation equations do i = 1 , n xi = x ( i ) ilp1mx = min ( i + k , np1 ) ! find left in the closed interval (i,i+k-1) such that !         t(left) <= x(i) < t(left+1) ! matrix is singular if this is not possible left = max ( left , i ) if ( xi < t ( left )) then !write(error_unit,'(A)') 'dbintk - some abscissa was not in the support of the'//& !             ' corresponding basis function and the system is singular' iflag = 103 return end if found = . false . do found = ( xi < t ( left + 1 )) if ( found ) exit left = left + 1 if ( left >= ilp1mx ) exit end do if (. not . found ) then left = left - 1 if ( xi > t ( left + 1 )) then !write(error_unit,'(A)') 'dbintk - some abscissa was not in the support of the'//& !             ' corresponding basis function and the system is singular' iflag = 103 return end if end if ! the i-th equation enforces interpolation at xi, hence ! a(i,j) = b(j,k,t)(xi), all j. only the  k  entries with  j = ! left-k+1,...,left actually might be nonzero. these  k  numbers ! are returned, in  bcoef (used for temp.storage here), by the ! following call dbspvn ( t , k , k , 1 , xi , left , bcoef , work , iwork , iflag ) if ( iflag /= 0 ) return ! we therefore want  bcoef(j) = b(left-k+j)(xi) to go into ! a(i,left-k+j), i.e., into  q(i-(left+j)+2*k,(left+j)-k) since ! a(i+j,j)  is to go into  q(i+k,j), all i,j,  if we consider  q ! as a two-dim. array , with  2*k-1  rows (see comments in ! dbnfac). in the present program, we treat  q  as an equivalent ! one-dimensional array (because of fortran restrictions on ! dimension statements) . we therefore want  bcoef(j) to go into ! entry !     i -(left+j) + 2*k + ((left+j) - k-1)*(2*k-1) !            = i-left+1 + (left -k)*(2*k-1) + (2*k-2)*j ! of q. jj = i - left + 1 + ( left - k ) * ( k + km1 ) do j = 1 , k jj = jj + kpkm2 q ( jj ) = bcoef ( j ) end do end do ! obtain factorization of a, stored again in q. call dbnfac ( q , k + km1 , n , km1 , km1 , iflag ) if ( iflag == 1 ) then !success ! solve  a*bcoef = y  by backsubstitution do i = 1 , n bcoef ( i ) = y ( i ) end do call dbnslv ( q , k + km1 , n , km1 , km1 , bcoef ) iflag = 0 else !failure !write(error_unit,'(A)') 'dbintk - the system of solver detects a singular system'//& !             ' although the theoretical conditions for a solution were satisfied' iflag = 104 end if end subroutine dbintk !***************************************************************************************** !***************************************************************************************** !> Returns in w the LU-factorization (without pivoting) of the banded !  matrix a of order nrow with (nbandl + 1 + nbandu) bands or diagonals !  in the work array w . ! !  gauss elimination without pivoting is used. the routine is !  intended for use with matrices a which do not require row inter- !  changes during factorization, especially for the totally !  positive matrices which occur in spline calculations. !  the routine should not be used for an arbitrary banded matrix. ! !# Work array ! ! **Input** ! !        w array of size (nroww,nrow) contains the interesting !        part of a banded matrix  a , with the diagonals or bands of  a !        stored in the rows of  w , while columns of  a  correspond to !        columns of  w . this is the storage mode used in  linpack  and !        results in efficient innermost loops. !           explicitly,  a  has  nbandl  bands below the diagonal !                            +     1     (main) diagonal !                            +   nbandu  bands above the diagonal !        and thus, with    middle = nbandu + 1, !          a(i+j,j)  is in  w(i+middle,j)  for i=-nbandu,...,nbandl !                                              j=1,...,nrow . !        for example, the interesting entries of a (1,2)-banded matrix !        of order  9  would appear in the first  1+1+2 = 4  rows of  w !        as follows. !                          13 24 35 46 57 68 79 !                       12 23 34 45 56 67 78 89 !                    11 22 33 44 55 66 77 88 99 !                    21 32 43 54 65 76 87 98 ! !        all other entries of  w  not identified in this way with an en- !        try of  a  are never referenced . ! ! **Output** ! !  * if  iflag = 1, then !        w contains the lu-factorization of  a  into a unit lower triangu- !        lar matrix  l  and an upper triangular matrix  u (both banded) !        and stored in customary fashion over the corresponding entries !        of  a . this makes it possible to solve any particular linear !        system  a*x = b  for  x  by a !              call dbnslv ( w, nroww, nrow, nbandl, nbandu, b ) !        with the solution x  contained in  b  on return . !  * if  iflag = 2, then !        one of  nrow-1, nbandl,nbandu failed to be nonnegative, or else !        one of the potential pivots was found to be zero indicating !        that  a  does not have an lu-factorization. this implies that !        a  is singular in case it is totally positive . ! !# History ! !  * banfac written by carl de boor [5] !  * dbnfac from CMLIB [1] !  * Jacob Williams, 5/10/2015 : converted to free-form Fortran. pure subroutine dbnfac ( w , nroww , nrow , nbandl , nbandu , iflag ) integer , intent ( in ) :: nroww !! row dimension of the work array w. must be >= nbandl + 1 + nbandu. integer , intent ( in ) :: nrow !! matrix order integer , intent ( in ) :: nbandl !! number of bands of a below the main diagonal integer , intent ( in ) :: nbandu !! number of bands of a above the main diagonal integer , intent ( out ) :: iflag !! indicating success(=1) or failure (=2) real ( wp ), dimension ( nroww , nrow ), intent ( inout ) :: w !! work array. See header for details. integer :: i , ipk , j , jmax , k , kmax , middle , midmk , nrowm1 real ( wp ) :: factor , pivot iflag = 1 middle = nbandu + 1 ! w(middle,.) contains the main diagonal of a. nrowm1 = nrow - 1 if ( nrowm1 < 0 ) then iflag = 2 return elseif ( nrowm1 == 0 ) then if ( w ( middle , nrow ) == 0.0_wp ) iflag = 2 return end if if ( nbandl <= 0 ) then ! a is upper triangular. check that diagonal is nonzero . do i = 1 , nrowm1 if ( w ( middle , i ) == 0.0_wp ) then iflag = 2 return end if end do if ( w ( middle , nrow ) == 0.0_wp ) iflag = 2 return end if if ( nbandu <= 0 ) then ! a is lower triangular. check that diagonal is nonzero and ! divide each column by its diagonal. do i = 1 , nrowm1 pivot = w ( middle , i ) if ( pivot == 0.0_wp ) then iflag = 2 return end if jmax = min ( nbandl , nrow - i ) do j = 1 , jmax w ( middle + j , i ) = w ( middle + j , i ) / pivot end do end do return end if ! a is not just a triangular matrix. construct lu factorization do i = 1 , nrowm1 ! w(middle,i)  is pivot for i-th step . pivot = w ( middle , i ) if ( pivot == 0.0_wp ) then iflag = 2 return end if ! jmax is the number of (nonzero) entries in column i ! below the diagonal. jmax = min ( nbandl , nrow - i ) ! divide each entry in column i below diagonal by pivot. do j = 1 , jmax w ( middle + j , i ) = w ( middle + j , i ) / pivot end do ! kmax is the number of (nonzero) entries in row i to ! the right of the diagonal. kmax = min ( nbandu , nrow - i ) ! subtract a(i,i+k)*(i-th column) from (i+k)-th column ! (below row i). do k = 1 , kmax ipk = i + k midmk = middle - k factor = w ( midmk , ipk ) do j = 1 , jmax w ( midmk + j , ipk ) = w ( midmk + j , ipk ) - w ( middle + j , i ) * factor end do end do end do ! check the last diagonal entry. if ( w ( middle , nrow ) == 0.0_wp ) iflag = 2 end subroutine dbnfac !***************************************************************************************** !> Companion routine to [[dbnfac]]. it returns the solution x of the !  linear system a*x = b in place of b, given the lu-factorization !  for a in the work array w from dbnfac. ! !  (with  a = l*u , as stored in w), the unit lower triangular system !   l(u*x) = b  is solved for  y = u*x , and y stored in b. then the !  upper triangular system u*x = y  is solved for x. the calculations !  are so arranged that the innermost loops stay within columns. ! !# History ! !  * banslv written by carl de boor [5] !  * dbnslv from SLATEC library [1] !  * Jacob Williams, 5/10/2015 : converted to free-form Fortran. pure subroutine dbnslv ( w , nroww , nrow , nbandl , nbandu , b ) integer , intent ( in ) :: nroww !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. integer , intent ( in ) :: nrow !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. integer , intent ( in ) :: nbandl !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. integer , intent ( in ) :: nbandu !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. real ( wp ), dimension ( nroww , nrow ), intent ( in ) :: w !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. real ( wp ), dimension ( nrow ), intent ( inout ) :: b !! **in**: right side of the system to be solved !! **out**: the solution x, of order nrow integer :: i , j , jmax , middle , nrowm1 middle = nbandu + 1 if ( nrow /= 1 ) then nrowm1 = nrow - 1 if ( nbandl /= 0 ) then ! forward pass ! for i=1,2,...,nrow-1, subtract right side(i)*(i-th column of l) !                       from right side (below i-th row). do i = 1 , nrowm1 jmax = min ( nbandl , nrow - i ) do j = 1 , jmax b ( i + j ) = b ( i + j ) - b ( i ) * w ( middle + j , i ) end do end do end if ! backward pass ! for i=nrow,nrow-1,...,1, divide right side(i) by i-th diagonal !                          entry of u, then subtract right side(i)*(i-th column !                          of u) from right side (above i-th row). if ( nbandu <= 0 ) then ! a is lower triangular. do i = 1 , nrow b ( i ) = b ( i ) / w ( 1 , i ) end do return end if i = nrow do b ( i ) = b ( i ) / w ( middle , i ) jmax = min ( nbandu , i - 1 ) do j = 1 , jmax b ( i - j ) = b ( i - j ) - b ( i ) * w ( middle - j , i ) end do i = i - 1 if ( i <= 1 ) exit end do end if b ( 1 ) = b ( 1 ) / w ( middle , 1 ) end subroutine dbnslv !***************************************************************************************** !***************************************************************************************** !> Calculates the value of all (possibly) nonzero basis !  functions at x of order max(jhigh,(j+1)*(index-1)), where t(k) !  <= x <= t(n+1) and j=iwork is set inside the routine on !  the first call when index=1.  ileft is such that t(ileft) <= !  x < t(ileft+1).  a call to dintrv(t,n+1,x,ilo,ileft,mflag) !  produces the proper ileft.  dbspvn calculates using the basic !  algorithm needed in dbspvd.  if only basis functions are !  desired, setting jhigh=k and index=1 can be faster than !  calling dbspvd, but extra coding is required for derivatives !  (index=2) and dbspvd is set up for this purpose. ! !  left limiting values are set up as described in dbspvd. ! !#Error Conditions ! !  * improper input ! !# History ! !  * bsplvn written by carl de boor [5] !  * dbspvn author: amos, d. e., (snla) : date written 800901 !  * revision date 820801 !  * 000330 modified array declarations.  (jec) !  * Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. pure subroutine dbspvn ( t , jhigh , k , index , x , ileft , vnikx , work , iwork , iflag ) implicit none real ( wp ), dimension ( * ), intent ( in ) :: t !! knot vector of length n+k, where !! n = number of b-spline basis functions !! n = sum of knot multiplicities-k !! dimension t(ileft+jhigh) integer , intent ( in ) :: jhigh !! order of b-spline, 1 <= jhigh <= k integer , intent ( in ) :: k !! highest possible order integer , intent ( in ) :: index !! index = 1 gives basis functions of order jhigh !!       = 2 denotes previous entry with work, iwork !!         values saved for subsequent calls to !!         dbspvn. real ( wp ), intent ( in ) :: x !! argument of basis functions, t(k) <= x <= t(n+1) integer , intent ( in ) :: ileft !! largest integer such that t(ileft) <= x < t(ileft+1) real ( wp ), dimension ( k ), intent ( out ) :: vnikx !! vector of length k for spline values. real ( wp ), dimension ( * ), intent ( out ) :: work !! a work vector of length 2*k integer , intent ( out ) :: iwork !! a work parameter.  both work and iwork contain !! information necessary to continue for index = 2. !! when index = 1 exclusively, these are scratch !! variables and can be used for other purposes. integer , intent ( out ) :: iflag !!   0: no errors !! 201: k does not satisfy k>=1 !! 202: jhigh does not satisfy 1<=jhigh<=k !! 203: index is not 1 or 2 !! 204: x does not satisfy t(ileft)<=x<=t(ileft+1) integer :: imjp1 , ipj , jp1 , jp1ml , l real ( wp ) :: vm , vmprev ! content of j, deltam, deltap is expected unchanged between calls. ! work(i) = deltap(i), ! work(k+i) = deltam(i), i = 1,k if ( k < 1 ) then !write(error_unit,'(A)') 'dbspvn - k does not satisfy k>=1' iflag = 201 return end if if ( jhigh > k . or . jhigh < 1 ) then !write(error_unit,'(A)') 'dbspvn - jhigh does not satisfy 1<=jhigh<=k' iflag = 202 return end if if ( index < 1 . or . index > 2 ) then !write(error_unit,'(A)') 'dbspvn - index is not 1 or 2' iflag = 203 return end if if ( x < t ( ileft ) . or . x > t ( ileft + 1 )) then !write(error_unit,'(A)') 'dbspvn - x does not satisfy t(ileft)<=x<=t(ileft+1)' iflag = 204 return end if iflag = 0 if ( index == 1 ) then iwork = 1 vnikx ( 1 ) = 1.0_wp if ( iwork >= jhigh ) return end if do ipj = ileft + iwork work ( iwork ) = t ( ipj ) - x imjp1 = ileft - iwork + 1 work ( k + iwork ) = x - t ( imjp1 ) vmprev = 0.0_wp jp1 = iwork + 1 do l = 1 , iwork jp1ml = jp1 - l vm = vnikx ( l ) / ( work ( l ) + work ( k + jp1ml )) vnikx ( l ) = vm * work ( l ) + vmprev vmprev = vm * work ( k + jp1ml ) end do vnikx ( jp1 ) = vmprev iwork = jp1 if ( iwork >= jhigh ) exit end do end subroutine dbspvn !***************************************************************************************** !***************************************************************************************** !> Evaluates the b-representation (t,a,n,k) of a b-spline !  at x for the function value on ideriv=0 or any of its !  derivatives on ideriv=1,2,...,k-1.  right limiting values !  (right derivatives) are returned except at the right end !  point x=t(n+1) where left limiting values are computed.  the !  spline is defined on t(k) <= x <= t(n+1).  dbvalu returns !  a fatal error message when x is outside of this interval. ! !  to compute left derivatives or left limiting values at a !  knot t(i), replace n by i-1 and set x=t(i), i=k+1,n+1. ! !#Error Conditions ! !  * improper input ! !# History ! !  * bvalue written by carl de boor [5] !  * dbvalu author: amos, d. e., (snla) : date written 800901 !  * revision date 820801 !  * 000330 modified array declarations.  (jec) !  * Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. pure subroutine dbvalu ( t , a , n , k , ideriv , x , inbv , work , iflag , val ) implicit none real ( wp ), intent ( out ) :: val !! the interpolated value integer , intent ( in ) :: n !! number of b-spline coefficients. !! (sum of knot multiplicities-k) real ( wp ), dimension (:), intent ( in ) :: t !! knot vector of length n+k real ( wp ), dimension ( n ), intent ( in ) :: a !! b-spline coefficient vector of length n integer , intent ( in ) :: k !! order of the b-spline, k >= 1 integer , intent ( in ) :: ideriv !! order of the derivative, 0 <= ideriv <= k-1. !! ideriv = 0 returns the b-spline value real ( wp ), intent ( in ) :: x !! argument, t(k) <= x <= t(n+1) integer , intent ( inout ) :: inbv !! an initialization parameter which must be set !! to 1 the first time dbvalu is called. !! inbv contains information for efficient process- !! ing after the initial call and inbv must not !! be changed by the user.  distinct splines require !! distinct inbv parameters. real ( wp ), dimension (:), intent ( inout ) :: work !! work vector of length at least 3*k integer , intent ( out ) :: iflag !!   0: no errors !! 401: k does not satisfy k>=1 !! 402: n does not satisfy n>=k !! 403: ideriv does not satisfy 0<=ideriv<k !! 404: x is not greater than or equal to t(k) !! 405: x is not less than or equal to t(n+1) !! 406: a left limiting value cannot be obtained at t(k) integer :: i , iderp1 , ihi , ihmkmj , ilo , imk , imkpj , ipj ,& ip1 , ip1mj , j , jj , j1 , j2 , kmider , kmj , km1 , kpk , mflag real ( wp ) :: fkmj val = 0.0_wp if ( k < 1 ) then !write(error_unit,'(A)') 'dbvalu - k does not satisfy k>=1' iflag = 401 return end if if ( n < k ) then !write(error_unit,'(A)') 'dbvalu - n does not satisfy n>=k' iflag = 402 return end if if ( ideriv < 0 . or . ideriv >= k ) then !write(error_unit,'(A)') 'dbvalu - ideriv does not satisfy 0<=ideriv<k' iflag = 403 return end if kmider = k - ideriv ! find *i* in (k,n) such that t(i) <= x < t(i+1) ! (or, <= t(i+1) if t(i) < t(i+1) = t(n+1)). km1 = k - 1 call dintrv ( t , n + 1 , x , inbv , i , mflag ) if ( x < t ( k )) then !write(error_unit,'(A)') 'dbvalu - x is not greater than or equal to t(k)' iflag = 404 return end if if ( mflag /= 0 ) then if ( x > t ( i )) then !write(error_unit,'(A)') 'dbvalu - x is not less than or equal to t(n+1)' iflag = 405 return end if do if ( i == k ) then !write(error_unit,'(A)') 'dbvalu - a left limiting value cannot be obtained at t(k)' iflag = 406 return end if i = i - 1 if ( x /= t ( i )) exit end do end if ! difference the coefficients *ideriv* times ! work(i) = aj(i), work(k+i) = dp(i), work(k+k+i) = dm(i), i=1.k imk = i - k do j = 1 , k imkpj = imk + j work ( j ) = a ( imkpj ) end do if ( ideriv /= 0 ) then do j = 1 , ideriv kmj = k - j fkmj = real ( kmj , wp ) do jj = 1 , kmj ihi = i + jj ihmkmj = ihi - kmj work ( jj ) = ( work ( jj + 1 ) - work ( jj )) / ( t ( ihi ) - t ( ihmkmj )) * fkmj end do end do end if ! compute value at *x* in (t(i),(t(i+1)) of ideriv-th derivative, ! given its relevant b-spline coeff. in aj(1),...,aj(k-ideriv). if ( ideriv /= km1 ) then ip1 = i + 1 kpk = k + k j1 = k + 1 j2 = kpk + 1 do j = 1 , kmider ipj = i + j work ( j1 ) = t ( ipj ) - x ip1mj = ip1 - j work ( j2 ) = x - t ( ip1mj ) j1 = j1 + 1 j2 = j2 + 1 end do iderp1 = ideriv + 1 do j = iderp1 , km1 kmj = k - j ilo = kmj do jj = 1 , kmj work ( jj ) = ( work ( jj + 1 ) * work ( kpk + ilo ) + work ( jj ) * & work ( k + jj )) / ( work ( kpk + ilo ) + work ( k + jj )) ilo = ilo - 1 end do end do end if iflag = 0 val = work ( 1 ) end subroutine dbvalu !***************************************************************************************** !***************************************************************************************** !> Computes the largest integer ileft in 1 <= ileft <= lxt !  such that xt(ileft) <= x where xt(*) is a subdivision of !  the x interval. !  precisely, ! !```fortran !         if            x < xt(1)   then ileft=1,   mflag=-1 !         if   xt(i) <= x < xt(i+1) then ileft=i,   mflag=0 !         if xt(lxt) <= x           then ileft=lxt, mflag=1 !``` ! !  that is, when multiplicities are present in the break point !  to the left of x, the largest index is taken for ileft. ! !# History ! !  * interv written by carl de boor [5] !  * dintrv author: amos, d. e., (snla) : date written 800901 !  * revision date 820801 !  * Jacob Williams, 2/24/2015 : updated to free-form Fortran. !  * Jacob Williams, 2/17/2016 : additional refactoring (eliminated GOTOs). pure subroutine dintrv ( xt , lxt , x , ilo , ileft , mflag ) implicit none integer , intent ( in ) :: lxt !! length of the `xt` vector real ( wp ), dimension ( lxt ), intent ( in ) :: xt !! a knot or break point vector of length `lxt` real ( wp ), intent ( in ) :: x !! argument integer , intent ( inout ) :: ilo !! an initialization parameter which must be set !! to 1 the first time the spline array `xt` is !! processed by dintrv. `ilo` contains information for !! efficient processing after the initial call and `ilo` !! must not be changed by the user.  distinct splines !! require distinct i`lo parameters. integer , intent ( out ) :: ileft !! largest integer satisfying `xt(ileft) <= x` integer , intent ( out ) :: mflag !! signals when `x` lies out of bounds integer :: ihi , istep , middle ihi = ilo + 1 if ( ihi >= lxt ) then if ( x >= xt ( lxt ) ) then mflag = 1 ileft = lxt return end if if ( lxt <= 1 ) then mflag = - 1 ileft = 1 return end if ilo = lxt - 1 ihi = lxt endif if ( x >= xt ( ihi ) ) then ! now x >= xt(ilo). find upper bound istep = 1 do ilo = ihi ihi = ilo + istep if ( ihi >= lxt ) then if ( x >= xt ( lxt ) ) then mflag = 1 ileft = lxt return end if ihi = lxt elseif ( x >= xt ( ihi ) ) then istep = istep * 2 cycle endif exit end do else if ( x >= xt ( ilo ) ) then mflag = 0 ileft = ilo return end if ! now x <= xt(ihi). find lower bound istep = 1 do ihi = ilo ilo = ihi - istep if ( ilo <= 1 ) then ilo = 1 if ( x < xt ( 1 ) ) then mflag = - 1 ileft = 1 return end if elseif ( x < xt ( ilo ) ) then istep = istep * 2 cycle endif exit end do endif ! now xt(ilo) <= x < xt(ihi). narrow the interval do middle = ( ilo + ihi ) / 2 if ( middle == ilo ) then mflag = 0 ileft = ilo return end if ! note. it is assumed that middle = ilo in case ihi = ilo+1 if ( x < xt ( middle ) ) then ihi = middle else ilo = middle endif end do end subroutine dintrv !***************************************************************************************** !***************************************************************************************** !> !  Returns a message string associated with the status code. pure function get_status_message ( iflag ) result ( msg ) implicit none integer , intent ( in ) :: iflag !! return code from one of the routines character ( len = :), allocatable :: msg !! status message associated with the flag character ( len = 10 ) :: istr !! for integer to string conversion integer :: istat !! for write statement select case ( iflag ) case ( 0 ); msg = 'Successful execution' case ( 1 ); msg = 'Error in evaluate_*d: class is not initialized' case ( 2 ); msg = 'Error in db*ink: iknot out of range' case ( 3 ); msg = 'Error in db*ink: nx out of range' case ( 4 ); msg = 'Error in db*ink: kx out of range' case ( 5 ); msg = 'Error in db*ink: x not strictly increasing' case ( 6 ); msg = 'Error in db*ink: tx not non-decreasing' case ( 7 ); msg = 'Error in db*ink: ny out of range' case ( 8 ); msg = 'Error in db*ink: ky out of range' case ( 9 ); msg = 'Error in db*ink: y not strictly increasing' case ( 10 ); msg = 'Error in db*ink: ty not non-decreasing' case ( 11 ); msg = 'Error in db*ink: nz out of range' case ( 12 ); msg = 'Error in db*ink: kz out of range' case ( 13 ); msg = 'Error in db*ink: z not strictly increasing' case ( 14 ); msg = 'Error in db*ink: tz not non-decreasing' case ( 15 ); msg = 'Error in db*ink: nq out of range' case ( 16 ); msg = 'Error in db*ink: kq out of range' case ( 17 ); msg = 'Error in db*ink: q not strictly increasing' case ( 18 ); msg = 'Error in db*ink: tq not non-decreasing' case ( 19 ); msg = 'Error in db*ink: nr out of range' case ( 20 ); msg = 'Error in db*ink: kr out of range' case ( 21 ); msg = 'Error in db*ink: r not strictly increasing' case ( 22 ); msg = 'Error in db*ink: tr not non-decreasing' case ( 23 ); msg = 'Error in db*ink: ns out of range' case ( 24 ); msg = 'Error in db*ink: ks out of range' case ( 25 ); msg = 'Error in db*ink: s not strictly increasing' case ( 26 ); msg = 'Error in db*ink: ts not non-decreasing' case ( 700 ); msg = 'Error in db*ink: size(x) /= size(fcn,1)' case ( 701 ); msg = 'Error in db*ink: size(y) /= size(fcn,2)' case ( 702 ); msg = 'Error in db*ink: size(z) /= size(fcn,3)' case ( 703 ); msg = 'Error in db*ink: size(q) /= size(fcn,4)' case ( 704 ); msg = 'Error in db*ink: size(r) /= size(fcn,5)' case ( 705 ); msg = 'Error in db*ink: size(s) /= size(fcn,6)' case ( 706 ); msg = 'Error in db*ink: size(x) /= nx' case ( 707 ); msg = 'Error in db*ink: size(y) /= ny' case ( 708 ); msg = 'Error in db*ink: size(z) /= nz' case ( 709 ); msg = 'Error in db*ink: size(q) /= nq' case ( 710 ); msg = 'Error in db*ink: size(r) /= nr' case ( 711 ); msg = 'Error in db*ink: size(s) /= ns' case ( 712 ); msg = 'Error in db*ink: size(tx) /= nx+kx' case ( 713 ); msg = 'Error in db*ink: size(ty) /= ny+ky' case ( 714 ); msg = 'Error in db*ink: size(tz) /= nz+kz' case ( 715 ); msg = 'Error in db*ink: size(tq) /= nq+kq' case ( 716 ); msg = 'Error in db*ink: size(tr) /= nr+kr' case ( 717 ); msg = 'Error in db*ink: size(ts) /= ns+ks' case ( 800 ); msg = 'Error in db*ink: size(x) /= size(bcoef,1)' case ( 801 ); msg = 'Error in db*ink: size(y) /= size(bcoef,2)' case ( 802 ); msg = 'Error in db*ink: size(z) /= size(bcoef,3)' case ( 803 ); msg = 'Error in db*ink: size(q) /= size(bcoef,4)' case ( 804 ); msg = 'Error in db*ink: size(r) /= size(bcoef,5)' case ( 805 ); msg = 'Error in db*ink: size(s) /= size(bcoef,6)' case ( 100 ); msg = 'Error in dbintk: k does not satisfy k>=1' case ( 101 ); msg = 'Error in dbintk: n does not satisfy n>=k' case ( 102 ); msg = 'Error in dbintk: x(i) does not satisfy x(i)<x(i+1) for some i' case ( 103 ); msg = 'Error in dbintk: some abscissa was not in the support of the ' // & 'corresponding basis function and the system is singular' case ( 104 ); msg = 'Error in dbintk: the system of solver detects a singular system ' // & 'although the theoretical conditions for a solution were satisfied' case ( 201 ); msg = 'Error in dbspvn: k does not satisfy k>=1' case ( 202 ); msg = 'Error in dbspvn: jhigh does not satisfy 1<=jhigh<=k' case ( 203 ); msg = 'Error in dbspvn: index is not 1 or 2' case ( 204 ); msg = 'Error in dbspvn: x does not satisfy t(ileft)<=x<=t(ileft+1)' case ( 301 ); msg = 'Error in dbtpcf: n should be > 0' case ( 401 ); msg = 'Error in dbvalu: k does not satisfy k>=1' case ( 402 ); msg = 'Error in dbvalu: n does not satisfy n>=k' case ( 403 ); msg = 'Error in dbvalu: ideriv does not satisfy 0<=ideriv<k' case ( 404 ); msg = 'Error in dbvalu: x is not greater than or equal to t(k)' case ( 405 ); msg = 'Error in dbvalu: x is not less than or equal to t(n+1)' case ( 406 ); msg = 'Error in dbvalu: a left limiting value cannot be obtained at t(k)' case ( 501 ); msg = 'Error in initialize_*d_specify_knots: tx is not the correct size (kx+nx)' case ( 502 ); msg = 'Error in initialize_*d_specify_knots: ty is not the correct size (ky+ny)' case ( 503 ); msg = 'Error in initialize_*d_specify_knots: tz is not the correct size (kz+nz)' case ( 504 ); msg = 'Error in initialize_*d_specify_knots: tq is not the correct size (kq+nq)' case ( 505 ); msg = 'Error in initialize_*d_specify_knots: tr is not the correct size (kr+nr)' case ( 506 ); msg = 'Error in initialize_*d_specify_knots: ts is not the correct size (ks+ns)' case ( 601 ); msg = 'Error in db*val: x value out of bounds' case ( 602 ); msg = 'Error in db*val: y value out of bounds' case ( 603 ); msg = 'Error in db*val: z value out of bounds' case ( 604 ); msg = 'Error in db*val: q value out of bounds' case ( 605 ); msg = 'Error in db*val: r value out of bounds' case ( 606 ); msg = 'Error in db*val: s value out of bounds' case default write ( istr , fmt = '(I10)' , iostat = istat ) iflag msg = 'Unknown status flag: ' // trim ( adjustl ( istr )) end select end function get_status_message !***************************************************************************************** !***************************************************************************************** end module bspline_sub_module !*****************************************************************************************","tags":"","loc":"sourcefile/bspline_sub_module.f90.html","title":"bspline_sub_module.f90 – Photodissociation of water"},{"text":"Contents Programs dynamic_h2o Source Code dynamic.f90 Source Code !> The program solves classical Newton's Eq. for H2O \\\\ !> Non-adiabatic transitions take place according to Landau-Zener Surface Hopping algorithm (see J. Chem. Phys. 142, 104307 (2015)) \\\\ !> The PES must be given as follows rOH1, rOH2, angle_H1OH2, energies program dynamic_h2o implicit none integer , parameter :: npart = 3 double precision , dimension ( 3 , npart ) :: xyz , vxyz double precision , dimension ( npart ) :: mass double precision :: r1 , r2 , theta double precision :: ti , tf double precision :: dt , dr integer :: fsta character ( 64 ) :: fpot integer :: i , j , l ! reads the initial conditions write ( * , * ) \"!!!  Enter Oxygen first !!!\" read ( * , * ) dt , dr read ( * , * ) fpot , tf , fsta tf = tf * 41 d0 do i = 1 , npart read ( * , * ) mass ( i ), xyz ( 1 , i ), xyz ( 2 , i ), xyz ( 3 , i ), vxyz ( 1 , i ), vxyz ( 2 , i ), vxyz ( 3 , i ) write ( 100 , '(6(f20.15,1X))' ) xyz ( 1 , i ), xyz ( 2 , i ), xyz ( 3 , i ), vxyz ( 1 , i ), vxyz ( 2 , i ), vxyz ( 3 , i ) mass ( i ) = mass ( i ) * 183 6.15d0 enddo write ( 100 , * ) if ( mass ( 1 ) /= 1 6.0d0 * 183 6.15d0 ) then write ( * , * ) \"I said !!!  Enter Oxygen first !!!\" stop endif call compute_dist ( npart , xyz , r1 , r2 , theta ) write ( 10 , * ) r1 , r2 , theta ! starts with the dynamics ti = 0 d0 call dyn ( npart , mass , xyz , vxyz , ti , tf , fpot , fsta , dt , dr ) call compute_dist ( npart , xyz , r1 , r2 , theta ) write ( * , * ) r1 , r2 , theta write ( * , * ) do i = 1 , npart write ( 100 , '(6(f20.10,1X))' ) xyz (:, i ), vxyz (:, i ) enddo write ( 100 , * ) end program dynamic_h2o","tags":"","loc":"sourcefile/dynamic.f90.html","title":"dynamic.f90 – Photodissociation of water"},{"text":"Contents Modules bspline_module Source Code bspline_module.f90 Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !# Description ! !  Multidimensional (1D-6D) B-Spline interpolation of data on a regular grid. !  This module uses both the subroutine and object-oriented modules. module bspline_module use bspline_oo_module use bspline_sub_module implicit none public !***************************************************************************************** end module bspline_module !*****************************************************************************************","tags":"","loc":"sourcefile/bspline_module.f90.html","title":"bspline_module.f90 – Photodissociation of water"},{"text":"Contents Subroutines dyn compute_dist Source Code dynlib.f90 Source Code subroutine dyn ( npart , mass , xyz , vxyz , ti , tf , fpot , fsta , dt , dr ) use bspline_module use interpolation use RDistributions implicit none !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Nico 24.05.2016 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! performs the dynamics until tf                        !! ! uses Verlet algorithom                                !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! for the dynamics double precision , intent ( in ) :: dt , dr ! in atomic units double precision , intent ( inout ) :: ti , tf double precision , dimension ( 3 , npart ) :: xyzm , xyzt , xyznew , xyzdr double precision :: time , grade double precision , dimension (:), allocatable :: valdrp , valdrm , val ! for the system integer , intent ( in ) :: npart double precision , dimension ( npart ), intent ( in ) :: mass double precision , dimension ( 3 , npart ), intent ( inout ) :: xyz , vxyz !for the electronic state character ( 64 ) :: fpot !for Landau-Zener double precision , dimension (:), allocatable :: epair , epair_t1 , d_epair , d_epair_t1 , d2_epair double precision :: plz !for the interpolation integer :: nsta integer :: nr1 , nr2 , nthe double precision , dimension (:), allocatable :: r1 , r2 , the double precision , dimension (:,:,:,:), allocatable :: energy integer , intent ( inout ) :: fsta double precision , dimension (:,:), allocatable :: tr1 , tr2 , tthe integer , parameter :: kr1 = 4 !! order in r1 integer , parameter :: kr2 = 4 !! order in r2 integer , parameter :: kt = 2 !! order in theta integer , parameter :: iknot = 0 !! automatically select the knots double precision :: tol logical :: fail , file_e integer :: inbvx , inbvy , inbvz integer :: iloy , iloz , iflag integer :: idr1 , idr2 , idthe double precision :: newr1 , newr2 , newthe integer :: i , j , k , ista ! Reads the data inquire ( file = trim ( fpot ), exist = file_e ) if ( file_e . eqv . . false . ) then write ( * , * ) trim ( fpot ), \" does not exist\" stop endif write ( * , '(A,A)' ) 'Read PESs in ' , trim ( fpot ) open ( unit = 10 , file = trim ( fpot )) read ( 10 , * ) nr1 , nr2 , nthe , nsta write ( * , '(A,I4,A,I4,A,I4,A)' ) 'There are' , nr1 , ' * ' , nr2 , ' * ' , nthe , ' points' write ( * , '(A,I4,A)' ) 'There are' , nsta , 'states' allocate ( r1 ( nr1 ), r2 ( nr2 ), the ( nthe )) allocate ( energy ( nsta , nr2 , nr1 , nthe )) ! do i = 1 , nr2 do j = 1 , nr1 do k = 1 , nthe read ( 10 , * ) r2 ( i ), r1 ( j ), the ( k ),( energy ( ista , i , j , k ), ista = 1 , nsta ) !      write(*,'(5(f20.10,1X))')r2(i),r1(j),the(k),(energy(ista,i,j,k),ista=1,nsta) enddo enddo enddo close ( 10 ) write ( * , '(A)' ) 'Reading PESs done ' !!energy(:,:,:,:)=0d0 allocate ( epair ( nsta ), epair_t1 ( nsta ), d_epair ( nsta ), d_epair_t1 ( nsta ), d2_epair ( nsta )) d_epair_t1 (:) = 0 d0 epair_t1 (:) = 0 d0 ! ! Set-up the interpolation inbvx = 1 inbvy = 1 inbvz = 1 iloy = 1 iloz = 1 idr1 = 0 idr2 = 0 idthe = 0 fail = . false . tol = 1.0e-14 allocate ( tr1 ( nsta , nr1 + kr1 ), tr2 ( nsta , nr2 + kr2 ), tthe ( nsta , nthe + kt )) allocate ( val ( nsta ), valdrp ( nsta ), valdrm ( nsta )) do ista = 1 , nsta iflag = 0 call db3ink ( r2 , nr2 , r1 , nr1 , the , nthe , energy ( ista ,:,:,:), kr1 , kr2 , kt , iknot , tr2 ( ista ,:), tr1 ( ista ,:), tthe ( ista ,:), energy ( ista ,:,:,:), iflag ) if ( iflag /= 0 ) then write ( * , * ) \"error in db3ink\" , iflag return endif enddo ! landau-zenner surf. hopp. stuff call compute_dist ( npart , xyz , newr1 , newr2 , newthe ) do ista = 1 , nsta call db3val ( newr2 , newr1 , newthe , idr1 , idr2 , idthe , tr2 ( ista ,:), tr1 ( ista ,:), tthe ( ista ,:), nr2 , nr1 , nthe , kr1 , kr2 , kt , energy ( ista ,:,:,:), val ( ista ), iflag ,& inbvx , inbvy , inbvz , iloy , iloz ) if ( iflag /= 0 ) then write ( * , * ) \"error in db3val at time\" , time stop endif enddo do ista = 1 , nsta epair ( ista ) = abs ( val ( ista ) - val ( fsta )) enddo ! first step of the Verlet algorithm do i = 1 , npart do j = 1 , 3 xyzm ( j , i ) = xyz ( j , i ) xyzt ( j , i ) = xyz ( j , i ) + vxyz ( j , i ) * dt enddo enddo time = ti do while ( time < tf ) ! landau-zenner surf. hopp. stuff epair_t1 (:) = epair (:) d_epair_t1 (:) = d_epair (:) epair (:) = 0 d0 ! computes the energy at position at time t call compute_dist ( npart , xyz , newr1 , newr2 , newthe ) do ista = 1 , nsta call db3val ( newr2 , newr1 , newthe , idr1 , idr2 , idthe , tr2 ( ista ,:), tr1 ( ista ,:), tthe ( ista ,:), nr2 , nr1 , nthe , kr1 , kr2 , kt , energy ( ista ,:,:,:), val ( ista ), iflag ,& inbvx , inbvy , inbvz , iloy , iloz ) write ( 200 , '(5(f20.10,1X),i3)' ) time , newr1 , newr2 , newthe , val ( fsta ), fsta if ( iflag /= 0 ) then write ( * , * ) \"error in db3val at time\" , time stop endif enddo ! apply LZ surface hopping here do ista = 1 , nsta epair ( ista ) = abs ( val ( ista ) - val ( fsta )) enddo d_epair (:) = ( epair (:) - epair_t1 (:)) / dt d2_epair (:) = ( d_epair (:) - d_epair_t1 (:)) / dt do ista = 1 , nsta if ( d_epair ( ista ) * d_epair_t1 ( ista ) < 0 d0 . and . d2_epair ( ista ) > 0 d0 ) then plz = exp ( - 0.5d0 * pi * sqrt ( epair ( ista ) ** 3 / d2_epair ( ista ))) if ( plz > rand_uniform ( 0 d0 , 1 d0 )) then write ( * , * ) \"HOP\" fsta = ista epair_t1 (:) = 0 d0 epair (:) = 0 d0 d_epair (:) = 0 d0 d_epair_t1 (:) = 0 d0 exit ! only one hop allowed endif endif enddo !! end surface hopping ! computes the new position do i = 1 , npart do j = 1 , 3 xyzdr (:,:) = xyzt (:,:) xyzdr ( j , i ) = xyzt ( j , i ) + dr call compute_dist ( npart , xyz , newr1 , newr2 , newthe ) do ista = 1 , nsta call db3val ( newr2 , newr1 , newthe , idr1 , idr2 , idthe , tr2 ( ista ,:), tr1 ( ista ,:), tthe ( ista ,:), nr2 , nr1 , nthe , kr1 , kr2 , kt , energy ( ista ,:,:,:), valdrp ( ista ), iflag ,& inbvx , inbvy , inbvz , iloy , iloz ) enddo !    write(*,'(i4,i4,5(f15.5))')j,i,newr1,newr2,newthe,valdrp(fsta) xyzdr (:,:) = xyzt (:,:) xyzdr ( j , i ) = xyzt ( j , i ) - dr call compute_dist ( npart , xyz , newr1 , newr2 , newthe ) do ista = 1 , nsta call db3val ( newr2 , newr1 , newthe , idr1 , idr2 , idthe , tr2 ( ista ,:), tr1 ( ista ,:), tthe ( ista ,:), nr2 , nr1 , nthe , kr1 , kr2 , kt , energy ( ista ,:,:,:), valdrp ( ista ), iflag ,& inbvx , inbvy , inbvz , iloy , iloz ) enddo !    write(*,'(i4,i4,5(f15.5))')j,i,newr1,newr2,newthe,valdrm(fsta) grade = 0.5 * ( ( valdrp ( fsta ) - val ( fsta )) / dr - ( valdrm ( fsta ) - val ( fsta )) / dr ) !    write(*,'(i4,i4,5(f15.5))')j,i,grade,newr,newrh2,newthe !    write(*,*) xyznew ( j , i ) = 2 * xyzt ( j , i ) - xyzm ( j , i ) - grade * dt ** 2 / mass ( i ) enddo enddo xyzm (:,:) = xyzt (:,:) xyzt (:,:) = xyznew (:,:) time = time + dt enddo !stop xyz (:,:) = xyznew (:,:) vxyz (:,:) = ( xyzt (:,:) - xyzm (:,:)) / dt deallocate ( r1 , r2 , the , energy ) deallocate ( tr1 , tr2 , tthe ) deallocate ( val , valdrp , valdrm ) deallocate ( epair , epair_t1 , d_epair , d2_epair ) end subroutine dyn subroutine compute_dist ( npart , xyz , r1 , r2 , theta ) implicit none integer , intent ( in ) :: npart double precision , dimension ( 3 , npart ), intent ( in ) :: xyz double precision :: r1 , r2 , costhe , theta ! atom 1 must be oxygen ! atoms 2 and 3 are then hydrogen r1 = sqrt ( ( xyz ( 1 , 1 ) - xyz ( 1 , 2 )) ** 2 + ( xyz ( 2 , 1 ) - xyz ( 2 , 2 )) ** 2 + ( xyz ( 3 , 1 ) - xyz ( 3 , 2 )) ** 2 ) r2 = sqrt ( ( xyz ( 1 , 1 ) - xyz ( 1 , 3 )) ** 2 + ( xyz ( 2 , 1 ) - xyz ( 2 , 3 )) ** 2 + ( xyz ( 3 , 1 ) - xyz ( 3 , 3 )) ** 2 ) costhe = ( ( xyz ( 1 , 2 ) - xyz ( 1 , 1 )) * ( xyz ( 1 , 3 ) - xyz ( 1 , 1 )) + ( xyz ( 2 , 2 ) - xyz ( 2 , 1 )) * ( xyz ( 2 , 3 ) - xyz ( 2 , 1 )) + ( xyz ( 3 , 2 ) - xyz ( 3 , 1 )) * ( xyz ( 3 , 3 ) - xyz ( 3 , 1 )) ) / ( r1 * r2 ) theta = dacos ( costhe ) * 180 d0 / dacos ( - 1 d0 ) end subroutine compute_dist","tags":"","loc":"sourcefile/dynlib.f90.html","title":"dynlib.f90 – Photodissociation of water"},{"text":"Contents Subroutines init_random_seed Source Code misc.f90 Source Code SUBROUTINE init_random_seed () INTEGER :: i , n , clock INTEGER , DIMENSION (:), ALLOCATABLE :: seed CALL RANDOM_SEED ( size = n ) ALLOCATE ( seed ( n )) CALL SYSTEM_CLOCK ( COUNT = clock ) seed = clock + 37 * ( / ( i - 1 , i = 1 , n ) / ) CALL RANDOM_SEED ( PUT = seed ) DEALLOCATE ( seed ) END SUBROUTINE","tags":"","loc":"sourcefile/misc.f90.html","title":"misc.f90 – Photodissociation of water"},{"text":"Contents Modules interpolation Source Code interp.f90 Source Code module interpolation implicit none contains !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine interp ( xa , ya , n , x , y ) implicit none integer , intent ( in ) :: n double precision , dimension ( n ), intent ( in ) :: xa , ya double precision :: x , y double precision :: a integer :: i , j !! Linear interpolation ! searching for two closer points of x in xa ! xa must be ascending sorted if ( x . lt . xa ( 1 ) . or . x . gt . xa ( n )) then write ( * , * ) 'x out of range in interp, I stop' , x stop endif ! call hunt(xa,n,x,i) call locate ( xa , n , x , i ) a = ( ya ( i + 1 ) - ya ( i )) / ( xa ( i + 1 ) - xa ( i )) y = ya ( i ) + a * ( x - xa ( i )) end subroutine interp !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE hunt ( xx , n , x , jlo ) INTEGER jlo , n REAL * 8 x , xx ( n ) INTEGER inc , jhi , jm LOGICAL ascnd ascnd = xx ( n ). gt . xx ( 1 ) if ( jlo . le . 0. or . jlo . gt . n ) then jlo = 0 jhi = n + 1 goto 3 endif inc = 1 if ( x . ge . xx ( jlo ). eqv . ascnd ) then 1 jhi = jlo + inc if ( jhi . gt . n ) then jhi = n + 1 else if ( x . ge . xx ( jhi ). eqv . ascnd ) then jlo = jhi inc = inc + inc goto 1 endif else jhi = jlo 2 jlo = jhi - inc if ( jlo . lt . 1 ) then jlo = 0 else if ( x . lt . xx ( jlo ). eqv . ascnd ) then jhi = jlo inc = inc + inc goto 2 endif endif 3 if ( jhi - jlo . eq . 1 ) return jm = ( jhi + jlo ) / 2 if ( x . gt . xx ( jm ). eqv . ascnd ) then jlo = jm else jhi = jm endif goto 3 END SUBROUTINE hunt !  (C) Copr. 1986-92 Numerical Recipes Software #>.)@1. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE locate ( xx , n , x , j ) INTEGER j , n REAL * 8 x , xx ( n ) INTEGER jl , jm , ju jl = 0 ju = n + 1 10 if ( ju - jl . gt . 1 ) then jm = ( ju + jl ) / 2 if (( xx ( n ). gt . xx ( 1 )). eqv .( x . gt . xx ( jm ))) then jl = jm else ju = jm endif goto 10 endif j = jl return END SUBROUTINE locate !  (C) Copr. 1986-92 Numerical Recipes Software #>.)@1. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! end module interpolation","tags":"","loc":"sourcefile/interp.f90.html","title":"interp.f90 – Photodissociation of water"},{"text":"Contents Modules bspline_oo_module Source Code bspline_oo_module.f90 Source Code !***************************************************************************************** !> !  author: Jacob Williams !  license: BSD !  date: 12/6/2015 ! !# Description ! !  Object-oriented style wrappers to [[bspline_sub_module]]. !  This module provides classes ([[bspline_1d]], [[bspline_2d]], !  [[bspline_3d]], [[bspline_4d]], [[bspline_5d]], and [[bspline_6d]]) !  which can be used instead of the main subroutine interface. module bspline_oo_module use , intrinsic :: iso_fortran_env , only : wp => real64 use , intrinsic :: iso_fortran_env , only : error_unit use bspline_sub_module implicit none private type , public , abstract :: bspline_class !! Base class for the b-spline types private integer :: inbvx = 1 !! internal variable used by dbvalu for efficient processing integer :: iflag = 1 !! saved `iflag` from the list routine call. logical :: initialized = . false . !! true if the class is initialized and ready to use contains private procedure , non_overridable :: destroy_base !! destructor for the abstract type procedure ( destroy_func ), deferred , public :: destroy !! destructor procedure , public , non_overridable :: status_ok !! returns true if the last `iflag` status code was `=0`. procedure , public , non_overridable :: status_message => get_bspline_status_message !! retrieve the last status message procedure , public , non_overridable :: clear_flag => clear_bspline_flag !! to reset the `iflag` saved in the class. end type bspline_class abstract interface pure subroutine destroy_func ( me ) !! interface for bspline destructor routines import :: bspline_class implicit none class ( bspline_class ), intent ( inout ) :: me end subroutine destroy_func end interface type , extends ( bspline_class ), public :: bspline_1d !! Class for 1d b-spline interpolation. private integer :: nx = 0 integer :: kx = 0 real ( wp ), dimension (:), allocatable :: bcoef real ( wp ), dimension (:), allocatable :: tx contains private generic , public :: initialize => initialize_1d_auto_knots , initialize_1d_specify_knots procedure :: initialize_1d_auto_knots procedure :: initialize_1d_specify_knots procedure , public :: evaluate => evaluate_1d procedure , public :: destroy => destroy_1d final :: finalize_1d end type bspline_1d type , extends ( bspline_class ), public :: bspline_2d !! Class for 2d b-spline interpolation. private integer :: nx = 0 integer :: ny = 0 integer :: kx = 0 integer :: ky = 0 real ( wp ), dimension (:,:), allocatable :: bcoef real ( wp ), dimension (:), allocatable :: tx real ( wp ), dimension (:), allocatable :: ty integer :: inbvy = 1 integer :: iloy = 1 contains private generic , public :: initialize => initialize_2d_auto_knots , initialize_2d_specify_knots procedure :: initialize_2d_auto_knots procedure :: initialize_2d_specify_knots procedure , public :: evaluate => evaluate_2d procedure , public :: destroy => destroy_2d final :: finalize_2d end type bspline_2d type , extends ( bspline_class ), public :: bspline_3d !! Class for 3d b-spline interpolation. private integer :: nx = 0 integer :: ny = 0 integer :: nz = 0 integer :: kx = 0 integer :: ky = 0 integer :: kz = 0 real ( wp ), dimension (:,:,:), allocatable :: bcoef real ( wp ), dimension (:), allocatable :: tx real ( wp ), dimension (:), allocatable :: ty real ( wp ), dimension (:), allocatable :: tz integer :: inbvy = 1 integer :: inbvz = 1 integer :: iloy = 1 integer :: iloz = 1 contains private generic , public :: initialize => initialize_3d_auto_knots , initialize_3d_specify_knots procedure :: initialize_3d_auto_knots procedure :: initialize_3d_specify_knots procedure , public :: evaluate => evaluate_3d procedure , public :: destroy => destroy_3d final :: finalize_3d end type bspline_3d type , extends ( bspline_class ), public :: bspline_4d !! Class for 4d b-spline interpolation. private integer :: nx = 0 integer :: ny = 0 integer :: nz = 0 integer :: nq = 0 integer :: kx = 0 integer :: ky = 0 integer :: kz = 0 integer :: kq = 0 real ( wp ), dimension (:,:,:,:), allocatable :: bcoef real ( wp ), dimension (:), allocatable :: tx real ( wp ), dimension (:), allocatable :: ty real ( wp ), dimension (:), allocatable :: tz real ( wp ), dimension (:), allocatable :: tq integer :: inbvy = 1 integer :: inbvz = 1 integer :: inbvq = 1 integer :: iloy = 1 integer :: iloz = 1 integer :: iloq = 1 contains private generic , public :: initialize => initialize_4d_auto_knots , initialize_4d_specify_knots procedure :: initialize_4d_auto_knots procedure :: initialize_4d_specify_knots procedure , public :: evaluate => evaluate_4d procedure , public :: destroy => destroy_4d final :: finalize_4d end type bspline_4d type , extends ( bspline_class ), public :: bspline_5d !! Class for 5d b-spline interpolation. private integer :: nx = 0 integer :: ny = 0 integer :: nz = 0 integer :: nq = 0 integer :: nr = 0 integer :: kx = 0 integer :: ky = 0 integer :: kz = 0 integer :: kq = 0 integer :: kr = 0 real ( wp ), dimension (:,:,:,:,:), allocatable :: bcoef real ( wp ), dimension (:), allocatable :: tx real ( wp ), dimension (:), allocatable :: ty real ( wp ), dimension (:), allocatable :: tz real ( wp ), dimension (:), allocatable :: tq real ( wp ), dimension (:), allocatable :: tr integer :: inbvy = 1 integer :: inbvz = 1 integer :: inbvq = 1 integer :: inbvr = 1 integer :: iloy = 1 integer :: iloz = 1 integer :: iloq = 1 integer :: ilor = 1 contains private generic , public :: initialize => initialize_5d_auto_knots , initialize_5d_specify_knots procedure :: initialize_5d_auto_knots procedure :: initialize_5d_specify_knots procedure , public :: evaluate => evaluate_5d procedure , public :: destroy => destroy_5d final :: finalize_5d end type bspline_5d type , extends ( bspline_class ), public :: bspline_6d !! Class for 6d b-spline interpolation. private integer :: nx = 0 integer :: ny = 0 integer :: nz = 0 integer :: nq = 0 integer :: nr = 0 integer :: ns = 0 integer :: kx = 0 integer :: ky = 0 integer :: kz = 0 integer :: kq = 0 integer :: kr = 0 integer :: ks = 0 real ( wp ), dimension (:,:,:,:,:,:), allocatable :: bcoef real ( wp ), dimension (:), allocatable :: tx real ( wp ), dimension (:), allocatable :: ty real ( wp ), dimension (:), allocatable :: tz real ( wp ), dimension (:), allocatable :: tq real ( wp ), dimension (:), allocatable :: tr real ( wp ), dimension (:), allocatable :: ts integer :: inbvy = 1 integer :: inbvz = 1 integer :: inbvq = 1 integer :: inbvr = 1 integer :: inbvs = 1 integer :: iloy = 1 integer :: iloz = 1 integer :: iloq = 1 integer :: ilor = 1 integer :: ilos = 1 contains private generic , public :: initialize => initialize_6d_auto_knots , initialize_6d_specify_knots procedure :: initialize_6d_auto_knots procedure :: initialize_6d_specify_knots procedure , public :: evaluate => evaluate_6d procedure , public :: destroy => destroy_6d final :: finalize_6d end type bspline_6d interface bspline_1d procedure :: bspline_1d_constructor_empty ,& bspline_1d_constructor_auto_knots ,& bspline_1d_constructor_specify_knots end interface interface bspline_2d procedure :: bspline_2d_constructor_empty ,& bspline_2d_constructor_auto_knots ,& bspline_2d_constructor_specify_knots end interface interface bspline_3d procedure :: bspline_3d_constructor_empty ,& bspline_3d_constructor_auto_knots ,& bspline_3d_constructor_specify_knots end interface interface bspline_4d procedure :: bspline_4d_constructor_empty ,& bspline_4d_constructor_auto_knots ,& bspline_4d_constructor_specify_knots end interface interface bspline_5d procedure :: bspline_5d_constructor_empty ,& bspline_5d_constructor_auto_knots ,& bspline_5d_constructor_specify_knots end interface interface bspline_6d procedure :: bspline_6d_constructor_empty ,& bspline_6d_constructor_auto_knots ,& bspline_6d_constructor_specify_knots end interface contains !***************************************************************************************** !***************************************************************************************** !> !  This routines returns true if the `iflag` code from the last !  routine called was `=0`. Maybe of the routines have output `iflag` !  variables, so they can be checked explicitly, or this routine !  can be used. ! !  If the class is initialized using a function constructor, then !  this is the only way to know if it was properly initialized, !  since those are pure functions with not output `iflag` arguments. ! !  If `status_ok=.false.`, then the error message can be !  obtained from the [[get_bspline_status_message]] routine. ! !  Note: after an error condition, the [[clear_bspline_flag]] routine !  can be called to reset the `iflag` to 0. elemental function status_ok ( me ) result ( ok ) implicit none class ( bspline_class ), intent ( in ) :: me logical :: ok ok = ( me % iflag == 0 ) end function status_ok !***************************************************************************************** !***************************************************************************************** !> !  This sets the `iflag` variable in the class to `0` !  (which indicates that everything is OK). It can be used !  after an error is encountered. elemental subroutine clear_bspline_flag ( me ) implicit none class ( bspline_class ), intent ( inout ) :: me me % iflag = 0 end subroutine clear_bspline_flag !***************************************************************************************** !***************************************************************************************** !> !  Get the status message from a [[bspline_class]] routine call. ! !  If `iflag` is not included, then the one in the class is used (which !  corresponds to the last routine called.) !  Otherwise, it will convert the !  input `iflag` argument into the appropriate message. ! !  This is a wrapper for [[get_status_message]]. pure function get_bspline_status_message ( me , iflag ) result ( msg ) implicit none class ( bspline_class ), intent ( in ) :: me character ( len = :), allocatable :: msg !! status message associated with the flag integer , intent ( in ), optional :: iflag !! the corresponding status code if ( present ( iflag )) then msg = get_status_message ( iflag ) else msg = get_status_message ( me % iflag ) end if end function get_bspline_status_message !***************************************************************************************** !***************************************************************************************** !> !  Destructor for contents of the base [[bspline_class]] class. !  (this routine is called by the extended classes). pure subroutine destroy_base ( me ) implicit none class ( bspline_class ), intent ( inout ) :: me me % inbvx = 1 me % iflag = 1 me % initialized = . false . end subroutine destroy_base !***************************************************************************************** !***************************************************************************************** !> !  Destructor for [[bspline_1d]] class. pure subroutine destroy_1d ( me ) implicit none class ( bspline_1d ), intent ( inout ) :: me call me % destroy_base () me % nx = 0 me % kx = 0 if ( allocated ( me % bcoef )) deallocate ( me % bcoef ) if ( allocated ( me % tx )) deallocate ( me % tx ) end subroutine destroy_1d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for [[bspline_2d]] class. pure subroutine destroy_2d ( me ) implicit none class ( bspline_2d ), intent ( inout ) :: me call me % destroy_base () me % nx = 0 me % ny = 0 me % kx = 0 me % ky = 0 me % inbvy = 1 me % iloy = 1 if ( allocated ( me % bcoef )) deallocate ( me % bcoef ) if ( allocated ( me % tx )) deallocate ( me % tx ) if ( allocated ( me % ty )) deallocate ( me % ty ) end subroutine destroy_2d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for [[bspline_3d]] class. pure subroutine destroy_3d ( me ) implicit none class ( bspline_3d ), intent ( inout ) :: me call me % destroy_base () me % nx = 0 me % ny = 0 me % nz = 0 me % kx = 0 me % ky = 0 me % kz = 0 me % inbvy = 1 me % inbvz = 1 me % iloy = 1 me % iloz = 1 if ( allocated ( me % bcoef )) deallocate ( me % bcoef ) if ( allocated ( me % tx )) deallocate ( me % tx ) if ( allocated ( me % ty )) deallocate ( me % ty ) if ( allocated ( me % tz )) deallocate ( me % tz ) end subroutine destroy_3d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for [[bspline_4d]] class. pure subroutine destroy_4d ( me ) implicit none class ( bspline_4d ), intent ( inout ) :: me me % nx = 0 me % ny = 0 me % nz = 0 me % nq = 0 me % kx = 0 me % ky = 0 me % kz = 0 me % kq = 0 me % inbvy = 1 me % inbvz = 1 me % inbvq = 1 me % iloy = 1 me % iloz = 1 me % iloq = 1 if ( allocated ( me % bcoef )) deallocate ( me % bcoef ) if ( allocated ( me % tx )) deallocate ( me % tx ) if ( allocated ( me % ty )) deallocate ( me % ty ) if ( allocated ( me % tz )) deallocate ( me % tz ) if ( allocated ( me % tq )) deallocate ( me % tq ) end subroutine destroy_4d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for [[bspline_5d]] class. pure subroutine destroy_5d ( me ) implicit none class ( bspline_5d ), intent ( inout ) :: me me % nx = 0 me % ny = 0 me % nz = 0 me % nq = 0 me % nr = 0 me % kx = 0 me % ky = 0 me % kz = 0 me % kq = 0 me % kr = 0 me % inbvy = 1 me % inbvz = 1 me % inbvq = 1 me % inbvr = 1 me % iloy = 1 me % iloz = 1 me % iloq = 1 me % ilor = 1 if ( allocated ( me % bcoef )) deallocate ( me % bcoef ) if ( allocated ( me % tx )) deallocate ( me % tx ) if ( allocated ( me % ty )) deallocate ( me % ty ) if ( allocated ( me % tz )) deallocate ( me % tz ) if ( allocated ( me % tq )) deallocate ( me % tq ) if ( allocated ( me % tr )) deallocate ( me % tr ) end subroutine destroy_5d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for [[bspline_6d]] class. pure subroutine destroy_6d ( me ) implicit none class ( bspline_6d ), intent ( inout ) :: me me % nx = 0 me % ny = 0 me % nz = 0 me % nq = 0 me % nr = 0 me % ns = 0 me % kx = 0 me % ky = 0 me % kz = 0 me % kq = 0 me % kr = 0 me % ks = 0 me % inbvy = 1 me % inbvz = 1 me % inbvq = 1 me % inbvr = 1 me % inbvs = 1 me % iloy = 1 me % iloz = 1 me % iloq = 1 me % ilor = 1 me % ilos = 1 if ( allocated ( me % bcoef )) deallocate ( me % bcoef ) if ( allocated ( me % tx )) deallocate ( me % tx ) if ( allocated ( me % ty )) deallocate ( me % ty ) if ( allocated ( me % tz )) deallocate ( me % tz ) if ( allocated ( me % tq )) deallocate ( me % tq ) if ( allocated ( me % tr )) deallocate ( me % tr ) if ( allocated ( me % ts )) deallocate ( me % ts ) end subroutine destroy_6d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for [[bspline_1d]] class. Just a wrapper for [[destroy_1d]]. pure elemental subroutine finalize_1d ( me ) type ( bspline_1d ), intent ( inout ) :: me ; call me % destroy () end subroutine finalize_1d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for [[bspline_2d]] class. Just a wrapper for [[destroy_2d]]. pure elemental subroutine finalize_2d ( me ) type ( bspline_2d ), intent ( inout ) :: me ; call me % destroy () end subroutine finalize_2d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for [[bspline_3d]] class. Just a wrapper for [[destroy_3d]]. pure elemental subroutine finalize_3d ( me ) type ( bspline_3d ), intent ( inout ) :: me ; call me % destroy () end subroutine finalize_3d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for [[bspline_4d]] class. Just a wrapper for [[destroy_4d]]. pure elemental subroutine finalize_4d ( me ) type ( bspline_4d ), intent ( inout ) :: me ; call me % destroy () end subroutine finalize_4d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for [[bspline_5d]] class. Just a wrapper for [[destroy_5d]]. pure elemental subroutine finalize_5d ( me ) type ( bspline_5d ), intent ( inout ) :: me ; call me % destroy () end subroutine finalize_5d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for [[bspline_6d]] class. Just a wrapper for [[destroy_6d]]. pure elemental subroutine finalize_6d ( me ) type ( bspline_6d ), intent ( inout ) :: me ; call me % destroy () end subroutine finalize_6d !***************************************************************************************** !***************************************************************************************** !> !  It returns an empty [[bspline_1d]] type. Note that INITIALIZE still !  needs to be called before it can be used. !  Not really that useful except perhaps in some OpenMP applications. pure elemental function bspline_1d_constructor_empty () result ( me ) implicit none type ( bspline_1d ) :: me end function bspline_1d_constructor_empty !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[bspline_1d]] type (auto knots). !  This is a wrapper for [[initialize_1d_auto_knots]]. pure function bspline_1d_constructor_auto_knots ( x , fcn , kx ) result ( me ) implicit none type ( bspline_1d ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: fcn integer , intent ( in ) :: kx call initialize_1d_auto_knots ( me , x , fcn , kx , me % iflag ) end function bspline_1d_constructor_auto_knots !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[bspline_1d]] type (user-specified knots). !  This is a wrapper for [[initialize_1d_specify_knots]]. pure function bspline_1d_constructor_specify_knots ( x , fcn , kx , tx ) result ( me ) implicit none type ( bspline_1d ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: fcn integer , intent ( in ) :: kx real ( wp ), dimension (:), intent ( in ) :: tx call initialize_1d_specify_knots ( me , x , fcn , kx , tx , me % iflag ) end function bspline_1d_constructor_specify_knots !***************************************************************************************** !***************************************************************************************** !> !  Initialize a [[bspline_1d]] type (with automatically-computed knots). !  This is a wrapper for [[db1ink]]. pure subroutine initialize_1d_auto_knots ( me , x , fcn , kx , iflag ) implicit none class ( bspline_1d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( out ) :: iflag integer :: iknot integer :: nx call me % destroy () nx = size ( x ) me % nx = nx me % kx = kx allocate ( me % tx ( nx + kx )) allocate ( me % bcoef ( nx )) iknot = 0 !knot sequence chosen by db1ink call db1ink ( x , nx , fcn , kx , iknot , me % tx , me % bcoef , iflag ) me % initialized = iflag == 0 me % iflag = iflag end subroutine initialize_1d_auto_knots !***************************************************************************************** !***************************************************************************************** !> !  Initialize a [[bspline_1d]] type (with user-specified knots). !  This is a wrapper for [[db1ink]]. pure subroutine initialize_1d_specify_knots ( me , x , fcn , kx , tx , iflag ) implicit none class ( bspline_1d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: fcn integer , intent ( in ) :: kx real ( wp ), dimension (:), intent ( in ) :: tx integer , intent ( out ) :: iflag integer :: nx call me % destroy () nx = size ( x ) call check_knot_vectors_sizes ( 'initialize_1d_specify_knots' , nx = nx , kx = kx , tx = tx , iflag = iflag ) if ( iflag == 0 ) then me % nx = nx me % kx = kx allocate ( me % tx ( nx + kx )) allocate ( me % bcoef ( nx )) me % tx = tx call db1ink ( x , nx , fcn , kx , 1 , me % tx , me % bcoef , iflag ) end if me % initialized = iflag == 0 me % iflag = iflag end subroutine initialize_1d_specify_knots !***************************************************************************************** !***************************************************************************************** !> !  Evaluate a [[bspline_1d]] interpolate.  This is a wrapper for [[db1val]]. pure subroutine evaluate_1d ( me , xval , idx , f , iflag ) implicit none class ( bspline_1d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: xval integer , intent ( in ) :: idx real ( wp ), intent ( out ) :: f integer , intent ( out ) :: iflag if ( me % initialized ) then call db1val ( xval , idx , me % tx , me % nx , me % kx , me % bcoef , f , iflag , me % inbvx ) else iflag = 1 end if me % iflag = iflag end subroutine evaluate_1d !***************************************************************************************** !***************************************************************************************** !> !  It returns an empty [[bspline_2d]] type. Note that INITIALIZE still !  needs to be called before it can be used. !  Not really that useful except perhaps in some OpenMP applications. elemental function bspline_2d_constructor_empty () result ( me ) implicit none type ( bspline_2d ) :: me end function bspline_2d_constructor_empty !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[bspline_2d]] type (auto knots). !  This is a wrapper for [[initialize_2d_auto_knots]]. pure function bspline_2d_constructor_auto_knots ( x , y , fcn , kx , ky ) result ( me ) implicit none type ( bspline_2d ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky call initialize_2d_auto_knots ( me , x , y , fcn , kx , ky , me % iflag ) end function bspline_2d_constructor_auto_knots !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[bspline_2d]] type (user-specified knots). !  This is a wrapper for [[initialize_2d_specify_knots]]. pure function bspline_2d_constructor_specify_knots ( x , y , fcn , kx , ky , tx , ty ) result ( me ) implicit none type ( bspline_2d ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky real ( wp ), dimension (:), intent ( in ) :: tx real ( wp ), dimension (:), intent ( in ) :: ty call initialize_2d_specify_knots ( me , x , y , fcn , kx , ky , tx , ty , me % iflag ) end function bspline_2d_constructor_specify_knots !***************************************************************************************** !***************************************************************************************** !> !  Initialize a [[bspline_2d]] type (with automatically-computed knots). !  This is a wrapper for [[db2ink]]. pure subroutine initialize_2d_auto_knots ( me , x , y , fcn , kx , ky , iflag ) implicit none class ( bspline_2d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( out ) :: iflag integer :: iknot integer :: nx , ny call me % destroy () nx = size ( x ) ny = size ( y ) me % nx = nx me % ny = ny me % kx = kx me % ky = ky allocate ( me % tx ( nx + kx )) allocate ( me % ty ( ny + ky )) allocate ( me % bcoef ( nx , ny )) iknot = 0 !knot sequence chosen by db2ink call db2ink ( x , nx , y , ny , fcn , kx , ky , iknot , me % tx , me % ty , me % bcoef , iflag ) me % initialized = iflag == 0 me % iflag = iflag end subroutine initialize_2d_auto_knots !***************************************************************************************** !***************************************************************************************** !> !  Initialize a [[bspline_2d]] type (with user-specified knots). !  This is a wrapper for [[db2ink]]. pure subroutine initialize_2d_specify_knots ( me , x , y , fcn , kx , ky , tx , ty , iflag ) implicit none class ( bspline_2d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky real ( wp ), dimension (:), intent ( in ) :: tx real ( wp ), dimension (:), intent ( in ) :: ty integer , intent ( out ) :: iflag integer :: nx , ny call me % destroy () nx = size ( x ) ny = size ( y ) call check_knot_vectors_sizes ( 'initialize_2d_specify_knots' , nx = nx , kx = kx , tx = tx ,& ny = ny , ky = ky , ty = ty ,& iflag = iflag ) if ( iflag == 0 ) then me % nx = nx me % ny = ny me % kx = kx me % ky = ky allocate ( me % tx ( nx + kx )) allocate ( me % ty ( ny + ky )) allocate ( me % bcoef ( nx , ny )) me % tx = tx me % ty = ty call db2ink ( x , nx , y , ny , fcn , kx , ky , 1 , me % tx , me % ty , me % bcoef , iflag ) end if me % initialized = iflag == 0 me % iflag = iflag end subroutine initialize_2d_specify_knots !***************************************************************************************** !***************************************************************************************** !> !  Evaluate a [[bspline_2d]] interpolate.  This is a wrapper for [[db2val]]. pure subroutine evaluate_2d ( me , xval , yval , idx , idy , f , iflag ) implicit none class ( bspline_2d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: xval real ( wp ), intent ( in ) :: yval integer , intent ( in ) :: idx integer , intent ( in ) :: idy real ( wp ), intent ( out ) :: f integer , intent ( out ) :: iflag if ( me % initialized ) then call db2val ( xval , yval ,& idx , idy ,& me % tx , me % ty ,& me % nx , me % ny ,& me % kx , me % ky ,& me % bcoef , f , iflag ,& me % inbvx , me % inbvy , me % iloy ) else iflag = 1 end if me % iflag = iflag end subroutine evaluate_2d !***************************************************************************************** !***************************************************************************************** !> !  It returns an empty [[bspline_3d]] type. Note that INITIALIZE still !  needs to be called before it can be used. !  Not really that useful except perhaps in some OpenMP applications. elemental function bspline_3d_constructor_empty () result ( me ) implicit none type ( bspline_3d ) :: me end function bspline_3d_constructor_empty !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[bspline_3d]] type (auto knots). !  This is a wrapper for [[initialize_3d_auto_knots]]. pure function bspline_3d_constructor_auto_knots ( x , y , z , fcn , kx , ky , kz ) result ( me ) implicit none type ( bspline_3d ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz call initialize_3d_auto_knots ( me , x , y , z , fcn , kx , ky , kz , me % iflag ) end function bspline_3d_constructor_auto_knots !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[bspline_3d]] type (user-specified knots). !  This is a wrapper for [[initialize_3d_specify_knots]]. pure function bspline_3d_constructor_specify_knots ( x , y , z , fcn , kx , ky , kz , tx , ty , tz ) result ( me ) implicit none type ( bspline_3d ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz real ( wp ), dimension (:), intent ( in ) :: tx real ( wp ), dimension (:), intent ( in ) :: ty real ( wp ), dimension (:), intent ( in ) :: tz call initialize_3d_specify_knots ( me , x , y , z , fcn , kx , ky , kz , tx , ty , tz , me % iflag ) end function bspline_3d_constructor_specify_knots !***************************************************************************************** !***************************************************************************************** !> !  Initialize a [[bspline_3d]] type (with automatically-computed knots). !  This is a wrapper for [[db3ink]]. pure subroutine initialize_3d_auto_knots ( me , x , y , z , fcn , kx , ky , kz , iflag ) implicit none class ( bspline_3d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz integer , intent ( out ) :: iflag integer :: iknot integer :: nx , ny , nz call me % destroy () nx = size ( x ) ny = size ( y ) nz = size ( z ) me % nx = nx me % ny = ny me % nz = nz me % kx = kx me % ky = ky me % kz = kz allocate ( me % tx ( nx + kx )) allocate ( me % ty ( ny + ky )) allocate ( me % tz ( nz + kz )) allocate ( me % bcoef ( nx , ny , nz )) iknot = 0 !knot sequence chosen by db3ink call db3ink ( x , nx , y , ny , z , nz ,& fcn ,& kx , ky , kz ,& iknot ,& me % tx , me % ty , me % tz ,& me % bcoef , iflag ) me % initialized = iflag == 0 me % iflag = iflag end subroutine initialize_3d_auto_knots !***************************************************************************************** !***************************************************************************************** !> !  Initialize a [[bspline_3d]] type (with user-specified knots). !  This is a wrapper for [[db3ink]]. pure subroutine initialize_3d_specify_knots ( me , x , y , z , fcn , kx , ky , kz , tx , ty , tz , iflag ) implicit none class ( bspline_3d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz real ( wp ), dimension (:), intent ( in ) :: tx real ( wp ), dimension (:), intent ( in ) :: ty real ( wp ), dimension (:), intent ( in ) :: tz integer , intent ( out ) :: iflag integer :: nx , ny , nz call me % destroy () nx = size ( x ) ny = size ( y ) nz = size ( z ) call check_knot_vectors_sizes ( 'initialize_3d_specify_knots' , nx = nx , kx = kx , tx = tx ,& ny = ny , ky = ky , ty = ty ,& nz = nz , kz = kz , tz = tz ,& iflag = iflag ) if ( iflag == 0 ) then me % nx = nx me % ny = ny me % nz = nz me % kx = kx me % ky = ky me % kz = kz allocate ( me % tx ( nx + kx )) allocate ( me % ty ( ny + ky )) allocate ( me % tz ( nz + kz )) allocate ( me % bcoef ( nx , ny , nz )) me % tx = tx me % ty = ty me % tz = tz call db3ink ( x , nx , y , ny , z , nz ,& fcn ,& kx , ky , kz ,& 1 ,& me % tx , me % ty , me % tz ,& me % bcoef , iflag ) end if me % initialized = iflag == 0 me % iflag = iflag end subroutine initialize_3d_specify_knots !***************************************************************************************** !***************************************************************************************** !> !  Evaluate a [[bspline_3d]] interpolate.  This is a wrapper for [[db3val]]. pure subroutine evaluate_3d ( me , xval , yval , zval , idx , idy , idz , f , iflag ) implicit none class ( bspline_3d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: xval real ( wp ), intent ( in ) :: yval real ( wp ), intent ( in ) :: zval integer , intent ( in ) :: idx integer , intent ( in ) :: idy integer , intent ( in ) :: idz real ( wp ), intent ( out ) :: f integer , intent ( out ) :: iflag if ( me % initialized ) then call db3val ( xval , yval , zval ,& idx , idy , idz ,& me % tx , me % ty , me % tz ,& me % nx , me % ny , me % nz ,& me % kx , me % ky , me % kz ,& me % bcoef , f , iflag ,& me % inbvx , me % inbvy , me % inbvz ,& me % iloy , me % iloz ) else iflag = 1 end if me % iflag = iflag end subroutine evaluate_3d !***************************************************************************************** !***************************************************************************************** !> !  It returns an empty [[bspline_4d]] type. Note that INITIALIZE still !  needs to be called before it can be used. !  Not really that useful except perhaps in some OpenMP applications. elemental function bspline_4d_constructor_empty () result ( me ) implicit none type ( bspline_4d ) :: me end function bspline_4d_constructor_empty !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[bspline_4d]] type (auto knots). !  This is a wrapper for [[initialize_4d_auto_knots]]. pure function bspline_4d_constructor_auto_knots ( x , y , z , q , fcn , kx , ky , kz , kq ) result ( me ) implicit none type ( bspline_4d ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:,:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz integer , intent ( in ) :: kq call initialize_4d_auto_knots ( me , x , y , z , q , fcn , kx , ky , kz , kq , me % iflag ) end function bspline_4d_constructor_auto_knots !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[bspline_4d]] type (user-specified knots). !  This is a wrapper for [[initialize_4d_specify_knots]]. pure function bspline_4d_constructor_specify_knots ( x , y , z , q , fcn , kx , ky , kz , kq , tx , ty , tz , tq ) result ( me ) implicit none type ( bspline_4d ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:,:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz integer , intent ( in ) :: kq real ( wp ), dimension (:), intent ( in ) :: tx real ( wp ), dimension (:), intent ( in ) :: ty real ( wp ), dimension (:), intent ( in ) :: tz real ( wp ), dimension (:), intent ( in ) :: tq call initialize_4d_specify_knots ( me , x , y , z , q , fcn , kx , ky , kz , kq , tx , ty , tz , tq , me % iflag ) end function bspline_4d_constructor_specify_knots !***************************************************************************************** !***************************************************************************************** !> !  Initialize a [[bspline_4d]] type (with automatically-computed knots). !  This is a wrapper for [[db4ink]]. pure subroutine initialize_4d_auto_knots ( me , x , y , z , q , fcn , kx , ky , kz , kq , iflag ) implicit none class ( bspline_4d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:,:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz integer , intent ( in ) :: kq integer , intent ( out ) :: iflag integer :: iknot integer :: nx , ny , nz , nq call me % destroy () nx = size ( x ) ny = size ( y ) nz = size ( z ) nq = size ( q ) me % nx = nx me % ny = ny me % nz = nz me % nq = nq me % kx = kx me % ky = ky me % kz = kz me % kq = kq allocate ( me % tx ( nx + kx )) allocate ( me % ty ( ny + ky )) allocate ( me % tz ( nz + kz )) allocate ( me % tq ( nq + kq )) allocate ( me % bcoef ( nx , ny , nz , nq )) iknot = 0 !knot sequence chosen by db4ink call db4ink ( x , nx , y , ny , z , nz , q , nq ,& fcn ,& kx , ky , kz , kq ,& iknot ,& me % tx , me % ty , me % tz , me % tq ,& me % bcoef , iflag ) me % initialized = iflag == 0 me % iflag = iflag end subroutine initialize_4d_auto_knots !***************************************************************************************** !***************************************************************************************** !> !  Initialize a [[bspline_4d]] type (with user-specified knots). !  This is a wrapper for [[db4ink]]. pure subroutine initialize_4d_specify_knots ( me , x , y , z , q , fcn , kx , ky , kz , kq , tx , ty , tz , tq , iflag ) implicit none class ( bspline_4d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:,:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz integer , intent ( in ) :: kq real ( wp ), dimension (:), intent ( in ) :: tx real ( wp ), dimension (:), intent ( in ) :: ty real ( wp ), dimension (:), intent ( in ) :: tz real ( wp ), dimension (:), intent ( in ) :: tq integer , intent ( out ) :: iflag integer :: nx , ny , nz , nq call me % destroy () nx = size ( x ) ny = size ( y ) nz = size ( z ) nq = size ( q ) call check_knot_vectors_sizes ( 'initialize_4d_specify_knots' , nx = nx , kx = kx , tx = tx ,& ny = ny , ky = ky , ty = ty ,& nz = nz , kz = kz , tz = tz ,& nq = nq , kq = kq , tq = tq ,& iflag = iflag ) if ( iflag == 0 ) then me % nx = nx me % ny = ny me % nz = nz me % nq = nq me % kx = kx me % ky = ky me % kz = kz me % kq = kq allocate ( me % tx ( nx + kx )) allocate ( me % ty ( ny + ky )) allocate ( me % tz ( nz + kz )) allocate ( me % tq ( nq + kq )) allocate ( me % bcoef ( nx , ny , nz , nq )) me % tx = tx me % ty = ty me % tz = tz me % tq = tq call db4ink ( x , nx , y , ny , z , nz , q , nq ,& fcn ,& kx , ky , kz , kq ,& 1 ,& me % tx , me % ty , me % tz , me % tq ,& me % bcoef , iflag ) end if me % initialized = iflag == 0 me % iflag = iflag end subroutine initialize_4d_specify_knots !***************************************************************************************** !***************************************************************************************** !> !  Evaluate a [[bspline_4d]] interpolate.  This is a wrapper for [[db4val]]. pure subroutine evaluate_4d ( me , xval , yval , zval , qval , idx , idy , idz , idq , f , iflag ) implicit none class ( bspline_4d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: xval real ( wp ), intent ( in ) :: yval real ( wp ), intent ( in ) :: zval real ( wp ), intent ( in ) :: qval integer , intent ( in ) :: idx integer , intent ( in ) :: idy integer , intent ( in ) :: idz integer , intent ( in ) :: idq real ( wp ), intent ( out ) :: f integer , intent ( out ) :: iflag if ( me % initialized ) then call db4val ( xval , yval , zval , qval ,& idx , idy , idz , idq ,& me % tx , me % ty , me % tz , me % tq ,& me % nx , me % ny , me % nz , me % nq ,& me % kx , me % ky , me % kz , me % kq ,& me % bcoef , f , iflag ,& me % inbvx , me % inbvy , me % inbvz , me % inbvq ,& me % iloy , me % iloz , me % iloq ) else iflag = 1 end if me % iflag = iflag end subroutine evaluate_4d !***************************************************************************************** !***************************************************************************************** !> !  It returns an empty [[bspline_5d]] type. Note that INITIALIZE still !  needs to be called before it can be used. !  Not really that useful except perhaps in some OpenMP applications. elemental function bspline_5d_constructor_empty () result ( me ) implicit none type ( bspline_5d ) :: me end function bspline_5d_constructor_empty !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[bspline_5d]] type (auto knots). !  This is a wrapper for [[initialize_5d_auto_knots]]. pure function bspline_5d_constructor_auto_knots ( x , y , z , q , r , fcn , kx , ky , kz , kq , kr ) result ( me ) implicit none type ( bspline_5d ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension (:,:,:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz integer , intent ( in ) :: kq integer , intent ( in ) :: kr call initialize_5d_auto_knots ( me , x , y , z , q , r , fcn , kx , ky , kz , kq , kr , me % iflag ) end function bspline_5d_constructor_auto_knots !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[bspline_5d]] type (user-specified knots). !  This is a wrapper for [[initialize_5d_specify_knots]]. pure function bspline_5d_constructor_specify_knots ( x , y , z , q , r , fcn , kx , ky , kz , kq , kr , tx , ty , tz , tq , tr ) result ( me ) implicit none type ( bspline_5d ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension (:,:,:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz integer , intent ( in ) :: kq integer , intent ( in ) :: kr real ( wp ), dimension (:), intent ( in ) :: tx real ( wp ), dimension (:), intent ( in ) :: ty real ( wp ), dimension (:), intent ( in ) :: tz real ( wp ), dimension (:), intent ( in ) :: tq real ( wp ), dimension (:), intent ( in ) :: tr call initialize_5d_specify_knots ( me , x , y , z , q , r , fcn , kx , ky , kz , kq , kr , tx , ty , tz , tq , tr , me % iflag ) end function bspline_5d_constructor_specify_knots !***************************************************************************************** !***************************************************************************************** !> !  Initialize a [[bspline_5d]] type (with automatically-computed knots). !  This is a wrapper for [[db5ink]]. pure subroutine initialize_5d_auto_knots ( me , x , y , z , q , r , fcn , kx , ky , kz , kq , kr , iflag ) implicit none class ( bspline_5d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension (:,:,:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz integer , intent ( in ) :: kq integer , intent ( in ) :: kr integer , intent ( out ) :: iflag integer :: iknot integer :: nx , ny , nz , nq , nr call me % destroy () nx = size ( x ) ny = size ( y ) nz = size ( z ) nq = size ( q ) nr = size ( r ) me % nx = nx me % ny = ny me % nz = nz me % nq = nq me % nr = nr me % kx = kx me % ky = ky me % kz = kz me % kq = kq me % kr = kr allocate ( me % tx ( nx + kx )) allocate ( me % ty ( ny + ky )) allocate ( me % tz ( nz + kz )) allocate ( me % tq ( nq + kq )) allocate ( me % tr ( nr + kr )) allocate ( me % bcoef ( nx , ny , nz , nq , nr )) iknot = 0 !knot sequence chosen by db5ink call db5ink ( x , nx , y , ny , z , nz , q , nq , r , nr ,& fcn ,& kx , ky , kz , kq , kr ,& iknot ,& me % tx , me % ty , me % tz , me % tq , me % tr ,& me % bcoef , iflag ) me % initialized = iflag == 0 me % iflag = iflag end subroutine initialize_5d_auto_knots !***************************************************************************************** !***************************************************************************************** !> !  Initialize a [[bspline_5d]] type (with user-specified knots). !  This is a wrapper for [[db5ink]]. pure subroutine initialize_5d_specify_knots ( me , x , y , z , q , r , fcn , kx , ky , kz , kq , kr , tx , ty , tz , tq , tr , iflag ) implicit none class ( bspline_5d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension (:,:,:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz integer , intent ( in ) :: kq integer , intent ( in ) :: kr real ( wp ), dimension (:), intent ( in ) :: tx real ( wp ), dimension (:), intent ( in ) :: ty real ( wp ), dimension (:), intent ( in ) :: tz real ( wp ), dimension (:), intent ( in ) :: tq real ( wp ), dimension (:), intent ( in ) :: tr integer , intent ( out ) :: iflag integer :: nx , ny , nz , nq , nr call me % destroy () nx = size ( x ) ny = size ( y ) nz = size ( z ) nq = size ( q ) nr = size ( r ) call check_knot_vectors_sizes ( 'initialize_5d_specify_knots' , nx = nx , kx = kx , tx = tx ,& ny = ny , ky = ky , ty = ty ,& nz = nz , kz = kz , tz = tz ,& nq = nq , kq = kq , tq = tq ,& nr = nr , kr = kr , tr = tr ,& iflag = iflag ) if ( iflag == 0 ) then me % nx = nx me % ny = ny me % nz = nz me % nq = nq me % nr = nr me % kx = kx me % ky = ky me % kz = kz me % kq = kq me % kr = kr allocate ( me % tx ( nx + kx )) allocate ( me % ty ( ny + ky )) allocate ( me % tz ( nz + kz )) allocate ( me % tq ( nq + kq )) allocate ( me % tr ( nr + kr )) allocate ( me % bcoef ( nx , ny , nz , nq , nr )) me % tx = tx me % ty = ty me % tz = tz me % tq = tq me % tr = tr call db5ink ( x , nx , y , ny , z , nz , q , nq , r , nr ,& fcn ,& kx , ky , kz , kq , kr ,& 1 ,& me % tx , me % ty , me % tz , me % tq , me % tr ,& me % bcoef , iflag ) end if me % initialized = iflag == 0 me % iflag = iflag end subroutine initialize_5d_specify_knots !***************************************************************************************** !***************************************************************************************** !> !  Evaluate a [[bspline_5d]] interpolate.  This is a wrapper for [[db5val]]. pure subroutine evaluate_5d ( me , xval , yval , zval , qval , rval , idx , idy , idz , idq , idr , f , iflag ) implicit none class ( bspline_5d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: xval real ( wp ), intent ( in ) :: yval real ( wp ), intent ( in ) :: zval real ( wp ), intent ( in ) :: qval real ( wp ), intent ( in ) :: rval integer , intent ( in ) :: idx integer , intent ( in ) :: idy integer , intent ( in ) :: idz integer , intent ( in ) :: idq integer , intent ( in ) :: idr real ( wp ), intent ( out ) :: f integer , intent ( out ) :: iflag if ( me % initialized ) then call db5val ( xval , yval , zval , qval , rval ,& idx , idy , idz , idq , idr ,& me % tx , me % ty , me % tz , me % tq , me % tr ,& me % nx , me % ny , me % nz , me % nq , me % nr ,& me % kx , me % ky , me % kz , me % kq , me % kr ,& me % bcoef , f , iflag ,& me % inbvx , me % inbvy , me % inbvz , me % inbvq , me % inbvr ,& me % iloy , me % iloz , me % iloq , me % ilor ) else iflag = 1 end if me % iflag = iflag end subroutine evaluate_5d !***************************************************************************************** !***************************************************************************************** !> !  It returns an empty [[bspline_6d]] type. Note that INITIALIZE still !  needs to be called before it can be used. !  Not really that useful except perhaps in some OpenMP applications. elemental function bspline_6d_constructor_empty () result ( me ) implicit none type ( bspline_6d ) :: me end function bspline_6d_constructor_empty !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[bspline_6d]] type (auto knots). !  This is a wrapper for [[initialize_6d_auto_knots]]. pure function bspline_6d_constructor_auto_knots ( x , y , z , q , r , s , fcn , kx , ky , kz , kq , kr , ks ) result ( me ) implicit none type ( bspline_6d ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension (:), intent ( in ) :: s real ( wp ), dimension (:,:,:,:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz integer , intent ( in ) :: kq integer , intent ( in ) :: kr integer , intent ( in ) :: ks call initialize_6d_auto_knots ( me , x , y , z , q , r , s , fcn , kx , ky , kz , kq , kr , ks , me % iflag ) end function bspline_6d_constructor_auto_knots !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[bspline_6d]] type (user-specified knots). !  This is a wrapper for [[initialize_6d_specify_knots]]. pure function bspline_6d_constructor_specify_knots ( x , y , z , q , r , s , fcn , kx , ky , kz , kq , kr , ks , tx , ty , tz , tq , tr , ts ) result ( me ) implicit none type ( bspline_6d ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension (:), intent ( in ) :: s real ( wp ), dimension (:,:,:,:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz integer , intent ( in ) :: kq integer , intent ( in ) :: kr integer , intent ( in ) :: ks real ( wp ), dimension (:), intent ( in ) :: tx real ( wp ), dimension (:), intent ( in ) :: ty real ( wp ), dimension (:), intent ( in ) :: tz real ( wp ), dimension (:), intent ( in ) :: tq real ( wp ), dimension (:), intent ( in ) :: tr real ( wp ), dimension (:), intent ( in ) :: ts call initialize_6d_specify_knots ( me , x , y , z , q , r , s , fcn , kx , ky , kz , kq , kr , ks , tx , ty , tz , tq , tr , ts , me % iflag ) end function bspline_6d_constructor_specify_knots !***************************************************************************************** !***************************************************************************************** !> !  Initialize a [[bspline_6d]] type (with automatically-computed knots). !  This is a wrapper for [[db6ink]]. pure subroutine initialize_6d_auto_knots ( me , x , y , z , q , r , s , fcn , kx , ky , kz , kq , kr , ks , iflag ) implicit none class ( bspline_6d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension (:), intent ( in ) :: s real ( wp ), dimension (:,:,:,:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz integer , intent ( in ) :: kq integer , intent ( in ) :: kr integer , intent ( in ) :: ks integer , intent ( out ) :: iflag integer :: iknot integer :: nx , ny , nz , nq , nr , ns call me % destroy () nx = size ( x ) ny = size ( y ) nz = size ( z ) nq = size ( q ) nr = size ( r ) ns = size ( s ) me % nx = nx me % ny = ny me % nz = nz me % nq = nq me % nr = nr me % ns = ns me % kx = kx me % ky = ky me % kz = kz me % kq = kq me % kr = kr me % ks = ks allocate ( me % tx ( nx + kx )) allocate ( me % ty ( ny + ky )) allocate ( me % tz ( nz + kz )) allocate ( me % tq ( nq + kq )) allocate ( me % tr ( nr + kr )) allocate ( me % ts ( ns + ks )) allocate ( me % bcoef ( nx , ny , nz , nq , nr , ns )) iknot = 0 !knot sequence chosen by db6ink call db6ink ( x , nx , y , ny , z , nz , q , nq , r , nr , s , ns ,& fcn ,& kx , ky , kz , kq , kr , ks ,& iknot ,& me % tx , me % ty , me % tz , me % tq , me % tr , me % ts ,& me % bcoef , iflag ) me % initialized = iflag == 0 me % iflag = iflag end subroutine initialize_6d_auto_knots !***************************************************************************************** !***************************************************************************************** !> !  Initialize a [[bspline_6d]] type (with user-specified knots). !  This is a wrapper for [[db6ink]]. pure subroutine initialize_6d_specify_knots ( me , x , y , z , q , r , s , fcn , kx , ky , kz , kq , kr , ks , tx , ty , tz , tq , tr , ts , iflag ) implicit none class ( bspline_6d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension (:), intent ( in ) :: s real ( wp ), dimension (:,:,:,:,:,:), intent ( in ) :: fcn integer , intent ( in ) :: kx integer , intent ( in ) :: ky integer , intent ( in ) :: kz integer , intent ( in ) :: kq integer , intent ( in ) :: kr integer , intent ( in ) :: ks real ( wp ), dimension (:), intent ( in ) :: tx real ( wp ), dimension (:), intent ( in ) :: ty real ( wp ), dimension (:), intent ( in ) :: tz real ( wp ), dimension (:), intent ( in ) :: tq real ( wp ), dimension (:), intent ( in ) :: tr real ( wp ), dimension (:), intent ( in ) :: ts integer , intent ( out ) :: iflag integer :: nx , ny , nz , nq , nr , ns call me % destroy () nx = size ( x ) ny = size ( y ) nz = size ( z ) nq = size ( q ) nr = size ( r ) ns = size ( s ) call check_knot_vectors_sizes ( 'initialize_6d_specify_knots' , nx = nx , kx = kx , tx = tx ,& ny = ny , ky = ky , ty = ty ,& nz = nz , kz = kz , tz = tz ,& nq = nq , kq = kq , tq = tq ,& nr = nr , kr = kr , tr = tr ,& ns = ns , ks = ks , ts = ts ,& iflag = iflag ) if ( iflag == 0 ) then me % nx = nx me % ny = ny me % nz = nz me % nq = nq me % nr = nr me % ns = ns me % kx = kx me % ky = ky me % kz = kz me % kq = kq me % kr = kr me % ks = ks allocate ( me % tx ( nx + kx )) allocate ( me % ty ( ny + ky )) allocate ( me % tz ( nz + kz )) allocate ( me % tq ( nq + kq )) allocate ( me % tr ( nr + kr )) allocate ( me % ts ( ns + ks )) allocate ( me % bcoef ( nx , ny , nz , nq , nr , ns )) me % tx = tx me % ty = ty me % tz = tz me % tq = tq me % tr = tr me % ts = ts call db6ink ( x , nx , y , ny , z , nz , q , nq , r , nr , s , ns ,& fcn ,& kx , ky , kz , kq , kr , ks ,& 1 ,& me % tx , me % ty , me % tz , me % tq , me % tr , me % ts ,& me % bcoef , iflag ) end if me % initialized = iflag == 0 me % iflag = iflag end subroutine initialize_6d_specify_knots !***************************************************************************************** !***************************************************************************************** !> !  Evaluate a [[bspline_6d]] interpolate.  This is a wrapper for [[db6val]]. pure subroutine evaluate_6d ( me , xval , yval , zval , qval , rval , sval , idx , idy , idz , idq , idr , ids , f , iflag ) implicit none class ( bspline_6d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: xval real ( wp ), intent ( in ) :: yval real ( wp ), intent ( in ) :: zval real ( wp ), intent ( in ) :: qval real ( wp ), intent ( in ) :: rval real ( wp ), intent ( in ) :: sval integer , intent ( in ) :: idx integer , intent ( in ) :: idy integer , intent ( in ) :: idz integer , intent ( in ) :: idq integer , intent ( in ) :: idr integer , intent ( in ) :: ids real ( wp ), intent ( out ) :: f integer , intent ( out ) :: iflag if ( me % initialized ) then call db6val ( xval , yval , zval , qval , rval , sval ,& idx , idy , idz , idq , idr , ids ,& me % tx , me % ty , me % tz , me % tq , me % tr , me % ts ,& me % nx , me % ny , me % nz , me % nq , me % nr , me % ns ,& me % kx , me % ky , me % kz , me % kq , me % kr , me % ks ,& me % bcoef , f , iflag ,& me % inbvx , me % inbvy , me % inbvz , me % inbvq , me % inbvr , me % inbvs ,& me % iloy , me % iloz , me % iloq , me % ilor , me % ilos ) else iflag = 1 end if me % iflag = iflag end subroutine evaluate_6d !***************************************************************************************** !***************************************************************************************** !> !  Error checks for the user-specified knot vector sizes. !  Note that if more than one is the wrong size, then the iflag error code will !  correspond to the one with for the highest rank. pure subroutine check_knot_vectors_sizes ( routine , nx , ny , nz , nq , nr , ns ,& kx , ky , kz , kq , kr , ks ,& tx , ty , tz , tq , tr , ts , iflag ) implicit none character ( len =* ), intent ( in ) :: routine integer , intent ( in ), optional :: nx integer , intent ( in ), optional :: ny integer , intent ( in ), optional :: nz integer , intent ( in ), optional :: nq integer , intent ( in ), optional :: nr integer , intent ( in ), optional :: ns integer , intent ( in ), optional :: kx integer , intent ( in ), optional :: ky integer , intent ( in ), optional :: kz integer , intent ( in ), optional :: kq integer , intent ( in ), optional :: kr integer , intent ( in ), optional :: ks real ( wp ), dimension (:), intent ( in ), optional :: tx real ( wp ), dimension (:), intent ( in ), optional :: ty real ( wp ), dimension (:), intent ( in ), optional :: tz real ( wp ), dimension (:), intent ( in ), optional :: tq real ( wp ), dimension (:), intent ( in ), optional :: tr real ( wp ), dimension (:), intent ( in ), optional :: ts integer , intent ( out ) :: iflag !! 0 if everything is OK iflag = 0 if ( present ( nx ) . and . present ( kx ) . and . present ( tx )) then if ( size ( tx ) /= ( nx + kx )) then !write(error_unit,'(A)') trim(routine)//' - tx is not the correct size (nx+kx)' iflag = 501 end if end if if ( present ( ny ) . and . present ( ky ) . and . present ( ty )) then if ( size ( ty ) /= ( ny + ky )) then !write(error_unit,'(A)') trim(routine)//' - ty is not the correct size (ny+ky)' iflag = 502 end if end if if ( present ( nz ) . and . present ( kz ) . and . present ( tz )) then if ( size ( tz ) /= ( nz + kz )) then !write(error_unit,'(A)') trim(routine)//' - tz is not the correct size (nz+kz)' iflag = 503 end if end if if ( present ( nq ) . and . present ( kq ) . and . present ( tq )) then if ( size ( tq ) /= ( nq + kq )) then !write(error_unit,'(A)') trim(routine)//' - tq is not the correct size (nq+kq)' iflag = 504 end if end if if ( present ( nr ) . and . present ( kr ) . and . present ( tr )) then if ( size ( tr ) /= ( nr + kr )) then !write(error_unit,'(A)') trim(routine)//' - tr is not the correct size (nr+kr)' iflag = 505 end if end if if ( present ( ns ) . and . present ( ks ) . and . present ( ts )) then if ( size ( ts ) /= ( ns + ks )) then !write(error_unit,'(A)') trim(routine)//' - ts is not the correct size (ns+ks)' iflag = 506 end if end if end subroutine check_knot_vectors_sizes !***************************************************************************************** !***************************************************************************************** end module bspline_oo_module !*****************************************************************************************","tags":"","loc":"sourcefile/bspline_oo_module.f90.html","title":"bspline_oo_module.f90 – Photodissociation of water"},{"text":"Contents Modules RDistributions Source Code distrib.f90 Source Code MODULE RDistributions ! Inspired from: http://www.johndcook.com/julia_rng.html ! Original author in julia : John D Cook ! coded : Sukhbinder in fortran ! Date : 28th Feb 2012 ! ! ! Non uniform random Number Generators in Fortran ! DOUBLE PRECISION , PARAMETER :: PI = 3.141592653589793238462 CONTAINS FUNCTION rand_uniform ( a , b ) RESULT ( c ) DOUBLE PRECISION :: a , b , c , temp CALL RANDOM_NUMBER ( temp ) c = a + temp * ( b - a ) END FUNCTION ! ! Random Sample from normal (Gaussian) distribution ! FUNCTION rand_normal ( mean , stdev ) RESULT ( c ) DOUBLE PRECISION :: mean , stdev , c , temp ( 2 ) IF ( stdev <= 0.0d0 ) THEN WRITE ( * , * ) \"Standard Deviation must be +ve\" ELSE CALL RANDOM_NUMBER ( temp ) r = ( - 2.0d0 * log ( temp ( 1 ))) ** 0.5 theta = 2.0d0 * PI * temp ( 2 ) c = mean + stdev * r * sin ( theta ) END IF END FUNCTION ! ! Random smaple from an exponential distribution ! FUNCTION rand_exponential ( mean ) RESULT ( c ) DOUBLE PRECISION :: mean , c , temp IF ( mean <= 0.0d0 ) THEN WRITE ( * , * ) \"mean must be positive\" ELSE CALL RANDOM_NUMBER ( temp ) c =- mean * log ( temp ) END IF END FUNCTION ! ! Return a random sample from a gamma distribution ! RECURSIVE FUNCTION rand_gamma ( shape , SCALE ) RESULT ( ans ) DOUBLE PRECISION SHAPE , scale , u , w , d , c , x , xsq , g IF ( shape <= 0.0d0 ) THEN WRITE ( * , * ) \"Shape PARAMETER must be positive\" END IF IF ( scale <= 0.0d0 ) THEN WRITE ( * , * ) \"Scale PARAMETER must be positive\" END IF ! ! ## Implementation based on \"A Simple Method for Generating Gamma Variables\" ! ## by George Marsaglia and Wai Wan Tsang. ! ## ACM Transactions on Mathematical Software ! ## Vol 26, No 3, September 2000, pages 363-372. ! IF ( shape >= 1.0d0 ) THEN d = SHAPE - 1.0d0 / 3.0d0 c = 1.0d0 / ( 9.0d0 * d ) ** 0.5 DO while (. true .) x = rand_normal ( 0.0d0 , 1.0d0 ) v = 1.0 + c * x DO while ( v <= 0.0d0 ) x = rand_normal ( 0.0d0 , 1.0d0 ) v = 1.0d0 + c * x END DO v = v * v * v CALL RANDOM_NUMBER ( u ) xsq = x * x IF (( u < 1.0d0 - . 0331 d0 * xsq * xsq ) . OR . & ( log ( u ) < 0.5d0 * xsq + d * ( 1.0d0 - v + log ( v ))) ) then ans = scale * d * v RETURN END IF END DO ELSE g = rand_gamma ( shape + 1.0d0 , 1.0d0 ) CALL RANDOM_NUMBER ( w ) ans = scale * g * ( w ) ** ( 1.0d0 / shape ) RETURN END IF END FUNCTION ! ! ## return a random sample from a chi square distribution ! ## with the specified degrees of freedom ! FUNCTION rand_chi_square ( dof ) RESULT ( ans ) DOUBLE PRECISION ans , dof ans = rand_gamma ( 0.5d0 , 2.0d0 * dof ) END FUNCTION ! ! ## return a random sample from an inverse gamma random variable ! FUNCTION rand_inverse_gamma ( shape , SCALE ) RESULT ( ans ) DOUBLE PRECISION SHAPE , scale , ans ! ## If X is gamma(shape, scale) then ! ## 1/Y is inverse gamma(shape, 1/scale) ans = 1.0d0 / rand_gamma ( shape , 1.0d0 / SCALE ) END FUNCTION ! !## return a sample from a Weibull distribution ! FUNCTION rand_weibull ( shape , SCALE ) RESULT ( ans ) DOUBLE PRECISION SHAPE , scale , temp , ans IF ( shape <= 0.0d0 ) THEN WRITE ( * , * ) \"Shape PARAMETER must be positive\" END IF IF ( scale <= 0.0d0 ) THEN WRITE ( * , * ) \"Scale PARAMETER must be positive\" END IF CALL RANDOM_NUMBER ( temp ) ans = SCALE * ( - log ( temp )) ** ( 1.0 / SHAPE ) END FUNCTION ! !## return a random sample from a Cauchy distribution ! FUNCTION rand_cauchy ( median , SCALE ) RESULT ( ans ) DOUBLE PRECISION ans , median , scale , p IF ( scale <= 0.0d0 ) THEN WRITE ( * , * ) \"Scale PARAMETER must be positive\" END IF CALL RANDOM_NUMBER ( p ) ans = median + SCALE * tan ( PI * ( p - 0.5 )) END FUNCTION ! !## return a random sample from a Student t distribution ! FUNCTION rand_student_t ( dof ) RESULT ( ans ) DOUBLE PRECISION ans , dof , y1 , y2 IF ( dof <= 0.d0 ) THEN WRITE ( * , * ) \"Degrees of freedom must be positive\" END IF ! ! ## See Seminumerical Algorithms by Knuth y1 = rand_normal ( 0.0d0 , 1.0d0 ) y2 = rand_chi_square ( dof ) ans = y1 / ( y2 / DOf ) ** 0.50d0 ! END FUNCTION ! !## return a random sample from a Laplace distribution !## The Laplace distribution is also known as the double exponential distribution. ! FUNCTION rand_laplace ( mean , SCALE ) RESULT ( ans ) DOUBLE PRECISION ans , mean , scale , u IF ( scale <= 0.0d0 ) THEN WRITE ( * , * ) \"Scale PARAMETER must be positive\" END IF CALL RANDOM_NUMBER ( u ) IF ( u < 0.5d0 ) THEN ans = mean + SCALE * log ( 2.0 * u ) ELSE ans = mean - SCALE * log ( 2 * ( 1 - u )) END IF END FUNCTION ! ! ## return a random sample from a log-normal distribution ! FUNCTION rand_log_normal ( mu , sigma ) RESULT ( ans ) DOUBLE PRECISION ans , mu , sigma ans = EXP ( rand_normal ( mu , sigma )) END FUNCTION ! ! ## return a random sample from a beta distribution ! FUNCTION rand_beta ( a , b ) RESULT ( ans ) DOUBLE PRECISION a , b , ans , u , v IF (( a <= 0.0d0 ) . OR . ( b <= 0.0d0 )) THEN WRITE ( * , * ) \"Beta PARAMETERs must be positive\" END IF ! ## There are more efficient methods for generating beta samples. ! ## However such methods are a little more efficient and much more complicated. ! ## For an explanation of why the following method works, see ! ## http://www.johndcook.com/distribution_chart.html#gamma_beta u = rand_gamma ( a , 1.0d0 ) v = rand_gamma ( b , 1.0d0 ) ans = u / ( u + v ) END FUNCTION END MODULE","tags":"","loc":"sourcefile/distrib.f90.html","title":"distrib.f90 – Photodissociation of water"},{"text":"type, public, abstract :: bspline_class Base class for the b-spline types Contents Type-Bound Procedures destroy status_ok status_message clear_flag Source Code bspline_class Type-Bound Procedures procedure(destroy_func), public, deferred :: destroy destructor pure subroutine destroy_func(me) Prototype interface for bspline destructor routines Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(inout) :: me procedure, public, non_overridable :: status_ok returns true if the last iflag status code was =0 . private elemental function status_ok(me) result(ok) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(in) :: me Return Value logical procedure, public, non_overridable :: status_message => get_bspline_status_message retrieve the last status message private pure function get_bspline_status_message(me, iflag) result(msg) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(in) :: me integer, intent(in), optional :: iflag the corresponding status code Return Value character(len=:),\n  allocatable status message associated with the flag procedure, public, non_overridable :: clear_flag => clear_bspline_flag to reset the iflag saved in the class. private elemental subroutine clear_bspline_flag(me) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(inout) :: me Source Code type , public , abstract :: bspline_class !! Base class for the b-spline types private integer :: inbvx = 1 !! internal variable used by dbvalu for efficient processing integer :: iflag = 1 !! saved `iflag` from the list routine call. logical :: initialized = . false . !! true if the class is initialized and ready to use contains private procedure , non_overridable :: destroy_base !! destructor for the abstract type procedure ( destroy_func ), deferred , public :: destroy !! destructor procedure , public , non_overridable :: status_ok !! returns true if the last `iflag` status code was `=0`. procedure , public , non_overridable :: status_message => get_bspline_status_message !! retrieve the last status message procedure , public , non_overridable :: clear_flag => clear_bspline_flag !! to reset the `iflag` saved in the class. end type bspline_class","tags":"","loc":"type/bspline_class.html","title":"bspline_class – Photodissociation of water "},{"text":"type, public, extends( bspline_class ) :: bspline_1d Class for 1d b-spline interpolation. Contents Constructor bspline_1d Finalization Procedures finalize_1d Type-Bound Procedures status_ok status_message clear_flag initialize evaluate destroy Source Code bspline_1d Constructor public interface bspline_1d private pure elemental function bspline_1d_constructor_empty() result(me) Arguments None Return Value type( bspline_1d ) private pure function bspline_1d_constructor_auto_knots(x, fcn, kx) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: fcn integer, intent(in) :: kx Return Value type( bspline_1d ) private pure function bspline_1d_constructor_specify_knots(x, fcn, kx, tx) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: fcn integer, intent(in) :: kx real(kind=wp), intent(in), dimension(:) :: tx Return Value type( bspline_1d ) Finalization Procedures final :: finalize_1d private pure elemental subroutine finalize_1d(me) Arguments Type Intent Optional Attributes Name type( bspline_1d ), intent(inout) :: me Type-Bound Procedures procedure, public, non_overridable :: status_ok returns true if the last iflag status code was =0 . private elemental function status_ok(me) result(ok) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(in) :: me Return Value logical procedure, public, non_overridable :: status_message => get_bspline_status_message retrieve the last status message private pure function get_bspline_status_message(me, iflag) result(msg) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(in) :: me integer, intent(in), optional :: iflag the corresponding status code Return Value character(len=:),\n  allocatable status message associated with the flag procedure, public, non_overridable :: clear_flag => clear_bspline_flag to reset the iflag saved in the class. private elemental subroutine clear_bspline_flag(me) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(inout) :: me generic, public :: initialize => initialize_1d_auto_knots, initialize_1d_specify_knots private pure subroutine initialize_1d_auto_knots(me, x, fcn, kx, iflag) Arguments Type Intent Optional Attributes Name class( bspline_1d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: fcn integer, intent(in) :: kx integer, intent(out) :: iflag private pure subroutine initialize_1d_specify_knots(me, x, fcn, kx, tx, iflag) Arguments Type Intent Optional Attributes Name class( bspline_1d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: fcn integer, intent(in) :: kx real(kind=wp), intent(in), dimension(:) :: tx integer, intent(out) :: iflag procedure, public :: evaluate => evaluate_1d private pure subroutine evaluate_1d(me, xval, idx, f, iflag) Arguments Type Intent Optional Attributes Name class( bspline_1d ), intent(inout) :: me real(kind=wp), intent(in) :: xval integer, intent(in) :: idx real(kind=wp), intent(out) :: f integer, intent(out) :: iflag procedure, public :: destroy => destroy_1d private pure subroutine destroy_1d(me) Arguments Type Intent Optional Attributes Name class( bspline_1d ), intent(inout) :: me Source Code type , extends ( bspline_class ), public :: bspline_1d !! Class for 1d b-spline interpolation. private integer :: nx = 0 integer :: kx = 0 real ( wp ), dimension (:), allocatable :: bcoef real ( wp ), dimension (:), allocatable :: tx contains private generic , public :: initialize => initialize_1d_auto_knots , initialize_1d_specify_knots procedure :: initialize_1d_auto_knots procedure :: initialize_1d_specify_knots procedure , public :: evaluate => evaluate_1d procedure , public :: destroy => destroy_1d final :: finalize_1d end type bspline_1d","tags":"","loc":"type/bspline_1d.html","title":"bspline_1d – Photodissociation of water "},{"text":"type, public, extends( bspline_class ) :: bspline_2d Class for 2d b-spline interpolation. Contents Constructor bspline_2d Finalization Procedures finalize_2d Type-Bound Procedures status_ok status_message clear_flag initialize evaluate destroy Source Code bspline_2d Constructor public interface bspline_2d private elemental function bspline_2d_constructor_empty() result(me) Arguments None Return Value type( bspline_2d ) private pure function bspline_2d_constructor_auto_knots(x, y, fcn, kx, ky) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky Return Value type( bspline_2d ) private pure function bspline_2d_constructor_specify_knots(x, y, fcn, kx, ky, tx, ty) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty Return Value type( bspline_2d ) Finalization Procedures final :: finalize_2d private pure elemental subroutine finalize_2d(me) Arguments Type Intent Optional Attributes Name type( bspline_2d ), intent(inout) :: me Type-Bound Procedures procedure, public, non_overridable :: status_ok returns true if the last iflag status code was =0 . private elemental function status_ok(me) result(ok) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(in) :: me Return Value logical procedure, public, non_overridable :: status_message => get_bspline_status_message retrieve the last status message private pure function get_bspline_status_message(me, iflag) result(msg) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(in) :: me integer, intent(in), optional :: iflag the corresponding status code Return Value character(len=:),\n  allocatable status message associated with the flag procedure, public, non_overridable :: clear_flag => clear_bspline_flag to reset the iflag saved in the class. private elemental subroutine clear_bspline_flag(me) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(inout) :: me generic, public :: initialize => initialize_2d_auto_knots, initialize_2d_specify_knots private pure subroutine initialize_2d_auto_knots(me, x, y, fcn, kx, ky, iflag) Arguments Type Intent Optional Attributes Name class( bspline_2d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(out) :: iflag private pure subroutine initialize_2d_specify_knots(me, x, y, fcn, kx, ky, tx, ty, iflag) Arguments Type Intent Optional Attributes Name class( bspline_2d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty integer, intent(out) :: iflag procedure, public :: evaluate => evaluate_2d private pure subroutine evaluate_2d(me, xval, yval, idx, idy, f, iflag) Arguments Type Intent Optional Attributes Name class( bspline_2d ), intent(inout) :: me real(kind=wp), intent(in) :: xval real(kind=wp), intent(in) :: yval integer, intent(in) :: idx integer, intent(in) :: idy real(kind=wp), intent(out) :: f integer, intent(out) :: iflag procedure, public :: destroy => destroy_2d private pure subroutine destroy_2d(me) Arguments Type Intent Optional Attributes Name class( bspline_2d ), intent(inout) :: me Source Code type , extends ( bspline_class ), public :: bspline_2d !! Class for 2d b-spline interpolation. private integer :: nx = 0 integer :: ny = 0 integer :: kx = 0 integer :: ky = 0 real ( wp ), dimension (:,:), allocatable :: bcoef real ( wp ), dimension (:), allocatable :: tx real ( wp ), dimension (:), allocatable :: ty integer :: inbvy = 1 integer :: iloy = 1 contains private generic , public :: initialize => initialize_2d_auto_knots , initialize_2d_specify_knots procedure :: initialize_2d_auto_knots procedure :: initialize_2d_specify_knots procedure , public :: evaluate => evaluate_2d procedure , public :: destroy => destroy_2d final :: finalize_2d end type bspline_2d","tags":"","loc":"type/bspline_2d.html","title":"bspline_2d – Photodissociation of water "},{"text":"type, public, extends( bspline_class ) :: bspline_3d Class for 3d b-spline interpolation. Contents Constructor bspline_3d Finalization Procedures finalize_3d Type-Bound Procedures status_ok status_message clear_flag initialize evaluate destroy Source Code bspline_3d Constructor public interface bspline_3d private elemental function bspline_3d_constructor_empty() result(me) Arguments None Return Value type( bspline_3d ) private pure function bspline_3d_constructor_auto_knots(x, y, z, fcn, kx, ky, kz) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz Return Value type( bspline_3d ) private pure function bspline_3d_constructor_specify_knots(x, y, z, fcn, kx, ky, kz, tx, ty, tz) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz Return Value type( bspline_3d ) Finalization Procedures final :: finalize_3d private pure elemental subroutine finalize_3d(me) Arguments Type Intent Optional Attributes Name type( bspline_3d ), intent(inout) :: me Type-Bound Procedures procedure, public, non_overridable :: status_ok returns true if the last iflag status code was =0 . private elemental function status_ok(me) result(ok) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(in) :: me Return Value logical procedure, public, non_overridable :: status_message => get_bspline_status_message retrieve the last status message private pure function get_bspline_status_message(me, iflag) result(msg) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(in) :: me integer, intent(in), optional :: iflag the corresponding status code Return Value character(len=:),\n  allocatable status message associated with the flag procedure, public, non_overridable :: clear_flag => clear_bspline_flag to reset the iflag saved in the class. private elemental subroutine clear_bspline_flag(me) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(inout) :: me generic, public :: initialize => initialize_3d_auto_knots, initialize_3d_specify_knots private pure subroutine initialize_3d_auto_knots(me, x, y, z, fcn, kx, ky, kz, iflag) Arguments Type Intent Optional Attributes Name class( bspline_3d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(out) :: iflag private pure subroutine initialize_3d_specify_knots(me, x, y, z, fcn, kx, ky, kz, tx, ty, tz, iflag) Arguments Type Intent Optional Attributes Name class( bspline_3d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz integer, intent(out) :: iflag procedure, public :: evaluate => evaluate_3d private pure subroutine evaluate_3d(me, xval, yval, zval, idx, idy, idz, f, iflag) Arguments Type Intent Optional Attributes Name class( bspline_3d ), intent(inout) :: me real(kind=wp), intent(in) :: xval real(kind=wp), intent(in) :: yval real(kind=wp), intent(in) :: zval integer, intent(in) :: idx integer, intent(in) :: idy integer, intent(in) :: idz real(kind=wp), intent(out) :: f integer, intent(out) :: iflag procedure, public :: destroy => destroy_3d private pure subroutine destroy_3d(me) Arguments Type Intent Optional Attributes Name class( bspline_3d ), intent(inout) :: me Source Code type , extends ( bspline_class ), public :: bspline_3d !! Class for 3d b-spline interpolation. private integer :: nx = 0 integer :: ny = 0 integer :: nz = 0 integer :: kx = 0 integer :: ky = 0 integer :: kz = 0 real ( wp ), dimension (:,:,:), allocatable :: bcoef real ( wp ), dimension (:), allocatable :: tx real ( wp ), dimension (:), allocatable :: ty real ( wp ), dimension (:), allocatable :: tz integer :: inbvy = 1 integer :: inbvz = 1 integer :: iloy = 1 integer :: iloz = 1 contains private generic , public :: initialize => initialize_3d_auto_knots , initialize_3d_specify_knots procedure :: initialize_3d_auto_knots procedure :: initialize_3d_specify_knots procedure , public :: evaluate => evaluate_3d procedure , public :: destroy => destroy_3d final :: finalize_3d end type bspline_3d","tags":"","loc":"type/bspline_3d.html","title":"bspline_3d – Photodissociation of water "},{"text":"type, public, extends( bspline_class ) :: bspline_4d Class for 4d b-spline interpolation. Contents Constructor bspline_4d Finalization Procedures finalize_4d Type-Bound Procedures status_ok status_message clear_flag initialize evaluate destroy Source Code bspline_4d Constructor public interface bspline_4d private elemental function bspline_4d_constructor_empty() result(me) Arguments None Return Value type( bspline_4d ) private pure function bspline_4d_constructor_auto_knots(x, y, z, q, fcn, kx, ky, kz, kq) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq Return Value type( bspline_4d ) private pure function bspline_4d_constructor_specify_knots(x, y, z, q, fcn, kx, ky, kz, kq, tx, ty, tz, tq) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz real(kind=wp), intent(in), dimension(:) :: tq Return Value type( bspline_4d ) Finalization Procedures final :: finalize_4d private pure elemental subroutine finalize_4d(me) Arguments Type Intent Optional Attributes Name type( bspline_4d ), intent(inout) :: me Type-Bound Procedures procedure, public, non_overridable :: status_ok returns true if the last iflag status code was =0 . private elemental function status_ok(me) result(ok) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(in) :: me Return Value logical procedure, public, non_overridable :: status_message => get_bspline_status_message retrieve the last status message private pure function get_bspline_status_message(me, iflag) result(msg) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(in) :: me integer, intent(in), optional :: iflag the corresponding status code Return Value character(len=:),\n  allocatable status message associated with the flag procedure, public, non_overridable :: clear_flag => clear_bspline_flag to reset the iflag saved in the class. private elemental subroutine clear_bspline_flag(me) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(inout) :: me generic, public :: initialize => initialize_4d_auto_knots, initialize_4d_specify_knots private pure subroutine initialize_4d_auto_knots(me, x, y, z, q, fcn, kx, ky, kz, kq, iflag) Arguments Type Intent Optional Attributes Name class( bspline_4d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(out) :: iflag private pure subroutine initialize_4d_specify_knots(me, x, y, z, q, fcn, kx, ky, kz, kq, tx, ty, tz, tq, iflag) Arguments Type Intent Optional Attributes Name class( bspline_4d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz real(kind=wp), intent(in), dimension(:) :: tq integer, intent(out) :: iflag procedure, public :: evaluate => evaluate_4d private pure subroutine evaluate_4d(me, xval, yval, zval, qval, idx, idy, idz, idq, f, iflag) Arguments Type Intent Optional Attributes Name class( bspline_4d ), intent(inout) :: me real(kind=wp), intent(in) :: xval real(kind=wp), intent(in) :: yval real(kind=wp), intent(in) :: zval real(kind=wp), intent(in) :: qval integer, intent(in) :: idx integer, intent(in) :: idy integer, intent(in) :: idz integer, intent(in) :: idq real(kind=wp), intent(out) :: f integer, intent(out) :: iflag procedure, public :: destroy => destroy_4d private pure subroutine destroy_4d(me) Arguments Type Intent Optional Attributes Name class( bspline_4d ), intent(inout) :: me Source Code type , extends ( bspline_class ), public :: bspline_4d !! Class for 4d b-spline interpolation. private integer :: nx = 0 integer :: ny = 0 integer :: nz = 0 integer :: nq = 0 integer :: kx = 0 integer :: ky = 0 integer :: kz = 0 integer :: kq = 0 real ( wp ), dimension (:,:,:,:), allocatable :: bcoef real ( wp ), dimension (:), allocatable :: tx real ( wp ), dimension (:), allocatable :: ty real ( wp ), dimension (:), allocatable :: tz real ( wp ), dimension (:), allocatable :: tq integer :: inbvy = 1 integer :: inbvz = 1 integer :: inbvq = 1 integer :: iloy = 1 integer :: iloz = 1 integer :: iloq = 1 contains private generic , public :: initialize => initialize_4d_auto_knots , initialize_4d_specify_knots procedure :: initialize_4d_auto_knots procedure :: initialize_4d_specify_knots procedure , public :: evaluate => evaluate_4d procedure , public :: destroy => destroy_4d final :: finalize_4d end type bspline_4d","tags":"","loc":"type/bspline_4d.html","title":"bspline_4d – Photodissociation of water "},{"text":"type, public, extends( bspline_class ) :: bspline_5d Class for 5d b-spline interpolation. Contents Constructor bspline_5d Finalization Procedures finalize_5d Type-Bound Procedures status_ok status_message clear_flag initialize evaluate destroy Source Code bspline_5d Constructor public interface bspline_5d private elemental function bspline_5d_constructor_empty() result(me) Arguments None Return Value type( bspline_5d ) private pure function bspline_5d_constructor_auto_knots(x, y, z, q, r, fcn, kx, ky, kz, kq, kr) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr Return Value type( bspline_5d ) private pure function bspline_5d_constructor_specify_knots(x, y, z, q, r, fcn, kx, ky, kz, kq, kr, tx, ty, tz, tq, tr) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz real(kind=wp), intent(in), dimension(:) :: tq real(kind=wp), intent(in), dimension(:) :: tr Return Value type( bspline_5d ) Finalization Procedures final :: finalize_5d private pure elemental subroutine finalize_5d(me) Arguments Type Intent Optional Attributes Name type( bspline_5d ), intent(inout) :: me Type-Bound Procedures procedure, public, non_overridable :: status_ok returns true if the last iflag status code was =0 . private elemental function status_ok(me) result(ok) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(in) :: me Return Value logical procedure, public, non_overridable :: status_message => get_bspline_status_message retrieve the last status message private pure function get_bspline_status_message(me, iflag) result(msg) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(in) :: me integer, intent(in), optional :: iflag the corresponding status code Return Value character(len=:),\n  allocatable status message associated with the flag procedure, public, non_overridable :: clear_flag => clear_bspline_flag to reset the iflag saved in the class. private elemental subroutine clear_bspline_flag(me) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(inout) :: me generic, public :: initialize => initialize_5d_auto_knots, initialize_5d_specify_knots private pure subroutine initialize_5d_auto_knots(me, x, y, z, q, r, fcn, kx, ky, kz, kq, kr, iflag) Arguments Type Intent Optional Attributes Name class( bspline_5d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr integer, intent(out) :: iflag private pure subroutine initialize_5d_specify_knots(me, x, y, z, q, r, fcn, kx, ky, kz, kq, kr, tx, ty, tz, tq, tr, iflag) Arguments Type Intent Optional Attributes Name class( bspline_5d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz real(kind=wp), intent(in), dimension(:) :: tq real(kind=wp), intent(in), dimension(:) :: tr integer, intent(out) :: iflag procedure, public :: evaluate => evaluate_5d private pure subroutine evaluate_5d(me, xval, yval, zval, qval, rval, idx, idy, idz, idq, idr, f, iflag) Arguments Type Intent Optional Attributes Name class( bspline_5d ), intent(inout) :: me real(kind=wp), intent(in) :: xval real(kind=wp), intent(in) :: yval real(kind=wp), intent(in) :: zval real(kind=wp), intent(in) :: qval real(kind=wp), intent(in) :: rval integer, intent(in) :: idx integer, intent(in) :: idy integer, intent(in) :: idz integer, intent(in) :: idq integer, intent(in) :: idr real(kind=wp), intent(out) :: f integer, intent(out) :: iflag procedure, public :: destroy => destroy_5d private pure subroutine destroy_5d(me) Arguments Type Intent Optional Attributes Name class( bspline_5d ), intent(inout) :: me Source Code type , extends ( bspline_class ), public :: bspline_5d !! Class for 5d b-spline interpolation. private integer :: nx = 0 integer :: ny = 0 integer :: nz = 0 integer :: nq = 0 integer :: nr = 0 integer :: kx = 0 integer :: ky = 0 integer :: kz = 0 integer :: kq = 0 integer :: kr = 0 real ( wp ), dimension (:,:,:,:,:), allocatable :: bcoef real ( wp ), dimension (:), allocatable :: tx real ( wp ), dimension (:), allocatable :: ty real ( wp ), dimension (:), allocatable :: tz real ( wp ), dimension (:), allocatable :: tq real ( wp ), dimension (:), allocatable :: tr integer :: inbvy = 1 integer :: inbvz = 1 integer :: inbvq = 1 integer :: inbvr = 1 integer :: iloy = 1 integer :: iloz = 1 integer :: iloq = 1 integer :: ilor = 1 contains private generic , public :: initialize => initialize_5d_auto_knots , initialize_5d_specify_knots procedure :: initialize_5d_auto_knots procedure :: initialize_5d_specify_knots procedure , public :: evaluate => evaluate_5d procedure , public :: destroy => destroy_5d final :: finalize_5d end type bspline_5d","tags":"","loc":"type/bspline_5d.html","title":"bspline_5d – Photodissociation of water "},{"text":"type, public, extends( bspline_class ) :: bspline_6d Class for 6d b-spline interpolation. Contents Constructor bspline_6d Finalization Procedures finalize_6d Type-Bound Procedures status_ok status_message clear_flag initialize evaluate destroy Source Code bspline_6d Constructor public interface bspline_6d private elemental function bspline_6d_constructor_empty() result(me) Arguments None Return Value type( bspline_6d ) private pure function bspline_6d_constructor_auto_knots(x, y, z, q, r, s, fcn, kx, ky, kz, kq, kr, ks) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr integer, intent(in) :: ks Return Value type( bspline_6d ) private pure function bspline_6d_constructor_specify_knots(x, y, z, q, r, s, fcn, kx, ky, kz, kq, kr, ks, tx, ty, tz, tq, tr, ts) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr integer, intent(in) :: ks real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz real(kind=wp), intent(in), dimension(:) :: tq real(kind=wp), intent(in), dimension(:) :: tr real(kind=wp), intent(in), dimension(:) :: ts Return Value type( bspline_6d ) Finalization Procedures final :: finalize_6d private pure elemental subroutine finalize_6d(me) Arguments Type Intent Optional Attributes Name type( bspline_6d ), intent(inout) :: me Type-Bound Procedures procedure, public, non_overridable :: status_ok returns true if the last iflag status code was =0 . private elemental function status_ok(me) result(ok) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(in) :: me Return Value logical procedure, public, non_overridable :: status_message => get_bspline_status_message retrieve the last status message private pure function get_bspline_status_message(me, iflag) result(msg) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(in) :: me integer, intent(in), optional :: iflag the corresponding status code Return Value character(len=:),\n  allocatable status message associated with the flag procedure, public, non_overridable :: clear_flag => clear_bspline_flag to reset the iflag saved in the class. private elemental subroutine clear_bspline_flag(me) Arguments Type Intent Optional Attributes Name class( bspline_class ), intent(inout) :: me generic, public :: initialize => initialize_6d_auto_knots, initialize_6d_specify_knots private pure subroutine initialize_6d_auto_knots(me, x, y, z, q, r, s, fcn, kx, ky, kz, kq, kr, ks, iflag) Arguments Type Intent Optional Attributes Name class( bspline_6d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr integer, intent(in) :: ks integer, intent(out) :: iflag private pure subroutine initialize_6d_specify_knots(me, x, y, z, q, r, s, fcn, kx, ky, kz, kq, kr, ks, tx, ty, tz, tq, tr, ts, iflag) Arguments Type Intent Optional Attributes Name class( bspline_6d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr integer, intent(in) :: ks real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz real(kind=wp), intent(in), dimension(:) :: tq real(kind=wp), intent(in), dimension(:) :: tr real(kind=wp), intent(in), dimension(:) :: ts integer, intent(out) :: iflag procedure, public :: evaluate => evaluate_6d private pure subroutine evaluate_6d(me, xval, yval, zval, qval, rval, sval, idx, idy, idz, idq, idr, ids, f, iflag) Arguments Type Intent Optional Attributes Name class( bspline_6d ), intent(inout) :: me real(kind=wp), intent(in) :: xval real(kind=wp), intent(in) :: yval real(kind=wp), intent(in) :: zval real(kind=wp), intent(in) :: qval real(kind=wp), intent(in) :: rval real(kind=wp), intent(in) :: sval integer, intent(in) :: idx integer, intent(in) :: idy integer, intent(in) :: idz integer, intent(in) :: idq integer, intent(in) :: idr integer, intent(in) :: ids real(kind=wp), intent(out) :: f integer, intent(out) :: iflag procedure, public :: destroy => destroy_6d private pure subroutine destroy_6d(me) Arguments Type Intent Optional Attributes Name class( bspline_6d ), intent(inout) :: me Source Code type , extends ( bspline_class ), public :: bspline_6d !! Class for 6d b-spline interpolation. private integer :: nx = 0 integer :: ny = 0 integer :: nz = 0 integer :: nq = 0 integer :: nr = 0 integer :: ns = 0 integer :: kx = 0 integer :: ky = 0 integer :: kz = 0 integer :: kq = 0 integer :: kr = 0 integer :: ks = 0 real ( wp ), dimension (:,:,:,:,:,:), allocatable :: bcoef real ( wp ), dimension (:), allocatable :: tx real ( wp ), dimension (:), allocatable :: ty real ( wp ), dimension (:), allocatable :: tz real ( wp ), dimension (:), allocatable :: tq real ( wp ), dimension (:), allocatable :: tr real ( wp ), dimension (:), allocatable :: ts integer :: inbvy = 1 integer :: inbvz = 1 integer :: inbvq = 1 integer :: inbvr = 1 integer :: inbvs = 1 integer :: iloy = 1 integer :: iloz = 1 integer :: iloq = 1 integer :: ilor = 1 integer :: ilos = 1 contains private generic , public :: initialize => initialize_6d_auto_knots , initialize_6d_specify_knots procedure :: initialize_6d_auto_knots procedure :: initialize_6d_specify_knots procedure , public :: evaluate => evaluate_6d procedure , public :: destroy => destroy_6d final :: finalize_6d end type bspline_6d","tags":"","loc":"type/bspline_6d.html","title":"bspline_6d – Photodissociation of water "},{"text":"subroutine dyn(npart, mass, xyz, vxyz, ti, tf, fpot, fsta, dt, dr) Uses bspline_module interpolation RDistributions !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! energy(:,:,:,:)=0d0 end surface hopping Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart double precision, intent(in), dimension(npart) :: mass double precision, intent(inout), dimension(3,npart) :: xyz double precision, intent(inout), dimension(3,npart) :: vxyz double precision, intent(inout) :: ti double precision, intent(inout) :: tf character(len=64) :: fpot integer, intent(inout) :: fsta double precision, intent(in) :: dt double precision, intent(in) :: dr Contents Source Code dyn Source Code subroutine dyn ( npart , mass , xyz , vxyz , ti , tf , fpot , fsta , dt , dr ) use bspline_module use interpolation use RDistributions implicit none !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Nico 24.05.2016 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! performs the dynamics until tf                        !! ! uses Verlet algorithom                                !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! for the dynamics double precision , intent ( in ) :: dt , dr ! in atomic units double precision , intent ( inout ) :: ti , tf double precision , dimension ( 3 , npart ) :: xyzm , xyzt , xyznew , xyzdr double precision :: time , grade double precision , dimension (:), allocatable :: valdrp , valdrm , val ! for the system integer , intent ( in ) :: npart double precision , dimension ( npart ), intent ( in ) :: mass double precision , dimension ( 3 , npart ), intent ( inout ) :: xyz , vxyz !for the electronic state character ( 64 ) :: fpot !for Landau-Zener double precision , dimension (:), allocatable :: epair , epair_t1 , d_epair , d_epair_t1 , d2_epair double precision :: plz !for the interpolation integer :: nsta integer :: nr1 , nr2 , nthe double precision , dimension (:), allocatable :: r1 , r2 , the double precision , dimension (:,:,:,:), allocatable :: energy integer , intent ( inout ) :: fsta double precision , dimension (:,:), allocatable :: tr1 , tr2 , tthe integer , parameter :: kr1 = 4 !! order in r1 integer , parameter :: kr2 = 4 !! order in r2 integer , parameter :: kt = 2 !! order in theta integer , parameter :: iknot = 0 !! automatically select the knots double precision :: tol logical :: fail , file_e integer :: inbvx , inbvy , inbvz integer :: iloy , iloz , iflag integer :: idr1 , idr2 , idthe double precision :: newr1 , newr2 , newthe integer :: i , j , k , ista ! Reads the data inquire ( file = trim ( fpot ), exist = file_e ) if ( file_e . eqv . . false . ) then write ( * , * ) trim ( fpot ), \" does not exist\" stop endif write ( * , '(A,A)' ) 'Read PESs in ' , trim ( fpot ) open ( unit = 10 , file = trim ( fpot )) read ( 10 , * ) nr1 , nr2 , nthe , nsta write ( * , '(A,I4,A,I4,A,I4,A)' ) 'There are' , nr1 , ' * ' , nr2 , ' * ' , nthe , ' points' write ( * , '(A,I4,A)' ) 'There are' , nsta , 'states' allocate ( r1 ( nr1 ), r2 ( nr2 ), the ( nthe )) allocate ( energy ( nsta , nr2 , nr1 , nthe )) ! do i = 1 , nr2 do j = 1 , nr1 do k = 1 , nthe read ( 10 , * ) r2 ( i ), r1 ( j ), the ( k ),( energy ( ista , i , j , k ), ista = 1 , nsta ) !      write(*,'(5(f20.10,1X))')r2(i),r1(j),the(k),(energy(ista,i,j,k),ista=1,nsta) enddo enddo enddo close ( 10 ) write ( * , '(A)' ) 'Reading PESs done ' !!energy(:,:,:,:)=0d0 allocate ( epair ( nsta ), epair_t1 ( nsta ), d_epair ( nsta ), d_epair_t1 ( nsta ), d2_epair ( nsta )) d_epair_t1 (:) = 0 d0 epair_t1 (:) = 0 d0 ! ! Set-up the interpolation inbvx = 1 inbvy = 1 inbvz = 1 iloy = 1 iloz = 1 idr1 = 0 idr2 = 0 idthe = 0 fail = . false . tol = 1.0e-14 allocate ( tr1 ( nsta , nr1 + kr1 ), tr2 ( nsta , nr2 + kr2 ), tthe ( nsta , nthe + kt )) allocate ( val ( nsta ), valdrp ( nsta ), valdrm ( nsta )) do ista = 1 , nsta iflag = 0 call db3ink ( r2 , nr2 , r1 , nr1 , the , nthe , energy ( ista ,:,:,:), kr1 , kr2 , kt , iknot , tr2 ( ista ,:), tr1 ( ista ,:), tthe ( ista ,:), energy ( ista ,:,:,:), iflag ) if ( iflag /= 0 ) then write ( * , * ) \"error in db3ink\" , iflag return endif enddo ! landau-zenner surf. hopp. stuff call compute_dist ( npart , xyz , newr1 , newr2 , newthe ) do ista = 1 , nsta call db3val ( newr2 , newr1 , newthe , idr1 , idr2 , idthe , tr2 ( ista ,:), tr1 ( ista ,:), tthe ( ista ,:), nr2 , nr1 , nthe , kr1 , kr2 , kt , energy ( ista ,:,:,:), val ( ista ), iflag ,& inbvx , inbvy , inbvz , iloy , iloz ) if ( iflag /= 0 ) then write ( * , * ) \"error in db3val at time\" , time stop endif enddo do ista = 1 , nsta epair ( ista ) = abs ( val ( ista ) - val ( fsta )) enddo ! first step of the Verlet algorithm do i = 1 , npart do j = 1 , 3 xyzm ( j , i ) = xyz ( j , i ) xyzt ( j , i ) = xyz ( j , i ) + vxyz ( j , i ) * dt enddo enddo time = ti do while ( time < tf ) ! landau-zenner surf. hopp. stuff epair_t1 (:) = epair (:) d_epair_t1 (:) = d_epair (:) epair (:) = 0 d0 ! computes the energy at position at time t call compute_dist ( npart , xyz , newr1 , newr2 , newthe ) do ista = 1 , nsta call db3val ( newr2 , newr1 , newthe , idr1 , idr2 , idthe , tr2 ( ista ,:), tr1 ( ista ,:), tthe ( ista ,:), nr2 , nr1 , nthe , kr1 , kr2 , kt , energy ( ista ,:,:,:), val ( ista ), iflag ,& inbvx , inbvy , inbvz , iloy , iloz ) write ( 200 , '(5(f20.10,1X),i3)' ) time , newr1 , newr2 , newthe , val ( fsta ), fsta if ( iflag /= 0 ) then write ( * , * ) \"error in db3val at time\" , time stop endif enddo ! apply LZ surface hopping here do ista = 1 , nsta epair ( ista ) = abs ( val ( ista ) - val ( fsta )) enddo d_epair (:) = ( epair (:) - epair_t1 (:)) / dt d2_epair (:) = ( d_epair (:) - d_epair_t1 (:)) / dt do ista = 1 , nsta if ( d_epair ( ista ) * d_epair_t1 ( ista ) < 0 d0 . and . d2_epair ( ista ) > 0 d0 ) then plz = exp ( - 0.5d0 * pi * sqrt ( epair ( ista ) ** 3 / d2_epair ( ista ))) if ( plz > rand_uniform ( 0 d0 , 1 d0 )) then write ( * , * ) \"HOP\" fsta = ista epair_t1 (:) = 0 d0 epair (:) = 0 d0 d_epair (:) = 0 d0 d_epair_t1 (:) = 0 d0 exit ! only one hop allowed endif endif enddo !! end surface hopping ! computes the new position do i = 1 , npart do j = 1 , 3 xyzdr (:,:) = xyzt (:,:) xyzdr ( j , i ) = xyzt ( j , i ) + dr call compute_dist ( npart , xyz , newr1 , newr2 , newthe ) do ista = 1 , nsta call db3val ( newr2 , newr1 , newthe , idr1 , idr2 , idthe , tr2 ( ista ,:), tr1 ( ista ,:), tthe ( ista ,:), nr2 , nr1 , nthe , kr1 , kr2 , kt , energy ( ista ,:,:,:), valdrp ( ista ), iflag ,& inbvx , inbvy , inbvz , iloy , iloz ) enddo !    write(*,'(i4,i4,5(f15.5))')j,i,newr1,newr2,newthe,valdrp(fsta) xyzdr (:,:) = xyzt (:,:) xyzdr ( j , i ) = xyzt ( j , i ) - dr call compute_dist ( npart , xyz , newr1 , newr2 , newthe ) do ista = 1 , nsta call db3val ( newr2 , newr1 , newthe , idr1 , idr2 , idthe , tr2 ( ista ,:), tr1 ( ista ,:), tthe ( ista ,:), nr2 , nr1 , nthe , kr1 , kr2 , kt , energy ( ista ,:,:,:), valdrp ( ista ), iflag ,& inbvx , inbvy , inbvz , iloy , iloz ) enddo !    write(*,'(i4,i4,5(f15.5))')j,i,newr1,newr2,newthe,valdrm(fsta) grade = 0.5 * ( ( valdrp ( fsta ) - val ( fsta )) / dr - ( valdrm ( fsta ) - val ( fsta )) / dr ) !    write(*,'(i4,i4,5(f15.5))')j,i,grade,newr,newrh2,newthe !    write(*,*) xyznew ( j , i ) = 2 * xyzt ( j , i ) - xyzm ( j , i ) - grade * dt ** 2 / mass ( i ) enddo enddo xyzm (:,:) = xyzt (:,:) xyzt (:,:) = xyznew (:,:) time = time + dt enddo !stop xyz (:,:) = xyznew (:,:) vxyz (:,:) = ( xyzt (:,:) - xyzm (:,:)) / dt deallocate ( r1 , r2 , the , energy ) deallocate ( tr1 , tr2 , tthe ) deallocate ( val , valdrp , valdrm ) deallocate ( epair , epair_t1 , d_epair , d2_epair ) end subroutine dyn","tags":"","loc":"proc/dyn.html","title":"dyn – Photodissociation of water"},{"text":"subroutine compute_dist(npart, xyz, r1, r2, theta) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart double precision, intent(in), dimension(3,npart) :: xyz double precision :: r1 double precision :: r2 double precision :: theta Contents Source Code compute_dist Source Code subroutine compute_dist ( npart , xyz , r1 , r2 , theta ) implicit none integer , intent ( in ) :: npart double precision , dimension ( 3 , npart ), intent ( in ) :: xyz double precision :: r1 , r2 , costhe , theta ! atom 1 must be oxygen ! atoms 2 and 3 are then hydrogen r1 = sqrt ( ( xyz ( 1 , 1 ) - xyz ( 1 , 2 )) ** 2 + ( xyz ( 2 , 1 ) - xyz ( 2 , 2 )) ** 2 + ( xyz ( 3 , 1 ) - xyz ( 3 , 2 )) ** 2 ) r2 = sqrt ( ( xyz ( 1 , 1 ) - xyz ( 1 , 3 )) ** 2 + ( xyz ( 2 , 1 ) - xyz ( 2 , 3 )) ** 2 + ( xyz ( 3 , 1 ) - xyz ( 3 , 3 )) ** 2 ) costhe = ( ( xyz ( 1 , 2 ) - xyz ( 1 , 1 )) * ( xyz ( 1 , 3 ) - xyz ( 1 , 1 )) + ( xyz ( 2 , 2 ) - xyz ( 2 , 1 )) * ( xyz ( 2 , 3 ) - xyz ( 2 , 1 )) + ( xyz ( 3 , 2 ) - xyz ( 3 , 1 )) * ( xyz ( 3 , 3 ) - xyz ( 3 , 1 )) ) / ( r1 * r2 ) theta = dacos ( costhe ) * 180 d0 / dacos ( - 1 d0 ) end subroutine compute_dist","tags":"","loc":"proc/compute_dist.html","title":"compute_dist – Photodissociation of water"},{"text":"subroutine init_random_seed() Arguments None Contents None","tags":"","loc":"proc/init_random_seed.html","title":"init_random_seed – Photodissociation of water"},{"text":"public pure function get_status_message(iflag) result(msg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iflag return code from one of the routines Return Value character(len=:),\n  allocatable status message associated with the flag Contents Source Code get_status_message Source Code pure function get_status_message ( iflag ) result ( msg ) implicit none integer , intent ( in ) :: iflag !! return code from one of the routines character ( len = :), allocatable :: msg !! status message associated with the flag character ( len = 10 ) :: istr !! for integer to string conversion integer :: istat !! for write statement select case ( iflag ) case ( 0 ); msg = 'Successful execution' case ( 1 ); msg = 'Error in evaluate_*d: class is not initialized' case ( 2 ); msg = 'Error in db*ink: iknot out of range' case ( 3 ); msg = 'Error in db*ink: nx out of range' case ( 4 ); msg = 'Error in db*ink: kx out of range' case ( 5 ); msg = 'Error in db*ink: x not strictly increasing' case ( 6 ); msg = 'Error in db*ink: tx not non-decreasing' case ( 7 ); msg = 'Error in db*ink: ny out of range' case ( 8 ); msg = 'Error in db*ink: ky out of range' case ( 9 ); msg = 'Error in db*ink: y not strictly increasing' case ( 10 ); msg = 'Error in db*ink: ty not non-decreasing' case ( 11 ); msg = 'Error in db*ink: nz out of range' case ( 12 ); msg = 'Error in db*ink: kz out of range' case ( 13 ); msg = 'Error in db*ink: z not strictly increasing' case ( 14 ); msg = 'Error in db*ink: tz not non-decreasing' case ( 15 ); msg = 'Error in db*ink: nq out of range' case ( 16 ); msg = 'Error in db*ink: kq out of range' case ( 17 ); msg = 'Error in db*ink: q not strictly increasing' case ( 18 ); msg = 'Error in db*ink: tq not non-decreasing' case ( 19 ); msg = 'Error in db*ink: nr out of range' case ( 20 ); msg = 'Error in db*ink: kr out of range' case ( 21 ); msg = 'Error in db*ink: r not strictly increasing' case ( 22 ); msg = 'Error in db*ink: tr not non-decreasing' case ( 23 ); msg = 'Error in db*ink: ns out of range' case ( 24 ); msg = 'Error in db*ink: ks out of range' case ( 25 ); msg = 'Error in db*ink: s not strictly increasing' case ( 26 ); msg = 'Error in db*ink: ts not non-decreasing' case ( 700 ); msg = 'Error in db*ink: size(x) /= size(fcn,1)' case ( 701 ); msg = 'Error in db*ink: size(y) /= size(fcn,2)' case ( 702 ); msg = 'Error in db*ink: size(z) /= size(fcn,3)' case ( 703 ); msg = 'Error in db*ink: size(q) /= size(fcn,4)' case ( 704 ); msg = 'Error in db*ink: size(r) /= size(fcn,5)' case ( 705 ); msg = 'Error in db*ink: size(s) /= size(fcn,6)' case ( 706 ); msg = 'Error in db*ink: size(x) /= nx' case ( 707 ); msg = 'Error in db*ink: size(y) /= ny' case ( 708 ); msg = 'Error in db*ink: size(z) /= nz' case ( 709 ); msg = 'Error in db*ink: size(q) /= nq' case ( 710 ); msg = 'Error in db*ink: size(r) /= nr' case ( 711 ); msg = 'Error in db*ink: size(s) /= ns' case ( 712 ); msg = 'Error in db*ink: size(tx) /= nx+kx' case ( 713 ); msg = 'Error in db*ink: size(ty) /= ny+ky' case ( 714 ); msg = 'Error in db*ink: size(tz) /= nz+kz' case ( 715 ); msg = 'Error in db*ink: size(tq) /= nq+kq' case ( 716 ); msg = 'Error in db*ink: size(tr) /= nr+kr' case ( 717 ); msg = 'Error in db*ink: size(ts) /= ns+ks' case ( 800 ); msg = 'Error in db*ink: size(x) /= size(bcoef,1)' case ( 801 ); msg = 'Error in db*ink: size(y) /= size(bcoef,2)' case ( 802 ); msg = 'Error in db*ink: size(z) /= size(bcoef,3)' case ( 803 ); msg = 'Error in db*ink: size(q) /= size(bcoef,4)' case ( 804 ); msg = 'Error in db*ink: size(r) /= size(bcoef,5)' case ( 805 ); msg = 'Error in db*ink: size(s) /= size(bcoef,6)' case ( 100 ); msg = 'Error in dbintk: k does not satisfy k>=1' case ( 101 ); msg = 'Error in dbintk: n does not satisfy n>=k' case ( 102 ); msg = 'Error in dbintk: x(i) does not satisfy x(i)<x(i+1) for some i' case ( 103 ); msg = 'Error in dbintk: some abscissa was not in the support of the ' // & 'corresponding basis function and the system is singular' case ( 104 ); msg = 'Error in dbintk: the system of solver detects a singular system ' // & 'although the theoretical conditions for a solution were satisfied' case ( 201 ); msg = 'Error in dbspvn: k does not satisfy k>=1' case ( 202 ); msg = 'Error in dbspvn: jhigh does not satisfy 1<=jhigh<=k' case ( 203 ); msg = 'Error in dbspvn: index is not 1 or 2' case ( 204 ); msg = 'Error in dbspvn: x does not satisfy t(ileft)<=x<=t(ileft+1)' case ( 301 ); msg = 'Error in dbtpcf: n should be > 0' case ( 401 ); msg = 'Error in dbvalu: k does not satisfy k>=1' case ( 402 ); msg = 'Error in dbvalu: n does not satisfy n>=k' case ( 403 ); msg = 'Error in dbvalu: ideriv does not satisfy 0<=ideriv<k' case ( 404 ); msg = 'Error in dbvalu: x is not greater than or equal to t(k)' case ( 405 ); msg = 'Error in dbvalu: x is not less than or equal to t(n+1)' case ( 406 ); msg = 'Error in dbvalu: a left limiting value cannot be obtained at t(k)' case ( 501 ); msg = 'Error in initialize_*d_specify_knots: tx is not the correct size (kx+nx)' case ( 502 ); msg = 'Error in initialize_*d_specify_knots: ty is not the correct size (ky+ny)' case ( 503 ); msg = 'Error in initialize_*d_specify_knots: tz is not the correct size (kz+nz)' case ( 504 ); msg = 'Error in initialize_*d_specify_knots: tq is not the correct size (kq+nq)' case ( 505 ); msg = 'Error in initialize_*d_specify_knots: tr is not the correct size (kr+nr)' case ( 506 ); msg = 'Error in initialize_*d_specify_knots: ts is not the correct size (ks+ns)' case ( 601 ); msg = 'Error in db*val: x value out of bounds' case ( 602 ); msg = 'Error in db*val: y value out of bounds' case ( 603 ); msg = 'Error in db*val: z value out of bounds' case ( 604 ); msg = 'Error in db*val: q value out of bounds' case ( 605 ); msg = 'Error in db*val: r value out of bounds' case ( 606 ); msg = 'Error in db*val: s value out of bounds' case default write ( istr , fmt = '(I10)' , iostat = istat ) iflag msg = 'Unknown status flag: ' // trim ( adjustl ( istr )) end select end function get_status_message","tags":"","loc":"proc/get_status_message.html","title":"get_status_message – Photodissociation of water"},{"text":"public pure subroutine db1ink(x, nx, fcn, kx, iknot, tx, bcoef, iflag) Determines the parameters of a function that interpolates Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x nx array of x abcissae. Must be strictly increasing. integer, intent(in) :: nx Number of x abcissae real(kind=wp), intent(in), dimension(:) :: fcn (nx) array of function values to interpolate. fcn(i) should\n    contain the function value at the point x(i) integer, intent(in) :: kx The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: iknot 0 = knot sequence chosen by db1ink .\n 1 = knot sequence chosen by user. real(kind=wp), intent(inout), dimension(:) :: tx The nx+kx knots in the x direction for the spline interpolant.\n   If iknot=0 these are chosen by db1ink .\n   If iknot=1 these are specified by the user.\n   Must be non-decreasing. real(kind=wp), intent(out), dimension(:) :: bcoef (nx) array of coefficients of the b-spline interpolant. integer, intent(out) :: iflag 0 = successful execution.\n 2 = iknot out of range.\n 3 = nx out of range.\n 4 = kx out of range.\n 5 = x not strictly increasing.\n 6 = tx not non-decreasing.\n 700 = size(x) /= size(fcn,1).\n 706 = size(x) /= nx.\n 712 = size(tx) /= nx+kx.\n 800 = size(x) /= size(bcoef,1). Contents Source Code db1ink Source Code pure subroutine db1ink ( x , nx , fcn , kx , iknot , tx , bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! Number of x abcissae integer , intent ( in ) :: kx !! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) real ( wp ), dimension (:), intent ( in ) :: x !! `nx` array of x abcissae. Must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: fcn !! `(nx)` array of function values to interpolate. `fcn(i)` should !!    contain the function value at the point `x(i)` integer , intent ( in ) :: iknot !! 0 = knot sequence chosen by [[db1ink]]. !! 1 = knot sequence chosen by user. real ( wp ), dimension (:), intent ( inout ) :: tx !! The `nx+kx` knots in the `x` direction for the spline interpolant. !!   If `iknot=0` these are chosen by [[db1ink]]. !!   If `iknot=1` these are specified by the user. !!   Must be non-decreasing. real ( wp ), dimension (:), intent ( out ) :: bcoef !! `(nx)` array of coefficients of the b-spline interpolant. integer , intent ( out ) :: iflag !! 0 = successful execution. !! 2 = iknot out of range. !! 3 = nx out of range. !! 4 = kx out of range. !! 5 = x not strictly increasing. !! 6 = tx not non-decreasing. !! 700 = size(x) /= size(fcn,1). !! 706 = size(x) /= nx. !! 712 = size(tx) /= nx+kx. !! 800 = size(x) /= size(bcoef,1). real ( wp ), dimension ( 2 * kx * ( nx + 1 )) :: work logical :: status_ok !check validity of inputs call check_inputs ( 'db1ink' ,& iknot ,& iflag ,& nx = nx ,& kx = kx ,& x = x ,& f1 = fcn ,& bcoef1 = bcoef ,& tx = tx ,& status_ok = status_ok ) if ( status_ok ) then !choose knots if ( iknot == 0 ) then call dbknot ( x , nx , kx , tx ) end if !construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , 1 , tx , kx , bcoef , work , iflag ) end if end subroutine db1ink","tags":"","loc":"proc/db1ink.html","title":"db1ink – Photodissociation of water"},{"text":"public pure subroutine db1val(xval, idx, tx, nx, kx, bcoef, f, iflag, inbvx) Evaluates the tensor product piecewise polynomial Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db1ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db1ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db1ink ) real(kind=wp), intent(in), dimension(nx) :: bcoef the b-spline coefficients computed by db1ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. Contents Source Code db1val Source Code pure subroutine db1val ( xval , idx , tx , nx , kx , bcoef , f , iflag , inbvx ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db1ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db1ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db1ink]]) real ( wp ), dimension ( nx ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db1ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. real ( wp ), dimension ( 3 * kx ) :: work f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then !write(error_unit,'(A)') 'db1val - x value out of bounds' iflag = 601 return end if call dbvalu ( tx , bcoef , nx , kx , idx , xval , inbvx , work , iflag , f ) end subroutine db1val","tags":"","loc":"proc/db1val.html","title":"db1val – Photodissociation of water"},{"text":"public pure subroutine db2ink(x, nx, y, ny, fcn, kx, ky, iknot, tx, ty, bcoef, iflag) Determines the parameters of a function that interpolates Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x nx array of x abcissae. Must be strictly increasing. integer, intent(in) :: nx Number of x abcissae real(kind=wp), intent(in), dimension(:) :: y ny array of y abcissae. Must be strictly increasing. integer, intent(in) :: ny Number of y abcissae real(kind=wp), intent(in), dimension(:,:) :: fcn (nx,ny) matrix of function values to interpolate. fcn(i,j) should\n    contain the function value at the point (x(i),y(j)) integer, intent(in) :: kx The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: ky The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer, intent(in) :: iknot 0 = knot sequence chosen by db1ink .\n 1 = knot sequence chosen by user. real(kind=wp), intent(inout), dimension(:) :: tx The nx+kx knots in the x direction for the spline interpolant.\n    If iknot=0 these are chosen by db2ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: ty The ny+ky knots in the y direction for the spline interpolant.\n    If iknot=0 these are chosen by db2ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(out), dimension(:,:) :: bcoef (nx,ny) matrix of coefficients of the b-spline interpolant. integer, intent(out) :: iflag 0 = successful execution.\n  2 = iknot out of range.\n  3 = nx out of range.\n  4 = kx out of range.\n  5 = x not strictly increasing.\n  6 = tx not non-decreasing.\n  7 = ny out of range.\n  8 = ky out of range.\n  9 = y not strictly increasing.\n 10 = ty not non-decreasing.\n 700 = size(x) /= size(fcn,1).\n 701 = size(y) /= size(fcn,2).\n 706 = size(x) /= nx.\n 707 = size(y) /= ny.\n 712 = size(tx) /= nx+kx.\n 713 = size(ty) /= ny+ky.\n 800 = size(x) /= size(bcoef,1).\n 801 = size(y) /= size(bcoef,2). Contents Source Code db2ink Source Code pure subroutine db2ink ( x , nx , y , ny , fcn , kx , ky , iknot , tx , ty , bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! Number of x abcissae integer , intent ( in ) :: ny !! Number of y abcissae integer , intent ( in ) :: kx !! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer , intent ( in ) :: ky !! The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) real ( wp ), dimension (:), intent ( in ) :: x !! `nx` array of x abcissae. Must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: y !! `ny` array of y abcissae. Must be strictly increasing. real ( wp ), dimension (:,:), intent ( in ) :: fcn !! `(nx,ny)` matrix of function values to interpolate. `fcn(i,j)` should !!    contain the function value at the point `(x(i),y(j))` integer , intent ( in ) :: iknot !! 0 = knot sequence chosen by [[db1ink]]. !! 1 = knot sequence chosen by user. real ( wp ), dimension (:), intent ( inout ) :: tx !! The `nx+kx` knots in the `x` direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db2ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: ty !! The `ny+ky` knots in the `y` direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db2ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:,:), intent ( out ) :: bcoef !! `(nx,ny)` matrix of coefficients of the b-spline interpolant. integer , intent ( out ) :: iflag !!  0 = successful execution. !!  2 = iknot out of range. !!  3 = nx out of range. !!  4 = kx out of range. !!  5 = x not strictly increasing. !!  6 = tx not non-decreasing. !!  7 = ny out of range. !!  8 = ky out of range. !!  9 = y not strictly increasing. !! 10 = ty not non-decreasing. !! 700 = size(x) /= size(fcn,1). !! 701 = size(y) /= size(fcn,2). !! 706 = size(x) /= nx. !! 707 = size(y) /= ny. !! 712 = size(tx) /= nx+kx. !! 713 = size(ty) /= ny+ky. !! 800 = size(x) /= size(bcoef,1). !! 801 = size(y) /= size(bcoef,2). real ( wp ), dimension ( nx * ny ) :: temp real ( wp ), dimension ( max ( 2 * kx * ( nx + 1 ), 2 * ky * ( ny + 1 ))) :: work logical :: status_ok !check validity of inputs call check_inputs ( 'db2ink' ,& iknot ,& iflag ,& nx = nx , ny = ny ,& kx = kx , ky = ky ,& x = x , y = y ,& tx = tx , ty = ty ,& f2 = fcn ,& bcoef2 = bcoef ,& status_ok = status_ok ) if ( status_ok ) then !choose knots if ( iknot == 0 ) then call dbknot ( x , nx , kx , tx ) call dbknot ( y , ny , ky , ty ) end if !construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , ny , tx , kx , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( y , ny , temp , ny , nx , ty , ky , bcoef , work , iflag ) end if end subroutine db2ink","tags":"","loc":"proc/db2ink.html","title":"db2ink – Photodissociation of water"},{"text":"public pure subroutine db2val(xval, yval, idx, idy, tx, ty, nx, ny, kx, ky, bcoef, f, iflag, inbvx, inbvy, iloy) Evaluates the tensor product piecewise polynomial Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. real(kind=wp), intent(in) :: yval y coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. integer, intent(in) :: idy y derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db2ink ) real(kind=wp), intent(in), dimension(ny+ky) :: ty sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to db2ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db2ink ) integer, intent(in) :: ny the number of interpolation points in y. (same as in last call to db2ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db2ink ) integer, intent(in) :: ky order of polynomial pieces in y. (same as in last call to db2ink ) real(kind=wp), intent(in), dimension(nx,ny) :: bcoef the b-spline coefficients computed by db2ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. Contents Source Code db2val Source Code pure subroutine db2val ( xval , yval , idx , idy , tx , ty , nx , ny , kx , ky , bcoef , f , iflag , inbvx , inbvy , iloy ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idy !! y derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db2ink]]) integer , intent ( in ) :: ny !! the number of interpolation points in y. (same as in last call to [[db2ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db2ink]]) integer , intent ( in ) :: ky !! order of polynomial pieces in y. (same as in last call to [[db2ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), intent ( in ) :: yval !! y coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db2ink]]) real ( wp ), dimension ( ny + ky ), intent ( in ) :: ty !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db2ink]]) real ( wp ), dimension ( nx , ny ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db2ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer :: k , lefty , mflag , kcol real ( wp ), dimension ( ky ) :: temp real ( wp ), dimension ( 3 * max ( kx , ky )) :: work f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then !write(error_unit,'(A)') 'db2val - x value out of bounds' iflag = 601 return end if if ( yval < ty ( 1 ) . or . yval > ty ( ny + ky )) then !write(error_unit,'(A)') 'db2val - y value out of bounds' iflag = 602 return end if iflag = - 1 call dintrv ( ty , ny + ky , yval , iloy , lefty , mflag ); if ( mflag /= 0 ) return kcol = lefty - ky do k = 1 , ky kcol = kcol + 1 call dbvalu ( tx , bcoef (:, kcol ), nx , kx , idx , xval , inbvx , work , iflag , temp ( k )) if ( iflag /= 0 ) return !error end do kcol = lefty - ky + 1 call dbvalu ( ty ( kcol :), temp , ky , ky , idy , yval , inbvy , work , iflag , f ) end subroutine db2val","tags":"","loc":"proc/db2val.html","title":"db2val – Photodissociation of water"},{"text":"public pure subroutine db3ink(x, nx, y, ny, z, nz, fcn, kx, ky, kz, iknot, tx, ty, tz, bcoef, iflag) Determines the parameters of a function that interpolates Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x nx array of x abcissae. must be strictly increasing. integer, intent(in) :: nx number of x abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: y ny array of y abcissae. must be strictly increasing. integer, intent(in) :: ny number of y abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: z nz array of z abcissae. must be strictly increasing. integer, intent(in) :: nz number of z abcissae (>= 3) real(kind=wp), intent(in), dimension(:,:,:) :: fcn (nx,ny,nz) matrix of function values to interpolate. fcn(i,j,k) should\n   contain the function value at the point (x(i),y(j),z(k)) integer, intent(in) :: kx the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: ky the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer, intent(in) :: kz the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) integer, intent(in) :: iknot 0 = knot sequence chosen by db1ink .\n 1 = knot sequence chosen by user. real(kind=wp), intent(inout), dimension(:) :: tx The nx+kx knots in the x direction for the spline interpolant.\n   If iknot=0 these are chosen by db3ink .\n   If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: ty The ny+ky knots in the y direction for the spline interpolant.\n    If iknot=0 these are chosen by db3ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tz The nz+kz knots in the z direction for the spline interpolant.\n    If iknot=0 these are chosen by db3ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(out), dimension(:,:,:) :: bcoef '(nx,ny,nz)' matrix of coefficients of the b-spline interpolant. integer, intent(out) :: iflag 0 = successful execution.\n  2 = iknot out of range.\n  3 = nx out of range.\n  4 = kx out of range.\n  5 = x not strictly increasing.\n  6 = tx not non-decreasing.\n  7 = ny out of range.\n  8 = ky out of range.\n  9 = y not strictly increasing.\n 10 = ty not non-decreasing.\n 11 = nz out of range.\n 12 = kz out of range.\n 13 = z not strictly increasing.\n 14 = ty not non-decreasing.\n 700 = size(x) /= size(fcn,1).\n 701 = size(y) /= size(fcn,2).\n 702 = size(z) /= size(fcn,3).\n 706 = size(x) /= nx.\n 707 = size(y) /= ny.\n 708 = size(z) /= nz.\n 712 = size(tx) /= nx+kx.\n 713 = size(ty) /= ny+ky.\n 714 = size(tz) /= nz+kz.\n 800 = size(x) /= size(bcoef,1).\n 801 = size(y) /= size(bcoef,2).\n 802 = size(z) /= size(bcoef,3). Contents Source Code db3ink Source Code pure subroutine db3ink ( x , nx , y , ny , z , nz , fcn , kx , ky , kz , iknot , tx , ty , tz , bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! number of x abcissae (>= 3) integer , intent ( in ) :: ny !! number of y abcissae (>= 3) integer , intent ( in ) :: nz !! number of z abcissae (>= 3) integer , intent ( in ) :: kx !! the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer , intent ( in ) :: ky !! the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer , intent ( in ) :: kz !! the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) real ( wp ), dimension (:), intent ( in ) :: x !! `nx` array of x abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: y !! `ny` array of y abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: z !! `nz` array of z abcissae. must be strictly increasing. real ( wp ), dimension (:,:,:), intent ( in ) :: fcn !! `(nx,ny,nz)` matrix of function values to interpolate. fcn(i,j,k) should !!   contain the function value at the point (x(i),y(j),z(k)) integer , intent ( in ) :: iknot !! 0 = knot sequence chosen by [[db1ink]]. !! 1 = knot sequence chosen by user. real ( wp ), dimension (:), intent ( inout ) :: tx !! The `nx+kx` knots in the `x` direction for the spline interpolant. !!   If `iknot=0` these are chosen by [[db3ink]]. !!   If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: ty !! The `ny+ky` knots in the `y` direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db3ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tz !! The `nz+kz` knots in the `z` direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db3ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:,:,:), intent ( out ) :: bcoef !! '(nx,ny,nz)' matrix of coefficients of the b-spline interpolant. integer , intent ( out ) :: iflag !!  0 = successful execution. !!  2 = iknot out of range. !!  3 = nx out of range. !!  4 = kx out of range. !!  5 = x not strictly increasing. !!  6 = tx not non-decreasing. !!  7 = ny out of range. !!  8 = ky out of range. !!  9 = y not strictly increasing. !! 10 = ty not non-decreasing. !! 11 = nz out of range. !! 12 = kz out of range. !! 13 = z not strictly increasing. !! 14 = ty not non-decreasing. !! 700 = size(x) /= size(fcn,1). !! 701 = size(y) /= size(fcn,2). !! 702 = size(z) /= size(fcn,3). !! 706 = size(x) /= nx. !! 707 = size(y) /= ny. !! 708 = size(z) /= nz. !! 712 = size(tx) /= nx+kx. !! 713 = size(ty) /= ny+ky. !! 714 = size(tz) /= nz+kz. !! 800 = size(x) /= size(bcoef,1). !! 801 = size(y) /= size(bcoef,2). !! 802 = size(z) /= size(bcoef,3). real ( wp ), dimension ( nx * ny * nz ) :: temp real ( wp ), dimension ( max ( 2 * kx * ( nx + 1 ), 2 * ky * ( ny + 1 ), 2 * kz * ( nz + 1 ))) :: work logical :: status_ok ! check validity of input call check_inputs ( 'db3ink' ,& iknot ,& iflag ,& nx = nx , ny = ny , nz = nz ,& kx = kx , ky = ky , kz = kz ,& x = x , y = y , z = z ,& tx = tx , ty = ty , tz = tz ,& f3 = fcn ,& bcoef3 = bcoef ,& status_ok = status_ok ) if ( status_ok ) then ! choose knots if ( iknot == 0 ) then call dbknot ( x , nx , kx , tx ) call dbknot ( y , ny , ky , ty ) call dbknot ( z , nz , kz , tz ) end if ! copy fcn to work in packed for dbtpcf temp ( 1 : nx * ny * nz ) = reshape ( fcn , [ nx * ny * nz ] ) ! construct b-spline coefficients call dbtpcf ( x , nx , temp , nx , ny * nz , tx , kx , bcoef , work , iflag ) if ( iflag == 0 ) call dbtpcf ( y , ny , bcoef , ny , nx * nz , ty , ky , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( z , nz , temp , nz , nx * ny , tz , kz , bcoef , work , iflag ) end if end subroutine db3ink","tags":"","loc":"proc/db3ink.html","title":"db3ink – Photodissociation of water"},{"text":"public pure subroutine db3val(xval, yval, zval, idx, idy, idz, tx, ty, tz, nx, ny, nz, kx, ky, kz, bcoef, f, iflag, inbvx, inbvy, inbvz, iloy, iloz) Evaluates the tensor product piecewise polynomial Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. real(kind=wp), intent(in) :: yval y coordinate of evaluation point. real(kind=wp), intent(in) :: zval z coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. integer, intent(in) :: idy y derivative of piecewise polynomial to evaluate. integer, intent(in) :: idz z derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db3ink ) real(kind=wp), intent(in), dimension(ny+ky) :: ty sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to db3ink ) real(kind=wp), intent(in), dimension(nz+kz) :: tz sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to db3ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db3ink ) integer, intent(in) :: ny the number of interpolation points in y. (same as in last call to db3ink ) integer, intent(in) :: nz the number of interpolation points in z. (same as in last call to db3ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db3ink ) integer, intent(in) :: ky order of polynomial pieces in y. (same as in last call to db3ink ) integer, intent(in) :: kz order of polynomial pieces in z. (same as in last call to db3ink ) real(kind=wp), intent(in), dimension(nx,ny,nz) :: bcoef the b-spline coefficients computed by db3ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. Contents Source Code db3val Source Code pure subroutine db3val ( xval , yval , zval , idx , idy , idz ,& tx , ty , tz ,& nx , ny , nz , kx , ky , kz , bcoef , f , iflag ,& inbvx , inbvy , inbvz , iloy , iloz ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idy !! y derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idz !! z derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db3ink]]) integer , intent ( in ) :: ny !! the number of interpolation points in y. (same as in last call to [[db3ink]]) integer , intent ( in ) :: nz !! the number of interpolation points in z. (same as in last call to [[db3ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db3ink]]) integer , intent ( in ) :: ky !! order of polynomial pieces in y. (same as in last call to [[db3ink]]) integer , intent ( in ) :: kz !! order of polynomial pieces in z. (same as in last call to [[db3ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), intent ( in ) :: yval !! y coordinate of evaluation point. real ( wp ), intent ( in ) :: zval !! z coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db3ink]]) real ( wp ), dimension ( ny + ky ), intent ( in ) :: ty !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db3ink]]) real ( wp ), dimension ( nz + kz ), intent ( in ) :: tz !! sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to [[db3ink]]) real ( wp ), dimension ( nx , ny , nz ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db3ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. real ( wp ), dimension ( ky , kz ) :: temp1 real ( wp ), dimension ( kz ) :: temp2 real ( wp ), dimension ( 3 * max ( kx , ky , kz )) :: work integer :: lefty , leftz , mflag ,& kcoly , kcolz , j , k f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then !write(error_unit,'(A)') 'db3val - x value out of bounds' iflag = 601 return end if if ( yval < ty ( 1 ) . or . yval > ty ( ny + ky )) then !write(error_unit,'(A)') 'db3val - y value out of bounds' iflag = 602 return end if if ( zval < tz ( 1 ) . or . zval > tz ( nz + kz )) then !write(error_unit,'(A)') 'db3val - z value out of bounds' iflag = 603 return end if iflag = - 1 call dintrv ( ty , ny + ky , yval , iloy , lefty , mflag ); if ( mflag /= 0 ) return call dintrv ( tz , nz + kz , zval , iloz , leftz , mflag ); if ( mflag /= 0 ) return iflag = 0 kcolz = leftz - kz do k = 1 , kz kcolz = kcolz + 1 kcoly = lefty - ky do j = 1 , ky kcoly = kcoly + 1 call dbvalu ( tx , bcoef (:, kcoly , kcolz ), nx , kx , idx , xval , inbvx , work , iflag , temp1 ( j , k )) if ( iflag /= 0 ) return end do end do kcoly = lefty - ky + 1 do k = 1 , kz call dbvalu ( ty ( kcoly :), temp1 (:, k ), ky , ky , idy , yval , inbvy , work , iflag , temp2 ( k )) if ( iflag /= 0 ) return end do kcolz = leftz - kz + 1 call dbvalu ( tz ( kcolz :), temp2 , kz , kz , idz , zval , inbvz , work , iflag , f ) end subroutine db3val","tags":"","loc":"proc/db3val.html","title":"db3val – Photodissociation of water"},{"text":"public pure subroutine db4ink(x, nx, y, ny, z, nz, q, nq, fcn, kx, ky, kz, kq, iknot, tx, ty, tz, tq, bcoef, iflag) Determines the parameters of a function that interpolates Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x nx array of x abcissae. must be strictly increasing. integer, intent(in) :: nx number of x abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: y ny array of y abcissae. must be strictly increasing. integer, intent(in) :: ny number of y abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: z nz array of z abcissae. must be strictly increasing. integer, intent(in) :: nz number of z abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: q nq array of q abcissae. must be strictly increasing. integer, intent(in) :: nq number of q abcissae (>= 3) real(kind=wp), intent(in), dimension(:,:,:,:) :: fcn (nx,ny,nz,nq) matrix of function values to interpolate. fcn(i,j,k,q) should\n   contain the function value at the point (x(i),y(j),z(k),q(l)) integer, intent(in) :: kx the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: ky the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer, intent(in) :: kz the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) integer, intent(in) :: kq the order of spline pieces in q (>= 2, < nq). (order = polynomial degree + 1) integer, intent(in) :: iknot 0 = knot sequence chosen by db1ink .\n 1 = knot sequence chosen by user. real(kind=wp), intent(inout), dimension(:) :: tx The nx+kx knots in the x direction for the spline interpolant.\n   If iknot=0 these are chosen by db4ink .\n   If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: ty The ny+ky knots in the y direction for the spline interpolant.\n    If iknot=0 these are chosen by db4ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tz The nz+kz knots in the z direction for the spline interpolant.\n    If iknot=0 these are chosen by db4ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tq The nq+kq knots in the q direction for the spline interpolant.\n    If iknot=0 these are chosen by db4ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(out), dimension(:,:,:,:) :: bcoef (nx,ny,nz,nq) matrix of coefficients of the b-spline interpolant. integer, intent(out) :: iflag 0 = successful execution.\n  2 = iknot out of range.\n  3 = nx out of range.\n  4 = kx out of range.\n  5 = x not strictly increasing.\n  6 = tx not non-decreasing.\n  7 = ny out of range.\n  8 = ky out of range.\n  9 = y not strictly increasing.\n 10 = ty not non-decreasing.\n 11 = nz out of range.\n 12 = kz out of range.\n 13 = z not strictly increasing.\n 14 = tz not non-decreasing.\n 15 = nq out of range.\n 16 = kq out of range.\n 17 = q not strictly increasing.\n 18 = tq not non-decreasing.\n 700 = size(x) /= size(fcn,1).\n 701 = size(y) /= size(fcn,2).\n 702 = size(z) /= size(fcn,3).\n 703 = size(q) /= size(fcn,4).\n 706 = size(x) /= nx.\n 707 = size(y) /= ny.\n 708 = size(z) /= nz.\n 709 = size(q) /= nq.\n 712 = size(tx) /= nx+kx.\n 713 = size(ty) /= ny+ky.\n 714 = size(tz) /= nz+kz.\n 715 = size(tq) /= nq+kq.\n 800 = size(x) /= size(bcoef,1).\n 801 = size(y) /= size(bcoef,2).\n 802 = size(z) /= size(bcoef,3).\n 803 = size(q) /= size(bcoef,4). Contents Source Code db4ink Source Code pure subroutine db4ink ( x , nx , y , ny , z , nz , q , nq ,& fcn ,& kx , ky , kz , kq ,& iknot ,& tx , ty , tz , tq ,& bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! number of x abcissae (>= 3) integer , intent ( in ) :: ny !! number of y abcissae (>= 3) integer , intent ( in ) :: nz !! number of z abcissae (>= 3) integer , intent ( in ) :: nq !! number of q abcissae (>= 3) integer , intent ( in ) :: kx !! the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer , intent ( in ) :: ky !! the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer , intent ( in ) :: kz !! the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) integer , intent ( in ) :: kq !! the order of spline pieces in q (>= 2, < nq). (order = polynomial degree + 1) real ( wp ), dimension (:), intent ( in ) :: x !! `nx` array of x abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: y !! `ny` array of y abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: z !! `nz` array of z abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: q !! `nq` array of q abcissae. must be strictly increasing. real ( wp ), dimension (:,:,:,:), intent ( in ) :: fcn !! `(nx,ny,nz,nq)` matrix of function values to interpolate. fcn(i,j,k,q) should !!   contain the function value at the point (x(i),y(j),z(k),q(l)) integer , intent ( in ) :: iknot !! 0 = knot sequence chosen by [[db1ink]]. !! 1 = knot sequence chosen by user. real ( wp ), dimension (:), intent ( inout ) :: tx !! The `nx+kx` knots in the x direction for the spline interpolant. !!   If `iknot=0` these are chosen by [[db4ink]]. !!   If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: ty !! The `ny+ky` knots in the y direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db4ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tz !! The `nz+kz` knots in the z direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db4ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tq !! The `nq+kq` knots in the q direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db4ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:,:,:,:), intent ( out ) :: bcoef !! `(nx,ny,nz,nq)` matrix of coefficients of the b-spline interpolant. integer , intent ( out ) :: iflag !!  0 = successful execution. !!  2 = iknot out of range. !!  3 = nx out of range. !!  4 = kx out of range. !!  5 = x not strictly increasing. !!  6 = tx not non-decreasing. !!  7 = ny out of range. !!  8 = ky out of range. !!  9 = y not strictly increasing. !! 10 = ty not non-decreasing. !! 11 = nz out of range. !! 12 = kz out of range. !! 13 = z not strictly increasing. !! 14 = tz not non-decreasing. !! 15 = nq out of range. !! 16 = kq out of range. !! 17 = q not strictly increasing. !! 18 = tq not non-decreasing. !! 700 = size(x) /= size(fcn,1). !! 701 = size(y) /= size(fcn,2). !! 702 = size(z) /= size(fcn,3). !! 703 = size(q) /= size(fcn,4). !! 706 = size(x) /= nx. !! 707 = size(y) /= ny. !! 708 = size(z) /= nz. !! 709 = size(q) /= nq. !! 712 = size(tx) /= nx+kx. !! 713 = size(ty) /= ny+ky. !! 714 = size(tz) /= nz+kz. !! 715 = size(tq) /= nq+kq. !! 800 = size(x) /= size(bcoef,1). !! 801 = size(y) /= size(bcoef,2). !! 802 = size(z) /= size(bcoef,3). !! 803 = size(q) /= size(bcoef,4). real ( wp ), dimension ( nx * ny * nz * nq ) :: temp real ( wp ), dimension ( max ( 2 * kx * ( nx + 1 ), 2 * ky * ( ny + 1 ), 2 * kz * ( nz + 1 ), 2 * kq * ( nq + 1 ))) :: work logical :: status_ok ! check validity of input call check_inputs ( 'db4ink' ,& iknot ,& iflag ,& nx = nx , ny = ny , nz = nz , nq = nq ,& kx = kx , ky = ky , kz = kz , kq = kq ,& x = x , y = y , z = z , q = q ,& tx = tx , ty = ty , tz = tz , tq = tq ,& f4 = fcn ,& bcoef4 = bcoef ,& status_ok = status_ok ) if ( status_ok ) then ! choose knots if ( iknot == 0 ) then call dbknot ( x , nx , kx , tx ) call dbknot ( y , ny , ky , ty ) call dbknot ( z , nz , kz , tz ) call dbknot ( q , nq , kq , tq ) end if ! construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , ny * nz * nq , tx , kx , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( y , ny , temp , ny , nx * nz * nq , ty , ky , bcoef , work , iflag ) if ( iflag == 0 ) call dbtpcf ( z , nz , bcoef , nz , nx * ny * nq , tz , kz , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( q , nq , temp , nq , nx * ny * nz , tq , kq , bcoef , work , iflag ) end if end subroutine db4ink","tags":"","loc":"proc/db4ink.html","title":"db4ink – Photodissociation of water"},{"text":"public pure subroutine db4val(xval, yval, zval, qval, idx, idy, idz, idq, tx, ty, tz, tq, nx, ny, nz, nq, kx, ky, kz, kq, bcoef, f, iflag, inbvx, inbvy, inbvz, inbvq, iloy, iloz, iloq) Evaluates the tensor product piecewise polynomial Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. real(kind=wp), intent(in) :: yval y coordinate of evaluation point. real(kind=wp), intent(in) :: zval z coordinate of evaluation point. real(kind=wp), intent(in) :: qval q coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. integer, intent(in) :: idy y derivative of piecewise polynomial to evaluate. integer, intent(in) :: idz z derivative of piecewise polynomial to evaluate. integer, intent(in) :: idq q derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db4ink ) real(kind=wp), intent(in), dimension(ny+ky) :: ty sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to db4ink ) real(kind=wp), intent(in), dimension(nz+kz) :: tz sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to db4ink ) real(kind=wp), intent(in), dimension(nq+kq) :: tq sequence of knots defining the piecewise polynomial in the q direction. (same as in last call to db4ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db4ink ) integer, intent(in) :: ny the number of interpolation points in y. (same as in last call to db4ink ) integer, intent(in) :: nz the number of interpolation points in z. (same as in last call to db4ink ) integer, intent(in) :: nq the number of interpolation points in q. (same as in last call to db4ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db4ink ) integer, intent(in) :: ky order of polynomial pieces in y. (same as in last call to db4ink ) integer, intent(in) :: kz order of polynomial pieces in z. (same as in last call to db4ink ) integer, intent(in) :: kq order of polynomial pieces in q. (same as in last call to db4ink ) real(kind=wp), intent(in), dimension(nx,ny,nz,nq) :: bcoef the b-spline coefficients computed by db4ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvq initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloq initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. Contents Source Code db4val Source Code pure subroutine db4val ( xval , yval , zval , qval ,& idx , idy , idz , idq ,& tx , ty , tz , tq ,& nx , ny , nz , nq ,& kx , ky , kz , kq ,& bcoef , f , iflag ,& inbvx , inbvy , inbvz , inbvq , iloy , iloz , iloq ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idy !! y derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idz !! z derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idq !! q derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db4ink]]) integer , intent ( in ) :: ny !! the number of interpolation points in y. (same as in last call to [[db4ink]]) integer , intent ( in ) :: nz !! the number of interpolation points in z. (same as in last call to [[db4ink]]) integer , intent ( in ) :: nq !! the number of interpolation points in q. (same as in last call to [[db4ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db4ink]]) integer , intent ( in ) :: ky !! order of polynomial pieces in y. (same as in last call to [[db4ink]]) integer , intent ( in ) :: kz !! order of polynomial pieces in z. (same as in last call to [[db4ink]]) integer , intent ( in ) :: kq !! order of polynomial pieces in q. (same as in last call to [[db4ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), intent ( in ) :: yval !! y coordinate of evaluation point. real ( wp ), intent ( in ) :: zval !! z coordinate of evaluation point. real ( wp ), intent ( in ) :: qval !! q coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db4ink]]) real ( wp ), dimension ( ny + ky ), intent ( in ) :: ty !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db4ink]]) real ( wp ), dimension ( nz + kz ), intent ( in ) :: tz !! sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to [[db4ink]]) real ( wp ), dimension ( nq + kq ), intent ( in ) :: tq !! sequence of knots defining the piecewise polynomial in the q direction. (same as in last call to [[db4ink]]) real ( wp ), dimension ( nx , ny , nz , nq ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db4ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvq !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloq !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. real ( wp ), dimension ( ky , kz , kq ) :: temp1 real ( wp ), dimension ( kz , kq ) :: temp2 real ( wp ), dimension ( kq ) :: temp3 real ( wp ), dimension ( 3 * max ( kx , ky , kz , kq )) :: work integer :: lefty , leftz , leftq , mflag ,& kcoly , kcolz , kcolq , j , k , q f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then !write(error_unit,'(A)') 'db4val - x value out of bounds' iflag = 601 return end if if ( yval < ty ( 1 ) . or . yval > ty ( ny + ky )) then !write(error_unit,'(A)') 'db4val - y value out of bounds' iflag = 602 return end if if ( zval < tz ( 1 ) . or . zval > tz ( nz + kz )) then !write(error_unit,'(A)') 'db4val - z value out of bounds' iflag = 603 return end if if ( qval < tq ( 1 ) . or . qval > tq ( nq + kq ) ) then !write(error_unit,'(A)') 'db4val - q value out of bounds' iflag = 604 return end if iflag = - 1 call dintrv ( ty , ny + ky , yval , iloy , lefty , mflag ); if ( mflag /= 0 ) return call dintrv ( tz , nz + kz , zval , iloz , leftz , mflag ); if ( mflag /= 0 ) return call dintrv ( tq , nq + kq , qval , iloq , leftq , mflag ); if ( mflag /= 0 ) return iflag = 0 ! x -> y, z, q kcolq = leftq - kq do q = 1 , kq kcolq = kcolq + 1 kcolz = leftz - kz do k = 1 , kz kcolz = kcolz + 1 kcoly = lefty - ky do j = 1 , ky kcoly = kcoly + 1 call dbvalu ( tx , bcoef (:, kcoly , kcolz , kcolq ),& nx , kx , idx , xval , inbvx , work , iflag , temp1 ( j , k , q )) if ( iflag /= 0 ) return end do end do end do ! y -> z, q kcoly = lefty - ky + 1 do q = 1 , kq do k = 1 , kz call dbvalu ( ty ( kcoly :), temp1 (:, k , q ), ky , ky , idy , yval , inbvy , work , iflag , temp2 ( k , q )) if ( iflag /= 0 ) return end do end do ! z -> q kcolz = leftz - kz + 1 do q = 1 , kq call dbvalu ( tz ( kcolz :), temp2 (:, q ), kz , kz , idz , zval , inbvz , work , iflag , temp3 ( q )) if ( iflag /= 0 ) return end do ! q kcolq = leftq - kq + 1 call dbvalu ( tq ( kcolq :), temp3 , kq , kq , idq , qval , inbvq , work , iflag , f ) end subroutine db4val","tags":"","loc":"proc/db4val.html","title":"db4val – Photodissociation of water"},{"text":"public pure subroutine db5ink(x, nx, y, ny, z, nz, q, nq, r, nr, fcn, kx, ky, kz, kq, kr, iknot, tx, ty, tz, tq, tr, bcoef, iflag) Determines the parameters of a function that interpolates Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x nx array of x abcissae. must be strictly increasing. integer, intent(in) :: nx number of x abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: y ny array of y abcissae. must be strictly increasing. integer, intent(in) :: ny number of y abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: z nz array of z abcissae. must be strictly increasing. integer, intent(in) :: nz number of z abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: q nq array of q abcissae. must be strictly increasing. integer, intent(in) :: nq number of q abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: r nr array of r abcissae. must be strictly increasing. integer, intent(in) :: nr number of r abcissae (>= 3) real(kind=wp), intent(in), dimension(:,:,:,:,:) :: fcn (nx,ny,nz,nq,nr) matrix of function values to interpolate. fcn(i,j,k,q,r) should\n   contain the function value at the point (x(i),y(j),z(k),q(l),r(m)) integer, intent(in) :: kx the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: ky the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer, intent(in) :: kz the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) integer, intent(in) :: kq the order of spline pieces in q (>= 2, < nq). (order = polynomial degree + 1) integer, intent(in) :: kr the order of spline pieces in r (>= 2, < nr). (order = polynomial degree + 1) integer, intent(in) :: iknot 0 = knot sequence chosen by db1ink .\n 1 = knot sequence chosen by user. real(kind=wp), intent(inout), dimension(:) :: tx The nx+kx knots in the x direction for the spline interpolant.\n   If iknot=0 these are chosen by db5ink .\n   If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: ty The ny+ky knots in the y direction for the spline interpolant.\n    If iknot=0 these are chosen by db5ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tz The nz+kz knots in the z direction for the spline interpolant.\n    If iknot=0 these are chosen by db5ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tq The nq+kq knots in the q direction for the spline interpolant.\n    If iknot=0 these are chosen by db5ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tr The nr+kr knots in the r direction for the spline interpolant.\n    If iknot=0 these are chosen by db5ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(out), dimension(:,:,:,:,:) :: bcoef (nx,ny,nz,nq,nr) matrix of coefficients of the b-spline interpolant. integer, intent(out) :: iflag 0 = successful execution.\n  2 = iknot out of range.\n  3 = nx out of range.\n  4 = kx out of range.\n  5 = x not strictly increasing.\n  6 = tx not non-decreasing.\n  7 = ny out of range.\n  8 = ky out of range.\n  9 = y not strictly increasing.\n 10 = ty not non-decreasing.\n 11 = nz out of range.\n 12 = kz out of range.\n 13 = z not strictly increasing.\n 14 = tz not non-decreasing.\n 15 = nq out of range.\n 16 = kq out of range.\n 17 = q not strictly increasing.\n 18 = tq not non-decreasing.\n 19 = nr out of range.\n 20 = kr out of range.\n 21 = r not strictly increasing.\n 22 = tr not non-decreasing.\n 700 = size(x) /= size(fcn,1).\n 701 = size(y) /= size(fcn,2).\n 702 = size(z) /= size(fcn,3).\n 703 = size(q) /= size(fcn,4).\n 704 = size(r) /= size(fcn,5).\n 706 = size(x) /= nx.\n 707 = size(y) /= ny.\n 708 = size(z) /= nz.\n 709 = size(q) /= nq.\n 710 = size(r) /= nr.\n 712 = size(tx) /= nx+kx.\n 713 = size(ty) /= ny+ky.\n 714 = size(tz) /= nz+kz.\n 715 = size(tq) /= nq+kq.\n 716 = size(tr) /= nr+kr.\n 800 = size(x) /= size(bcoef,1).\n 801 = size(y) /= size(bcoef,2).\n 802 = size(z) /= size(bcoef,3).\n 803 = size(q) /= size(bcoef,4).\n 804 = size(r) /= size(bcoef,5). Contents Source Code db5ink Source Code pure subroutine db5ink ( x , nx , y , ny , z , nz , q , nq , r , nr ,& fcn ,& kx , ky , kz , kq , kr ,& iknot ,& tx , ty , tz , tq , tr ,& bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! number of x abcissae (>= 3) integer , intent ( in ) :: ny !! number of y abcissae (>= 3) integer , intent ( in ) :: nz !! number of z abcissae (>= 3) integer , intent ( in ) :: nq !! number of q abcissae (>= 3) integer , intent ( in ) :: nr !! number of r abcissae (>= 3) integer , intent ( in ) :: kx !! the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer , intent ( in ) :: ky !! the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer , intent ( in ) :: kz !! the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) integer , intent ( in ) :: kq !! the order of spline pieces in q (>= 2, < nq). (order = polynomial degree + 1) integer , intent ( in ) :: kr !! the order of spline pieces in r (>= 2, < nr). (order = polynomial degree + 1) real ( wp ), dimension (:), intent ( in ) :: x !! `nx` array of x abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: y !! `ny` array of y abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: z !! `nz` array of z abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: q !! `nq` array of q abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: r !! `nr` array of r abcissae. must be strictly increasing. real ( wp ), dimension (:,:,:,:,:), intent ( in ) :: fcn !! `(nx,ny,nz,nq,nr)` matrix of function values to interpolate. fcn(i,j,k,q,r) should !!   contain the function value at the point (x(i),y(j),z(k),q(l),r(m)) integer , intent ( in ) :: iknot !! 0 = knot sequence chosen by [[db1ink]]. !! 1 = knot sequence chosen by user. real ( wp ), dimension (:), intent ( inout ) :: tx !! The `nx+kx` knots in the x direction for the spline interpolant. !!   If `iknot=0` these are chosen by [[db5ink]]. !!   If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: ty !! The `ny+ky` knots in the y direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db5ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tz !! The `nz+kz` knots in the z direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db5ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tq !! The `nq+kq` knots in the q direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db5ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tr !! The `nr+kr` knots in the r direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db5ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:,:,:,:,:), intent ( out ) :: bcoef !! `(nx,ny,nz,nq,nr)` matrix of coefficients of the b-spline interpolant. integer , intent ( out ) :: iflag !!  0 = successful execution. !!  2 = iknot out of range. !!  3 = nx out of range. !!  4 = kx out of range. !!  5 = x not strictly increasing. !!  6 = tx not non-decreasing. !!  7 = ny out of range. !!  8 = ky out of range. !!  9 = y not strictly increasing. !! 10 = ty not non-decreasing. !! 11 = nz out of range. !! 12 = kz out of range. !! 13 = z not strictly increasing. !! 14 = tz not non-decreasing. !! 15 = nq out of range. !! 16 = kq out of range. !! 17 = q not strictly increasing. !! 18 = tq not non-decreasing. !! 19 = nr out of range. !! 20 = kr out of range. !! 21 = r not strictly increasing. !! 22 = tr not non-decreasing. !! 700 = size(x) /= size(fcn,1). !! 701 = size(y) /= size(fcn,2). !! 702 = size(z) /= size(fcn,3). !! 703 = size(q) /= size(fcn,4). !! 704 = size(r) /= size(fcn,5). !! 706 = size(x) /= nx. !! 707 = size(y) /= ny. !! 708 = size(z) /= nz. !! 709 = size(q) /= nq. !! 710 = size(r) /= nr. !! 712 = size(tx) /= nx+kx. !! 713 = size(ty) /= ny+ky. !! 714 = size(tz) /= nz+kz. !! 715 = size(tq) /= nq+kq. !! 716 = size(tr) /= nr+kr. !! 800 = size(x) /= size(bcoef,1). !! 801 = size(y) /= size(bcoef,2). !! 802 = size(z) /= size(bcoef,3). !! 803 = size(q) /= size(bcoef,4). !! 804 = size(r) /= size(bcoef,5). real ( wp ), dimension ( nx * ny * nz * nq * nr ) :: temp real ( wp ), dimension ( max ( 2 * kx * ( nx + 1 ),& 2 * ky * ( ny + 1 ),& 2 * kz * ( nz + 1 ),& 2 * kq * ( nq + 1 ),& 2 * kr * ( nr + 1 ) )) :: work logical :: status_ok !  check validity of input call check_inputs ( 'db5ink' ,& iknot ,& iflag ,& nx = nx , ny = ny , nz = nz , nq = nq , nr = nr ,& kx = kx , ky = ky , kz = kz , kq = kq , kr = kr ,& x = x , y = y , z = z , q = q , r = r ,& tx = tx , ty = ty , tz = tz , tq = tq , tr = tr ,& f5 = fcn ,& bcoef5 = bcoef ,& status_ok = status_ok ) if ( status_ok ) then !  choose knots if ( iknot == 0 ) then call dbknot ( x , nx , kx , tx ) call dbknot ( y , ny , ky , ty ) call dbknot ( z , nz , kz , tz ) call dbknot ( q , nq , kq , tq ) call dbknot ( r , nr , kr , tr ) end if ! copy fcn to work in packed for dbtpcf temp ( 1 : nx * ny * nz * nq * nr ) = reshape ( fcn , [ nx * ny * nz * nq * nr ] ) !  construct b-spline coefficients call dbtpcf ( x , nx , temp , nx , ny * nz * nq * nr , tx , kx , bcoef , work , iflag ) if ( iflag == 0 ) call dbtpcf ( y , ny , bcoef , ny , nx * nz * nq * nr , ty , ky , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( z , nz , temp , nz , nx * ny * nq * nr , tz , kz , bcoef , work , iflag ) if ( iflag == 0 ) call dbtpcf ( q , nq , bcoef , nq , nx * ny * nz * nr , tq , kq , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( r , nr , temp , nr , nx * ny * nz * nq , tr , kr , bcoef , work , iflag ) end if end subroutine db5ink","tags":"","loc":"proc/db5ink.html","title":"db5ink – Photodissociation of water"},{"text":"public pure subroutine db5val(xval, yval, zval, qval, rval, idx, idy, idz, idq, idr, tx, ty, tz, tq, tr, nx, ny, nz, nq, nr, kx, ky, kz, kq, kr, bcoef, f, iflag, inbvx, inbvy, inbvz, inbvq, inbvr, iloy, iloz, iloq, ilor) Evaluates the tensor product piecewise polynomial Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. real(kind=wp), intent(in) :: yval y coordinate of evaluation point. real(kind=wp), intent(in) :: zval z coordinate of evaluation point. real(kind=wp), intent(in) :: qval q coordinate of evaluation point. real(kind=wp), intent(in) :: rval r coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. integer, intent(in) :: idy y derivative of piecewise polynomial to evaluate. integer, intent(in) :: idz z derivative of piecewise polynomial to evaluate. integer, intent(in) :: idq q derivative of piecewise polynomial to evaluate. integer, intent(in) :: idr r derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db5ink ) real(kind=wp), intent(in), dimension(ny+ky) :: ty sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to db5ink ) real(kind=wp), intent(in), dimension(nz+kz) :: tz sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to db5ink ) real(kind=wp), intent(in), dimension(nq+kq) :: tq sequence of knots defining the piecewise polynomial in the q direction. (same as in last call to db5ink ) real(kind=wp), intent(in), dimension(nr+kr) :: tr sequence of knots defining the piecewise polynomial in the r direction. (same as in last call to db5ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db5ink ) integer, intent(in) :: ny the number of interpolation points in y. (same as in last call to db5ink ) integer, intent(in) :: nz the number of interpolation points in z. (same as in last call to db5ink ) integer, intent(in) :: nq the number of interpolation points in q. (same as in last call to db5ink ) integer, intent(in) :: nr the number of interpolation points in r. (same as in last call to db5ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db5ink ) integer, intent(in) :: ky order of polynomial pieces in y. (same as in last call to db5ink ) integer, intent(in) :: kz order of polynomial pieces in z. (same as in last call to db5ink ) integer, intent(in) :: kq order of polynomial pieces in q. (same as in last call to db5ink ) integer, intent(in) :: kr order of polynomial pieces in r. (same as in last call to db5ink ) real(kind=wp), intent(in), dimension(nx,ny,nz,nq,nr) :: bcoef the b-spline coefficients computed by db5ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvq initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvr initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloq initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: ilor initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. Contents Source Code db5val Source Code pure subroutine db5val ( xval , yval , zval , qval , rval ,& idx , idy , idz , idq , idr ,& tx , ty , tz , tq , tr ,& nx , ny , nz , nq , nr ,& kx , ky , kz , kq , kr ,& bcoef , f , iflag ,& inbvx , inbvy , inbvz , inbvq , inbvr , iloy , iloz , iloq , ilor ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idy !! y derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idz !! z derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idq !! q derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idr !! r derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db5ink]]) integer , intent ( in ) :: ny !! the number of interpolation points in y. (same as in last call to [[db5ink]]) integer , intent ( in ) :: nz !! the number of interpolation points in z. (same as in last call to [[db5ink]]) integer , intent ( in ) :: nq !! the number of interpolation points in q. (same as in last call to [[db5ink]]) integer , intent ( in ) :: nr !! the number of interpolation points in r. (same as in last call to [[db5ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db5ink]]) integer , intent ( in ) :: ky !! order of polynomial pieces in y. (same as in last call to [[db5ink]]) integer , intent ( in ) :: kz !! order of polynomial pieces in z. (same as in last call to [[db5ink]]) integer , intent ( in ) :: kq !! order of polynomial pieces in q. (same as in last call to [[db5ink]]) integer , intent ( in ) :: kr !! order of polynomial pieces in r. (same as in last call to [[db5ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), intent ( in ) :: yval !! y coordinate of evaluation point. real ( wp ), intent ( in ) :: zval !! z coordinate of evaluation point. real ( wp ), intent ( in ) :: qval !! q coordinate of evaluation point. real ( wp ), intent ( in ) :: rval !! r coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db5ink]]) real ( wp ), dimension ( ny + ky ), intent ( in ) :: ty !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db5ink]]) real ( wp ), dimension ( nz + kz ), intent ( in ) :: tz !! sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to [[db5ink]]) real ( wp ), dimension ( nq + kq ), intent ( in ) :: tq !! sequence of knots defining the piecewise polynomial in the q direction. (same as in last call to [[db5ink]]) real ( wp ), dimension ( nr + kr ), intent ( in ) :: tr !! sequence of knots defining the piecewise polynomial in the r direction. (same as in last call to [[db5ink]]) real ( wp ), dimension ( nx , ny , nz , nq , nr ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db5ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvq !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvr !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloq !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: ilor !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. real ( wp ), dimension ( ky , kz , kq , kr ) :: temp1 real ( wp ), dimension ( kz , kq , kr ) :: temp2 real ( wp ), dimension ( kq , kr ) :: temp3 real ( wp ), dimension ( kr ) :: temp4 real ( wp ), dimension ( 3 * max ( kx , ky , kz , kq , kr )) :: work integer :: lefty , leftz , leftq , leftr , mflag ,& kcoly , kcolz , kcolq , kcolr , j , k , q , r f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then !write(error_unit,'(A)') 'db5val - x value out of bounds' iflag = 601 return end if if ( yval < ty ( 1 ) . or . yval > ty ( ny + ky )) then !write(error_unit,'(A)') 'db5val - y value out of bounds' iflag = 602 return end if if ( zval < tz ( 1 ) . or . zval > tz ( nz + kz )) then !write(error_unit,'(A)') 'db5val - z value out of bounds' iflag = 603 return end if if ( qval < tq ( 1 ) . or . qval > tq ( nq + kq ) ) then !write(error_unit,'(A)') 'db5val - q value out of bounds' iflag = 604 return end if if ( rval < tr ( 1 ) . or . rval > tr ( nr + kr ) ) then !write(error_unit,'(A)') 'db5val - r value out of bounds' iflag = 605 return end if iflag = - 1 call dintrv ( ty , ny + ky , yval , iloy , lefty , mflag ); if ( mflag /= 0 ) return call dintrv ( tz , nz + kz , zval , iloz , leftz , mflag ); if ( mflag /= 0 ) return call dintrv ( tq , nq + kq , qval , iloq , leftq , mflag ); if ( mflag /= 0 ) return call dintrv ( tr , nr + kr , rval , ilor , leftr , mflag ); if ( mflag /= 0 ) return iflag = 0 ! x -> y, z, q, r kcolr = leftr - kr do r = 1 , kr kcolr = kcolr + 1 kcolq = leftq - kq do q = 1 , kq kcolq = kcolq + 1 kcolz = leftz - kz do k = 1 , kz kcolz = kcolz + 1 kcoly = lefty - ky do j = 1 , ky kcoly = kcoly + 1 call dbvalu ( tx , bcoef (:, kcoly , kcolz , kcolq , kcolr ),& nx , kx , idx , xval , inbvx , work , iflag , temp1 ( j , k , q , r )) if ( iflag /= 0 ) return end do end do end do end do ! y -> z, q, r kcoly = lefty - ky + 1 do r = 1 , kr do q = 1 , kq do k = 1 , kz call dbvalu ( ty ( kcoly :), temp1 (:, k , q , r ), ky , ky , idy , yval , inbvy , work , iflag , temp2 ( k , q , r )) if ( iflag /= 0 ) return end do end do end do ! z -> q, r kcolz = leftz - kz + 1 do r = 1 , kr do q = 1 , kq call dbvalu ( tz ( kcolz :), temp2 (:, q , r ), kz , kz , idz , zval , inbvz , work , iflag , temp3 ( q , r )) if ( iflag /= 0 ) return end do end do ! q -> r kcolq = leftq - kq + 1 do r = 1 , kr call dbvalu ( tq ( kcolq :), temp3 (:, r ), kq , kq , idq , qval , inbvq , work , iflag , temp4 ( r )) if ( iflag /= 0 ) return end do ! r kcolr = leftr - kr + 1 call dbvalu ( tr ( kcolr :), temp4 , kr , kr , idr , rval , inbvr , work , iflag , f ) end subroutine db5val","tags":"","loc":"proc/db5val.html","title":"db5val – Photodissociation of water"},{"text":"public pure subroutine db6ink(x, nx, y, ny, z, nz, q, nq, r, nr, s, ns, fcn, kx, ky, kz, kq, kr, ks, iknot, tx, ty, tz, tq, tr, ts, bcoef, iflag) Determines the parameters of a function that interpolates Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x nx array of x abcissae. must be strictly increasing. integer, intent(in) :: nx number of x abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: y ny array of y abcissae. must be strictly increasing. integer, intent(in) :: ny number of y abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: z nz array of z abcissae. must be strictly increasing. integer, intent(in) :: nz number of z abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: q nq array of q abcissae. must be strictly increasing. integer, intent(in) :: nq number of q abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: r nr array of r abcissae. must be strictly increasing. integer, intent(in) :: nr number of r abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: s ns array of s abcissae. must be strictly increasing. integer, intent(in) :: ns number of s abcissae (>= 3) real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: fcn (nx,ny,nz,nq,nr,ns) matrix of function values to interpolate. fcn(i,j,k,q,r,s) should\n   contain the function value at the point (x(i),y(j),z(k),q(l),r(m),s(n)) integer, intent(in) :: kx the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: ky the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer, intent(in) :: kz the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) integer, intent(in) :: kq the order of spline pieces in q (>= 2, < nq). (order = polynomial degree + 1) integer, intent(in) :: kr the order of spline pieces in r (>= 2, < nr). (order = polynomial degree + 1) integer, intent(in) :: ks the order of spline pieces in s (>= 2, < ns). (order = polynomial degree + 1) integer, intent(in) :: iknot 0 = knot sequence chosen by db1ink .\n 1 = knot sequence chosen by user. real(kind=wp), intent(inout), dimension(:) :: tx The nx+kx knots in the x direction for the spline interpolant.\n   If iknot=0 these are chosen by db6ink .\n   If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: ty The ny+ky knots in the y direction for the spline interpolant.\n    If iknot=0 these are chosen by db6ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tz The nz+kz knots in the z direction for the spline interpolant.\n    If iknot=0 these are chosen by db6ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tq The nq+kq knots in the q direction for the spline interpolant.\n    If iknot=0 these are chosen by db6ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tr The nr+kr knots in the r direction for the spline interpolant.\n    If iknot=0 these are chosen by db6ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: ts The ns+ks knots in the s direction for the spline interpolant.\n    If iknot=0 these are chosen by db6ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(out), dimension(:,:,:,:,:,:) :: bcoef (nx,ny,nz,nq,nr,ns) matrix of coefficients of the b-spline interpolant. integer, intent(out) :: iflag 0 = successful execution.\n  2 = iknot out of range.\n  3 = nx out of range.\n  4 = kx out of range.\n  5 = x not strictly increasing.\n  6 = tx not non-decreasing.\n  7 = ny out of range.\n  8 = ky out of range.\n  9 = y not strictly increasing.\n 10 = ty not non-decreasing.\n 11 = nz out of range.\n 12 = kz out of range.\n 13 = z not strictly increasing.\n 14 = tz not non-decreasing.\n 15 = nq out of range.\n 16 = kq out of range.\n 17 = q not strictly increasing.\n 18 = tq not non-decreasing.\n 19 = nr out of range.\n 20 = kr out of range.\n 21 = r not strictly increasing.\n 22 = tr not non-decreasing.\n 23 = ns out of range.\n 24 = ks out of range.\n 25 = s not strictly increasing.\n 26 = ts not non-decreasing.\n 700 = size(x) /= size(fcn,1).\n 701 = size(y) /= size(fcn,2).\n 702 = size(z) /= size(fcn,3).\n 703 = size(q) /= size(fcn,4).\n 704 = size(r) /= size(fcn,5).\n 705 = size(s) /= size(fcn,6).\n 706 = size(x) /= nx.\n 707 = size(y) /= ny.\n 708 = size(z) /= nz.\n 709 = size(q) /= nq.\n 710 = size(r) /= nr.\n 711 = size(s) /= ns.\n 712 = size(tx) /= nx+kx.\n 713 = size(ty) /= ny+ky.\n 714 = size(tz) /= nz+kz.\n 715 = size(tq) /= nq+kq.\n 716 = size(tr) /= nr+kr.\n 717 = size(ts) /= ns+ks.\n 800 = size(x) /= size(bcoef,1).\n 801 = size(y) /= size(bcoef,2).\n 802 = size(z) /= size(bcoef,3).\n 803 = size(q) /= size(bcoef,4).\n 804 = size(r) /= size(bcoef,5).\n 805 = size(s) /= size(bcoef,6). Contents Source Code db6ink Source Code pure subroutine db6ink ( x , nx , y , ny , z , nz , q , nq , r , nr , s , ns ,& fcn ,& kx , ky , kz , kq , kr , ks ,& iknot ,& tx , ty , tz , tq , tr , ts ,& bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! number of x abcissae (>= 3) integer , intent ( in ) :: ny !! number of y abcissae (>= 3) integer , intent ( in ) :: nz !! number of z abcissae (>= 3) integer , intent ( in ) :: nq !! number of q abcissae (>= 3) integer , intent ( in ) :: nr !! number of r abcissae (>= 3) integer , intent ( in ) :: ns !! number of s abcissae (>= 3) integer , intent ( in ) :: kx !! the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer , intent ( in ) :: ky !! the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer , intent ( in ) :: kz !! the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) integer , intent ( in ) :: kq !! the order of spline pieces in q (>= 2, < nq). (order = polynomial degree + 1) integer , intent ( in ) :: kr !! the order of spline pieces in r (>= 2, < nr). (order = polynomial degree + 1) integer , intent ( in ) :: ks !! the order of spline pieces in s (>= 2, < ns). (order = polynomial degree + 1) real ( wp ), dimension (:), intent ( in ) :: x !! `nx` array of x abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: y !! `ny` array of y abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: z !! `nz` array of z abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: q !! `nq` array of q abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: r !! `nr` array of r abcissae. must be strictly increasing. real ( wp ), dimension (:), intent ( in ) :: s !! `ns` array of s abcissae. must be strictly increasing. real ( wp ), dimension (:,:,:,:,:,:), intent ( in ) :: fcn !! `(nx,ny,nz,nq,nr,ns)` matrix of function values to interpolate. fcn(i,j,k,q,r,s) should !!   contain the function value at the point (x(i),y(j),z(k),q(l),r(m),s(n)) integer , intent ( in ) :: iknot !! 0 = knot sequence chosen by [[db1ink]]. !! 1 = knot sequence chosen by user. real ( wp ), dimension (:), intent ( inout ) :: tx !! The `nx+kx` knots in the x direction for the spline interpolant. !!   If `iknot=0` these are chosen by [[db6ink]]. !!   If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: ty !! The `ny+ky` knots in the y direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db6ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tz !! The `nz+kz` knots in the z direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db6ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tq !! The `nq+kq` knots in the q direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db6ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: tr !! The `nr+kr` knots in the r direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db6ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:), intent ( inout ) :: ts !! The `ns+ks` knots in the s direction for the spline interpolant. !!    If `iknot=0` these are chosen by [[db6ink]]. !!    If `iknot=1` these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension (:,:,:,:,:,:), intent ( out ) :: bcoef !! `(nx,ny,nz,nq,nr,ns)` matrix of coefficients of the b-spline interpolant. integer , intent ( out ) :: iflag !!  0 = successful execution. !!  2 = iknot out of range. !!  3 = nx out of range. !!  4 = kx out of range. !!  5 = x not strictly increasing. !!  6 = tx not non-decreasing. !!  7 = ny out of range. !!  8 = ky out of range. !!  9 = y not strictly increasing. !! 10 = ty not non-decreasing. !! 11 = nz out of range. !! 12 = kz out of range. !! 13 = z not strictly increasing. !! 14 = tz not non-decreasing. !! 15 = nq out of range. !! 16 = kq out of range. !! 17 = q not strictly increasing. !! 18 = tq not non-decreasing. !! 19 = nr out of range. !! 20 = kr out of range. !! 21 = r not strictly increasing. !! 22 = tr not non-decreasing. !! 23 = ns out of range. !! 24 = ks out of range. !! 25 = s not strictly increasing. !! 26 = ts not non-decreasing. !! 700 = size(x) /= size(fcn,1). !! 701 = size(y) /= size(fcn,2). !! 702 = size(z) /= size(fcn,3). !! 703 = size(q) /= size(fcn,4). !! 704 = size(r) /= size(fcn,5). !! 705 = size(s) /= size(fcn,6). !! 706 = size(x) /= nx. !! 707 = size(y) /= ny. !! 708 = size(z) /= nz. !! 709 = size(q) /= nq. !! 710 = size(r) /= nr. !! 711 = size(s) /= ns. !! 712 = size(tx) /= nx+kx. !! 713 = size(ty) /= ny+ky. !! 714 = size(tz) /= nz+kz. !! 715 = size(tq) /= nq+kq. !! 716 = size(tr) /= nr+kr. !! 717 = size(ts) /= ns+ks. !! 800 = size(x) /= size(bcoef,1). !! 801 = size(y) /= size(bcoef,2). !! 802 = size(z) /= size(bcoef,3). !! 803 = size(q) /= size(bcoef,4). !! 804 = size(r) /= size(bcoef,5). !! 805 = size(s) /= size(bcoef,6). real ( wp ), dimension ( nx * ny * nz * nq * nr * ns ) :: temp real ( wp ), dimension ( max ( 2 * kx * ( nx + 1 ),& 2 * ky * ( ny + 1 ),& 2 * kz * ( nz + 1 ),& 2 * kq * ( nq + 1 ),& 2 * kr * ( nr + 1 ),& 2 * ks * ( ns + 1 ))) :: work logical :: status_ok ! check validity of input call check_inputs ( 'db6ink' ,& iknot ,& iflag ,& nx = nx , ny = ny , nz = nz , nq = nq , nr = nr , ns = ns ,& kx = kx , ky = ky , kz = kz , kq = kq , kr = kr , ks = ks ,& x = x , y = y , z = z , q = q , r = r , s = s ,& tx = tx , ty = ty , tz = tz , tq = tq , tr = tr , ts = ts ,& f6 = fcn ,& bcoef6 = bcoef ,& status_ok = status_ok ) if ( status_ok ) then ! choose knots if ( iknot == 0 ) then call dbknot ( x , nx , kx , tx ) call dbknot ( y , ny , ky , ty ) call dbknot ( z , nz , kz , tz ) call dbknot ( q , nq , kq , tq ) call dbknot ( r , nr , kr , tr ) call dbknot ( s , ns , ks , ts ) end if ! construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , ny * nz * nq * nr * ns , tx , kx , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( y , ny , temp , ny , nx * nz * nq * nr * ns , ty , ky , bcoef , work , iflag ) if ( iflag == 0 ) call dbtpcf ( z , nz , bcoef , nz , nx * ny * nq * nr * ns , tz , kz , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( q , nq , temp , nq , nx * ny * nz * nr * ns , tq , kq , bcoef , work , iflag ) if ( iflag == 0 ) call dbtpcf ( r , nr , bcoef , nr , nx * ny * nz * nq * ns , tr , kr , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( s , ns , temp , ns , nx * ny * nz * nq * nr , ts , ks , bcoef , work , iflag ) end if end subroutine db6ink","tags":"","loc":"proc/db6ink.html","title":"db6ink – Photodissociation of water"},{"text":"public pure subroutine db6val(xval, yval, zval, qval, rval, sval, idx, idy, idz, idq, idr, ids, tx, ty, tz, tq, tr, ts, nx, ny, nz, nq, nr, ns, kx, ky, kz, kq, kr, ks, bcoef, f, iflag, inbvx, inbvy, inbvz, inbvq, inbvr, inbvs, iloy, iloz, iloq, ilor, ilos) Evaluates the tensor product piecewise polynomial Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. real(kind=wp), intent(in) :: yval y coordinate of evaluation point. real(kind=wp), intent(in) :: zval z coordinate of evaluation point. real(kind=wp), intent(in) :: qval q coordinate of evaluation point. real(kind=wp), intent(in) :: rval r coordinate of evaluation point. real(kind=wp), intent(in) :: sval s coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. integer, intent(in) :: idy y derivative of piecewise polynomial to evaluate. integer, intent(in) :: idz z derivative of piecewise polynomial to evaluate. integer, intent(in) :: idq q derivative of piecewise polynomial to evaluate. integer, intent(in) :: idr r derivative of piecewise polynomial to evaluate. integer, intent(in) :: ids s derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db6ink ) real(kind=wp), intent(in), dimension(ny+ky) :: ty sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to db6ink ) real(kind=wp), intent(in), dimension(nz+kz) :: tz sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to db6ink ) real(kind=wp), intent(in), dimension(nq+kq) :: tq sequence of knots defining the piecewise polynomial in the q direction. (same as in last call to db6ink ) real(kind=wp), intent(in), dimension(nr+kr) :: tr sequence of knots defining the piecewise polynomial in the r direction. (same as in last call to db6ink ) real(kind=wp), intent(in), dimension(ns+ks) :: ts sequence of knots defining the piecewise polynomial in the s direction. (same as in last call to db6ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db6ink ) integer, intent(in) :: ny the number of interpolation points in y. (same as in last call to db6ink ) integer, intent(in) :: nz the number of interpolation points in z. (same as in last call to db6ink ) integer, intent(in) :: nq the number of interpolation points in q. (same as in last call to db6ink ) integer, intent(in) :: nr the number of interpolation points in r. (same as in last call to db6ink ) integer, intent(in) :: ns the number of interpolation points in s. (same as in last call to db6ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db6ink ) integer, intent(in) :: ky order of polynomial pieces in y. (same as in last call to db6ink ) integer, intent(in) :: kz order of polynomial pieces in z. (same as in last call to db6ink ) integer, intent(in) :: kq order of polynomial pieces in q. (same as in last call to db6ink ) integer, intent(in) :: kr order of polynomial pieces in r. (same as in last call to db6ink ) integer, intent(in) :: ks order of polynomial pieces in s. (same as in last call to db6ink ) real(kind=wp), intent(in), dimension(nx,ny,nz,nq,nr,ns) :: bcoef the b-spline coefficients computed by db6ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvq initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvr initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvs initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloq initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: ilor initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: ilos initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. Contents Source Code db6val Source Code pure subroutine db6val ( xval , yval , zval , qval , rval , sval ,& idx , idy , idz , idq , idr , ids ,& tx , ty , tz , tq , tr , ts ,& nx , ny , nz , nq , nr , ns ,& kx , ky , kz , kq , kr , ks ,& bcoef , f , iflag ,& inbvx , inbvy , inbvz , inbvq , inbvr , inbvs , iloy , iloz , iloq , ilor , ilos ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idy !! y derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idz !! z derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idq !! q derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idr !! r derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: ids !! s derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db6ink]]) integer , intent ( in ) :: ny !! the number of interpolation points in y. (same as in last call to [[db6ink]]) integer , intent ( in ) :: nz !! the number of interpolation points in z. (same as in last call to [[db6ink]]) integer , intent ( in ) :: nq !! the number of interpolation points in q. (same as in last call to [[db6ink]]) integer , intent ( in ) :: nr !! the number of interpolation points in r. (same as in last call to [[db6ink]]) integer , intent ( in ) :: ns !! the number of interpolation points in s. (same as in last call to [[db6ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db6ink]]) integer , intent ( in ) :: ky !! order of polynomial pieces in y. (same as in last call to [[db6ink]]) integer , intent ( in ) :: kz !! order of polynomial pieces in z. (same as in last call to [[db6ink]]) integer , intent ( in ) :: kq !! order of polynomial pieces in q. (same as in last call to [[db6ink]]) integer , intent ( in ) :: kr !! order of polynomial pieces in r. (same as in last call to [[db6ink]]) integer , intent ( in ) :: ks !! order of polynomial pieces in s. (same as in last call to [[db6ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), intent ( in ) :: yval !! y coordinate of evaluation point. real ( wp ), intent ( in ) :: zval !! z coordinate of evaluation point. real ( wp ), intent ( in ) :: qval !! q coordinate of evaluation point. real ( wp ), intent ( in ) :: rval !! r coordinate of evaluation point. real ( wp ), intent ( in ) :: sval !! s coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db6ink]]) real ( wp ), dimension ( ny + ky ), intent ( in ) :: ty !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db6ink]]) real ( wp ), dimension ( nz + kz ), intent ( in ) :: tz !! sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to [[db6ink]]) real ( wp ), dimension ( nq + kq ), intent ( in ) :: tq !! sequence of knots defining the piecewise polynomial in the q direction. (same as in last call to [[db6ink]]) real ( wp ), dimension ( nr + kr ), intent ( in ) :: tr !! sequence of knots defining the piecewise polynomial in the r direction. (same as in last call to [[db6ink]]) real ( wp ), dimension ( ns + ks ), intent ( in ) :: ts !! sequence of knots defining the piecewise polynomial in the s direction. (same as in last call to [[db6ink]]) real ( wp ), dimension ( nx , ny , nz , nq , nr , ns ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db6ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvq !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvr !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvs !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloz !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloq !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: ilor !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: ilos !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. real ( wp ), dimension ( ky , kz , kq , kr , ks ) :: temp1 real ( wp ), dimension ( kz , kq , kr , ks ) :: temp2 real ( wp ), dimension ( kq , kr , ks ) :: temp3 real ( wp ), dimension ( kr , ks ) :: temp4 real ( wp ), dimension ( ks ) :: temp5 real ( wp ), dimension ( 3 * max ( kx , ky , kz , kq , kr , ks )) :: work integer :: lefty , leftz , leftq , leftr , lefts ,& mflag ,& kcoly , kcolz , kcolq , kcolr , kcols ,& j , k , q , r , s f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then !write(error_unit,'(A)') 'db6val - x value out of bounds' iflag = 601 return end if if ( yval < ty ( 1 ) . or . yval > ty ( ny + ky )) then !write(error_unit,'(A)') 'db6val - y value out of bounds' iflag = 602 return end if if ( zval < tz ( 1 ) . or . zval > tz ( nz + kz )) then !write(error_unit,'(A)') 'db6val - z value out of bounds' iflag = 603 return end if if ( qval < tq ( 1 ) . or . qval > tq ( nq + kq ) ) then !write(error_unit,'(A)') 'db6val - q value out of bounds' iflag = 604 return end if if ( rval < tr ( 1 ) . or . rval > tr ( nr + kr ) ) then !write(error_unit,'(A)') 'db6val - r value out of bounds' iflag = 605 return end if if ( sval < ts ( 1 ) . or . sval > ts ( ns + ks ) ) then !write(error_unit,'(A)') 'db6val - s value out of bounds' iflag = 606 return end if iflag = - 1 call dintrv ( ty , ny + ky , yval , iloy , lefty , mflag ); if ( mflag /= 0 ) return call dintrv ( tz , nz + kz , zval , iloz , leftz , mflag ); if ( mflag /= 0 ) return call dintrv ( tq , nq + kq , qval , iloq , leftq , mflag ); if ( mflag /= 0 ) return call dintrv ( tr , nr + kr , rval , ilor , leftr , mflag ); if ( mflag /= 0 ) return call dintrv ( ts , ns + ks , sval , ilos , lefts , mflag ); if ( mflag /= 0 ) return iflag = 0 ! x -> y, z, q, r, s kcols = lefts - ks do s = 1 , ks kcols = kcols + 1 kcolr = leftr - kr do r = 1 , kr kcolr = kcolr + 1 kcolq = leftq - kq do q = 1 , kq kcolq = kcolq + 1 kcolz = leftz - kz do k = 1 , kz kcolz = kcolz + 1 kcoly = lefty - ky do j = 1 , ky kcoly = kcoly + 1 call dbvalu ( tx , bcoef (:, kcoly , kcolz , kcolq , kcolr , kcols ),& nx , kx , idx , xval , inbvx , work , iflag , temp1 ( j , k , q , r , s )) if ( iflag /= 0 ) return end do end do end do end do end do ! y -> z, q, r, s kcoly = lefty - ky + 1 do s = 1 , ks do r = 1 , kr do q = 1 , kq do k = 1 , kz call dbvalu ( ty ( kcoly :), temp1 (:, k , q , r , s ), ky , ky , idy , yval , inbvy , work , iflag , temp2 ( k , q , r , s )) if ( iflag /= 0 ) return end do end do end do end do ! z -> q, r, s kcolz = leftz - kz + 1 do s = 1 , ks do r = 1 , kr do q = 1 , kq call dbvalu ( tz ( kcolz :), temp2 (:, q , r , s ), kz , kz , idz , zval , inbvz , work , iflag , temp3 ( q , r , s )) if ( iflag /= 0 ) return end do end do end do ! q -> r, s kcolq = leftq - kq + 1 do s = 1 , ks do r = 1 , kr call dbvalu ( tq ( kcolq :), temp3 (:, r , s ), kq , kq , idq , qval , inbvq , work , iflag , temp4 ( r , s )) if ( iflag /= 0 ) return end do end do ! r -> s kcolr = leftr - kr + 1 do s = 1 , ks call dbvalu ( tr ( kcolr :), temp4 (:, s ), kr , kr , idr , rval , inbvr , work , iflag , temp5 ( s )) if ( iflag /= 0 ) return end do ! s kcols = lefts - ks + 1 call dbvalu ( ts ( kcols :), temp5 , ks , ks , ids , sval , inbvs , work , iflag , f ) end subroutine db6val","tags":"","loc":"proc/db6val.html","title":"db6val – Photodissociation of water"},{"text":"public subroutine interp(xa, ya, n, x, y) Arguments Type Intent Optional Attributes Name double precision, intent(in), dimension(n) :: xa double precision, intent(in), dimension(n) :: ya integer, intent(in) :: n double precision :: x double precision :: y Contents Source Code interp Source Code subroutine interp ( xa , ya , n , x , y ) implicit none integer , intent ( in ) :: n double precision , dimension ( n ), intent ( in ) :: xa , ya double precision :: x , y double precision :: a integer :: i , j !! Linear interpolation ! searching for two closer points of x in xa ! xa must be ascending sorted if ( x . lt . xa ( 1 ) . or . x . gt . xa ( n )) then write ( * , * ) 'x out of range in interp, I stop' , x stop endif ! call hunt(xa,n,x,i) call locate ( xa , n , x , i ) a = ( ya ( i + 1 ) - ya ( i )) / ( xa ( i + 1 ) - xa ( i )) y = ya ( i ) + a * ( x - xa ( i )) end subroutine interp","tags":"","loc":"proc/interp.html","title":"interp – Photodissociation of water"},{"text":"public subroutine hunt(xx, n, x, jlo) Arguments Type Intent Optional Attributes Name real(kind=8) :: xx (n) integer :: n real(kind=8) :: x integer :: jlo Contents Source Code hunt Source Code SUBROUTINE hunt ( xx , n , x , jlo ) INTEGER jlo , n REAL * 8 x , xx ( n ) INTEGER inc , jhi , jm LOGICAL ascnd ascnd = xx ( n ). gt . xx ( 1 ) if ( jlo . le . 0. or . jlo . gt . n ) then jlo = 0 jhi = n + 1 goto 3 endif inc = 1 if ( x . ge . xx ( jlo ). eqv . ascnd ) then 1 jhi = jlo + inc if ( jhi . gt . n ) then jhi = n + 1 else if ( x . ge . xx ( jhi ). eqv . ascnd ) then jlo = jhi inc = inc + inc goto 1 endif else jhi = jlo 2 jlo = jhi - inc if ( jlo . lt . 1 ) then jlo = 0 else if ( x . lt . xx ( jlo ). eqv . ascnd ) then jhi = jlo inc = inc + inc goto 2 endif endif 3 if ( jhi - jlo . eq . 1 ) return jm = ( jhi + jlo ) / 2 if ( x . gt . xx ( jm ). eqv . ascnd ) then jlo = jm else jhi = jm endif goto 3 END SUBROUTINE hunt","tags":"","loc":"proc/hunt.html","title":"hunt – Photodissociation of water"},{"text":"public subroutine locate(xx, n, x, j) Arguments Type Intent Optional Attributes Name real(kind=8) :: xx (n) integer :: n real(kind=8) :: x integer :: j Contents Source Code locate Source Code SUBROUTINE locate ( xx , n , x , j ) INTEGER j , n REAL * 8 x , xx ( n ) INTEGER jl , jm , ju jl = 0 ju = n + 1 10 if ( ju - jl . gt . 1 ) then jm = ( ju + jl ) / 2 if (( xx ( n ). gt . xx ( 1 )). eqv .( x . gt . xx ( jm ))) then jl = jm else ju = jm endif goto 10 endif j = jl return END SUBROUTINE locate","tags":"","loc":"proc/locate.html","title":"locate – Photodissociation of water"},{"text":"public interface bspline_1d Contents Module Procedures bspline_1d_constructor_empty bspline_1d_constructor_auto_knots bspline_1d_constructor_specify_knots Module Procedures private pure elemental function bspline_1d_constructor_empty() result(me) Arguments None Return Value type( bspline_1d ) private pure function bspline_1d_constructor_auto_knots(x, fcn, kx) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: fcn integer, intent(in) :: kx Return Value type( bspline_1d ) private pure function bspline_1d_constructor_specify_knots(x, fcn, kx, tx) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: fcn integer, intent(in) :: kx real(kind=wp), intent(in), dimension(:) :: tx Return Value type( bspline_1d )","tags":"","loc":"interface/bspline_1d.html","title":"bspline_1d – Photodissociation of water"},{"text":"public interface bspline_2d Contents Module Procedures bspline_2d_constructor_empty bspline_2d_constructor_auto_knots bspline_2d_constructor_specify_knots Module Procedures private elemental function bspline_2d_constructor_empty() result(me) Arguments None Return Value type( bspline_2d ) private pure function bspline_2d_constructor_auto_knots(x, y, fcn, kx, ky) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky Return Value type( bspline_2d ) private pure function bspline_2d_constructor_specify_knots(x, y, fcn, kx, ky, tx, ty) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty Return Value type( bspline_2d )","tags":"","loc":"interface/bspline_2d.html","title":"bspline_2d – Photodissociation of water"},{"text":"public interface bspline_3d Contents Module Procedures bspline_3d_constructor_empty bspline_3d_constructor_auto_knots bspline_3d_constructor_specify_knots Module Procedures private elemental function bspline_3d_constructor_empty() result(me) Arguments None Return Value type( bspline_3d ) private pure function bspline_3d_constructor_auto_knots(x, y, z, fcn, kx, ky, kz) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz Return Value type( bspline_3d ) private pure function bspline_3d_constructor_specify_knots(x, y, z, fcn, kx, ky, kz, tx, ty, tz) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz Return Value type( bspline_3d )","tags":"","loc":"interface/bspline_3d.html","title":"bspline_3d – Photodissociation of water"},{"text":"public interface bspline_4d Contents Module Procedures bspline_4d_constructor_empty bspline_4d_constructor_auto_knots bspline_4d_constructor_specify_knots Module Procedures private elemental function bspline_4d_constructor_empty() result(me) Arguments None Return Value type( bspline_4d ) private pure function bspline_4d_constructor_auto_knots(x, y, z, q, fcn, kx, ky, kz, kq) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq Return Value type( bspline_4d ) private pure function bspline_4d_constructor_specify_knots(x, y, z, q, fcn, kx, ky, kz, kq, tx, ty, tz, tq) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz real(kind=wp), intent(in), dimension(:) :: tq Return Value type( bspline_4d )","tags":"","loc":"interface/bspline_4d.html","title":"bspline_4d – Photodissociation of water"},{"text":"public interface bspline_5d Contents Module Procedures bspline_5d_constructor_empty bspline_5d_constructor_auto_knots bspline_5d_constructor_specify_knots Module Procedures private elemental function bspline_5d_constructor_empty() result(me) Arguments None Return Value type( bspline_5d ) private pure function bspline_5d_constructor_auto_knots(x, y, z, q, r, fcn, kx, ky, kz, kq, kr) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr Return Value type( bspline_5d ) private pure function bspline_5d_constructor_specify_knots(x, y, z, q, r, fcn, kx, ky, kz, kq, kr, tx, ty, tz, tq, tr) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz real(kind=wp), intent(in), dimension(:) :: tq real(kind=wp), intent(in), dimension(:) :: tr Return Value type( bspline_5d )","tags":"","loc":"interface/bspline_5d.html","title":"bspline_5d – Photodissociation of water"},{"text":"public interface bspline_6d Contents Module Procedures bspline_6d_constructor_empty bspline_6d_constructor_auto_knots bspline_6d_constructor_specify_knots Module Procedures private elemental function bspline_6d_constructor_empty() result(me) Arguments None Return Value type( bspline_6d ) private pure function bspline_6d_constructor_auto_knots(x, y, z, q, r, s, fcn, kx, ky, kz, kq, kr, ks) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr integer, intent(in) :: ks Return Value type( bspline_6d ) private pure function bspline_6d_constructor_specify_knots(x, y, z, q, r, s, fcn, kx, ky, kz, kq, kr, ks, tx, ty, tz, tq, tr, ts) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr integer, intent(in) :: ks real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz real(kind=wp), intent(in), dimension(:) :: tq real(kind=wp), intent(in), dimension(:) :: tr real(kind=wp), intent(in), dimension(:) :: ts Return Value type( bspline_6d )","tags":"","loc":"interface/bspline_6d.html","title":"bspline_6d – Photodissociation of water"},{"text":"public function rand_uniform(a, b) result(c) Arguments Type Intent Optional Attributes Name double precision :: a double precision :: b Return Value double precision Contents None","tags":"","loc":"proc/rand_uniform.html","title":"rand_uniform – Photodissociation of water"},{"text":"public function rand_normal(mean, stdev) result(c) Arguments Type Intent Optional Attributes Name double precision :: mean double precision :: stdev Return Value double precision Contents None","tags":"","loc":"proc/rand_normal.html","title":"rand_normal – Photodissociation of water"},{"text":"public function rand_exponential(mean) result(c) Arguments Type Intent Optional Attributes Name double precision :: mean Return Value double precision Contents None","tags":"","loc":"proc/rand_exponential.html","title":"rand_exponential – Photodissociation of water"},{"text":"public recursive function rand_gamma(SHAPE, scale) result(ans) Arguments Type Intent Optional Attributes Name double precision :: SHAPE double precision :: scale Return Value real Contents None","tags":"","loc":"proc/rand_gamma.html","title":"rand_gamma – Photodissociation of water"},{"text":"public function rand_chi_square(dof) result(ans) Arguments Type Intent Optional Attributes Name double precision :: dof Return Value double precision Contents None","tags":"","loc":"proc/rand_chi_square.html","title":"rand_chi_square – Photodissociation of water"},{"text":"public function rand_inverse_gamma(SHAPE, scale) result(ans) Arguments Type Intent Optional Attributes Name double precision :: SHAPE double precision :: scale Return Value double precision Contents None","tags":"","loc":"proc/rand_inverse_gamma.html","title":"rand_inverse_gamma – Photodissociation of water"},{"text":"public function rand_weibull(SHAPE, scale) result(ans) Arguments Type Intent Optional Attributes Name double precision :: SHAPE double precision :: scale Return Value double precision Contents None","tags":"","loc":"proc/rand_weibull.html","title":"rand_weibull – Photodissociation of water"},{"text":"public function rand_cauchy(median, scale) result(ans) Arguments Type Intent Optional Attributes Name double precision :: median double precision :: scale Return Value double precision Contents None","tags":"","loc":"proc/rand_cauchy.html","title":"rand_cauchy – Photodissociation of water"},{"text":"public function rand_student_t(dof) result(ans) Arguments Type Intent Optional Attributes Name double precision :: dof Return Value double precision Contents None","tags":"","loc":"proc/rand_student_t.html","title":"rand_student_t – Photodissociation of water"},{"text":"public function rand_laplace(mean, scale) result(ans) Arguments Type Intent Optional Attributes Name double precision :: mean double precision :: scale Return Value double precision Contents None","tags":"","loc":"proc/rand_laplace.html","title":"rand_laplace – Photodissociation of water"},{"text":"public function rand_log_normal(mu, sigma) result(ans) Arguments Type Intent Optional Attributes Name double precision :: mu double precision :: sigma Return Value double precision Contents None","tags":"","loc":"proc/rand_log_normal.html","title":"rand_log_normal – Photodissociation of water"},{"text":"public function rand_beta(a, b) result(ans) Arguments Type Intent Optional Attributes Name double precision :: a double precision :: b Return Value double precision Contents None","tags":"","loc":"proc/rand_beta.html","title":"rand_beta – Photodissociation of water"},{"text":"Uses iso_fortran_env iso_fortran_env Contents Functions get_status_message Subroutines db1ink db1val db2ink db2val db3ink db3val db4ink db4val db5ink db5val db6ink db6val Functions public pure function get_status_message (iflag) result(msg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iflag return code from one of the routines Return Value character(len=:),\n  allocatable status message associated with the flag Subroutines public pure subroutine db1ink (x, nx, fcn, kx, iknot, tx, bcoef, iflag) Determines the parameters of a function that interpolates Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x nx array of x abcissae. Must be strictly increasing. integer, intent(in) :: nx Number of x abcissae real(kind=wp), intent(in), dimension(:) :: fcn (nx) array of function values to interpolate. fcn(i) should\n    contain the function value at the point x(i) integer, intent(in) :: kx The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: iknot 0 = knot sequence chosen by db1ink .\n 1 = knot sequence chosen by user. real(kind=wp), intent(inout), dimension(:) :: tx The nx+kx knots in the x direction for the spline interpolant.\n   If iknot=0 these are chosen by db1ink .\n   If iknot=1 these are specified by the user.\n   Must be non-decreasing. real(kind=wp), intent(out), dimension(:) :: bcoef (nx) array of coefficients of the b-spline interpolant. integer, intent(out) :: iflag 0 = successful execution.\n 2 = iknot out of range.\n 3 = nx out of range.\n 4 = kx out of range.\n 5 = x not strictly increasing.\n 6 = tx not non-decreasing.\n 700 = size(x) /= size(fcn,1).\n 706 = size(x) /= nx.\n 712 = size(tx) /= nx+kx.\n 800 = size(x) /= size(bcoef,1). public pure subroutine db1val (xval, idx, tx, nx, kx, bcoef, f, iflag, inbvx) Evaluates the tensor product piecewise polynomial Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db1ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db1ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db1ink ) real(kind=wp), intent(in), dimension(nx) :: bcoef the b-spline coefficients computed by db1ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. public pure subroutine db2ink (x, nx, y, ny, fcn, kx, ky, iknot, tx, ty, bcoef, iflag) Determines the parameters of a function that interpolates Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x nx array of x abcissae. Must be strictly increasing. integer, intent(in) :: nx Number of x abcissae real(kind=wp), intent(in), dimension(:) :: y ny array of y abcissae. Must be strictly increasing. integer, intent(in) :: ny Number of y abcissae real(kind=wp), intent(in), dimension(:,:) :: fcn (nx,ny) matrix of function values to interpolate. fcn(i,j) should\n    contain the function value at the point (x(i),y(j)) integer, intent(in) :: kx The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: ky The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer, intent(in) :: iknot 0 = knot sequence chosen by db1ink .\n 1 = knot sequence chosen by user. real(kind=wp), intent(inout), dimension(:) :: tx The nx+kx knots in the x direction for the spline interpolant.\n    If iknot=0 these are chosen by db2ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: ty The ny+ky knots in the y direction for the spline interpolant.\n    If iknot=0 these are chosen by db2ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(out), dimension(:,:) :: bcoef (nx,ny) matrix of coefficients of the b-spline interpolant. integer, intent(out) :: iflag 0 = successful execution.\n  2 = iknot out of range.\n  3 = nx out of range.\n  4 = kx out of range.\n  5 = x not strictly increasing.\n  6 = tx not non-decreasing.\n  7 = ny out of range.\n  8 = ky out of range.\n  9 = y not strictly increasing.\n 10 = ty not non-decreasing.\n 700 = size(x) /= size(fcn,1).\n 701 = size(y) /= size(fcn,2).\n 706 = size(x) /= nx.\n 707 = size(y) /= ny.\n 712 = size(tx) /= nx+kx.\n 713 = size(ty) /= ny+ky.\n 800 = size(x) /= size(bcoef,1).\n 801 = size(y) /= size(bcoef,2). public pure subroutine db2val (xval, yval, idx, idy, tx, ty, nx, ny, kx, ky, bcoef, f, iflag, inbvx, inbvy, iloy) Evaluates the tensor product piecewise polynomial Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. real(kind=wp), intent(in) :: yval y coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. integer, intent(in) :: idy y derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db2ink ) real(kind=wp), intent(in), dimension(ny+ky) :: ty sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to db2ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db2ink ) integer, intent(in) :: ny the number of interpolation points in y. (same as in last call to db2ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db2ink ) integer, intent(in) :: ky order of polynomial pieces in y. (same as in last call to db2ink ) real(kind=wp), intent(in), dimension(nx,ny) :: bcoef the b-spline coefficients computed by db2ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. public pure subroutine db3ink (x, nx, y, ny, z, nz, fcn, kx, ky, kz, iknot, tx, ty, tz, bcoef, iflag) Determines the parameters of a function that interpolates Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x nx array of x abcissae. must be strictly increasing. integer, intent(in) :: nx number of x abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: y ny array of y abcissae. must be strictly increasing. integer, intent(in) :: ny number of y abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: z nz array of z abcissae. must be strictly increasing. integer, intent(in) :: nz number of z abcissae (>= 3) real(kind=wp), intent(in), dimension(:,:,:) :: fcn (nx,ny,nz) matrix of function values to interpolate. fcn(i,j,k) should\n   contain the function value at the point (x(i),y(j),z(k)) integer, intent(in) :: kx the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: ky the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer, intent(in) :: kz the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) integer, intent(in) :: iknot 0 = knot sequence chosen by db1ink .\n 1 = knot sequence chosen by user. real(kind=wp), intent(inout), dimension(:) :: tx The nx+kx knots in the x direction for the spline interpolant.\n   If iknot=0 these are chosen by db3ink .\n   If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: ty The ny+ky knots in the y direction for the spline interpolant.\n    If iknot=0 these are chosen by db3ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tz The nz+kz knots in the z direction for the spline interpolant.\n    If iknot=0 these are chosen by db3ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(out), dimension(:,:,:) :: bcoef '(nx,ny,nz)' matrix of coefficients of the b-spline interpolant. integer, intent(out) :: iflag 0 = successful execution.\n  2 = iknot out of range.\n  3 = nx out of range.\n  4 = kx out of range.\n  5 = x not strictly increasing.\n  6 = tx not non-decreasing.\n  7 = ny out of range.\n  8 = ky out of range.\n  9 = y not strictly increasing.\n 10 = ty not non-decreasing.\n 11 = nz out of range.\n 12 = kz out of range.\n 13 = z not strictly increasing.\n 14 = ty not non-decreasing.\n 700 = size(x) /= size(fcn,1).\n 701 = size(y) /= size(fcn,2).\n 702 = size(z) /= size(fcn,3).\n 706 = size(x) /= nx.\n 707 = size(y) /= ny.\n 708 = size(z) /= nz.\n 712 = size(tx) /= nx+kx.\n 713 = size(ty) /= ny+ky.\n 714 = size(tz) /= nz+kz.\n 800 = size(x) /= size(bcoef,1).\n 801 = size(y) /= size(bcoef,2).\n 802 = size(z) /= size(bcoef,3). public pure subroutine db3val (xval, yval, zval, idx, idy, idz, tx, ty, tz, nx, ny, nz, kx, ky, kz, bcoef, f, iflag, inbvx, inbvy, inbvz, iloy, iloz) Evaluates the tensor product piecewise polynomial Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. real(kind=wp), intent(in) :: yval y coordinate of evaluation point. real(kind=wp), intent(in) :: zval z coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. integer, intent(in) :: idy y derivative of piecewise polynomial to evaluate. integer, intent(in) :: idz z derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db3ink ) real(kind=wp), intent(in), dimension(ny+ky) :: ty sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to db3ink ) real(kind=wp), intent(in), dimension(nz+kz) :: tz sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to db3ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db3ink ) integer, intent(in) :: ny the number of interpolation points in y. (same as in last call to db3ink ) integer, intent(in) :: nz the number of interpolation points in z. (same as in last call to db3ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db3ink ) integer, intent(in) :: ky order of polynomial pieces in y. (same as in last call to db3ink ) integer, intent(in) :: kz order of polynomial pieces in z. (same as in last call to db3ink ) real(kind=wp), intent(in), dimension(nx,ny,nz) :: bcoef the b-spline coefficients computed by db3ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. public pure subroutine db4ink (x, nx, y, ny, z, nz, q, nq, fcn, kx, ky, kz, kq, iknot, tx, ty, tz, tq, bcoef, iflag) Determines the parameters of a function that interpolates Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x nx array of x abcissae. must be strictly increasing. integer, intent(in) :: nx number of x abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: y ny array of y abcissae. must be strictly increasing. integer, intent(in) :: ny number of y abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: z nz array of z abcissae. must be strictly increasing. integer, intent(in) :: nz number of z abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: q nq array of q abcissae. must be strictly increasing. integer, intent(in) :: nq number of q abcissae (>= 3) real(kind=wp), intent(in), dimension(:,:,:,:) :: fcn (nx,ny,nz,nq) matrix of function values to interpolate. fcn(i,j,k,q) should\n   contain the function value at the point (x(i),y(j),z(k),q(l)) integer, intent(in) :: kx the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: ky the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer, intent(in) :: kz the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) integer, intent(in) :: kq the order of spline pieces in q (>= 2, < nq). (order = polynomial degree + 1) integer, intent(in) :: iknot 0 = knot sequence chosen by db1ink .\n 1 = knot sequence chosen by user. real(kind=wp), intent(inout), dimension(:) :: tx The nx+kx knots in the x direction for the spline interpolant.\n   If iknot=0 these are chosen by db4ink .\n   If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: ty The ny+ky knots in the y direction for the spline interpolant.\n    If iknot=0 these are chosen by db4ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tz The nz+kz knots in the z direction for the spline interpolant.\n    If iknot=0 these are chosen by db4ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tq The nq+kq knots in the q direction for the spline interpolant.\n    If iknot=0 these are chosen by db4ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(out), dimension(:,:,:,:) :: bcoef (nx,ny,nz,nq) matrix of coefficients of the b-spline interpolant. integer, intent(out) :: iflag 0 = successful execution.\n  2 = iknot out of range.\n  3 = nx out of range.\n  4 = kx out of range.\n  5 = x not strictly increasing.\n  6 = tx not non-decreasing.\n  7 = ny out of range.\n  8 = ky out of range.\n  9 = y not strictly increasing.\n 10 = ty not non-decreasing.\n 11 = nz out of range.\n 12 = kz out of range.\n 13 = z not strictly increasing.\n 14 = tz not non-decreasing.\n 15 = nq out of range.\n 16 = kq out of range.\n 17 = q not strictly increasing.\n 18 = tq not non-decreasing.\n 700 = size(x) /= size(fcn,1).\n 701 = size(y) /= size(fcn,2).\n 702 = size(z) /= size(fcn,3).\n 703 = size(q) /= size(fcn,4).\n 706 = size(x) /= nx.\n 707 = size(y) /= ny.\n 708 = size(z) /= nz.\n 709 = size(q) /= nq.\n 712 = size(tx) /= nx+kx.\n 713 = size(ty) /= ny+ky.\n 714 = size(tz) /= nz+kz.\n 715 = size(tq) /= nq+kq.\n 800 = size(x) /= size(bcoef,1).\n 801 = size(y) /= size(bcoef,2).\n 802 = size(z) /= size(bcoef,3).\n 803 = size(q) /= size(bcoef,4). public pure subroutine db4val (xval, yval, zval, qval, idx, idy, idz, idq, tx, ty, tz, tq, nx, ny, nz, nq, kx, ky, kz, kq, bcoef, f, iflag, inbvx, inbvy, inbvz, inbvq, iloy, iloz, iloq) Evaluates the tensor product piecewise polynomial Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. real(kind=wp), intent(in) :: yval y coordinate of evaluation point. real(kind=wp), intent(in) :: zval z coordinate of evaluation point. real(kind=wp), intent(in) :: qval q coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. integer, intent(in) :: idy y derivative of piecewise polynomial to evaluate. integer, intent(in) :: idz z derivative of piecewise polynomial to evaluate. integer, intent(in) :: idq q derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db4ink ) real(kind=wp), intent(in), dimension(ny+ky) :: ty sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to db4ink ) real(kind=wp), intent(in), dimension(nz+kz) :: tz sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to db4ink ) real(kind=wp), intent(in), dimension(nq+kq) :: tq sequence of knots defining the piecewise polynomial in the q direction. (same as in last call to db4ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db4ink ) integer, intent(in) :: ny the number of interpolation points in y. (same as in last call to db4ink ) integer, intent(in) :: nz the number of interpolation points in z. (same as in last call to db4ink ) integer, intent(in) :: nq the number of interpolation points in q. (same as in last call to db4ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db4ink ) integer, intent(in) :: ky order of polynomial pieces in y. (same as in last call to db4ink ) integer, intent(in) :: kz order of polynomial pieces in z. (same as in last call to db4ink ) integer, intent(in) :: kq order of polynomial pieces in q. (same as in last call to db4ink ) real(kind=wp), intent(in), dimension(nx,ny,nz,nq) :: bcoef the b-spline coefficients computed by db4ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvq initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloq initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. public pure subroutine db5ink (x, nx, y, ny, z, nz, q, nq, r, nr, fcn, kx, ky, kz, kq, kr, iknot, tx, ty, tz, tq, tr, bcoef, iflag) Determines the parameters of a function that interpolates Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x nx array of x abcissae. must be strictly increasing. integer, intent(in) :: nx number of x abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: y ny array of y abcissae. must be strictly increasing. integer, intent(in) :: ny number of y abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: z nz array of z abcissae. must be strictly increasing. integer, intent(in) :: nz number of z abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: q nq array of q abcissae. must be strictly increasing. integer, intent(in) :: nq number of q abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: r nr array of r abcissae. must be strictly increasing. integer, intent(in) :: nr number of r abcissae (>= 3) real(kind=wp), intent(in), dimension(:,:,:,:,:) :: fcn (nx,ny,nz,nq,nr) matrix of function values to interpolate. fcn(i,j,k,q,r) should\n   contain the function value at the point (x(i),y(j),z(k),q(l),r(m)) integer, intent(in) :: kx the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: ky the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer, intent(in) :: kz the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) integer, intent(in) :: kq the order of spline pieces in q (>= 2, < nq). (order = polynomial degree + 1) integer, intent(in) :: kr the order of spline pieces in r (>= 2, < nr). (order = polynomial degree + 1) integer, intent(in) :: iknot 0 = knot sequence chosen by db1ink .\n 1 = knot sequence chosen by user. real(kind=wp), intent(inout), dimension(:) :: tx The nx+kx knots in the x direction for the spline interpolant.\n   If iknot=0 these are chosen by db5ink .\n   If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: ty The ny+ky knots in the y direction for the spline interpolant.\n    If iknot=0 these are chosen by db5ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tz The nz+kz knots in the z direction for the spline interpolant.\n    If iknot=0 these are chosen by db5ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tq The nq+kq knots in the q direction for the spline interpolant.\n    If iknot=0 these are chosen by db5ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tr The nr+kr knots in the r direction for the spline interpolant.\n    If iknot=0 these are chosen by db5ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(out), dimension(:,:,:,:,:) :: bcoef (nx,ny,nz,nq,nr) matrix of coefficients of the b-spline interpolant. integer, intent(out) :: iflag 0 = successful execution.\n  2 = iknot out of range.\n  3 = nx out of range.\n  4 = kx out of range.\n  5 = x not strictly increasing.\n  6 = tx not non-decreasing.\n  7 = ny out of range.\n  8 = ky out of range.\n  9 = y not strictly increasing.\n 10 = ty not non-decreasing.\n 11 = nz out of range.\n 12 = kz out of range.\n 13 = z not strictly increasing.\n 14 = tz not non-decreasing.\n 15 = nq out of range.\n 16 = kq out of range.\n 17 = q not strictly increasing.\n 18 = tq not non-decreasing.\n 19 = nr out of range.\n 20 = kr out of range.\n 21 = r not strictly increasing.\n 22 = tr not non-decreasing.\n 700 = size(x) /= size(fcn,1).\n 701 = size(y) /= size(fcn,2).\n 702 = size(z) /= size(fcn,3).\n 703 = size(q) /= size(fcn,4).\n 704 = size(r) /= size(fcn,5).\n 706 = size(x) /= nx.\n 707 = size(y) /= ny.\n 708 = size(z) /= nz.\n 709 = size(q) /= nq.\n 710 = size(r) /= nr.\n 712 = size(tx) /= nx+kx.\n 713 = size(ty) /= ny+ky.\n 714 = size(tz) /= nz+kz.\n 715 = size(tq) /= nq+kq.\n 716 = size(tr) /= nr+kr.\n 800 = size(x) /= size(bcoef,1).\n 801 = size(y) /= size(bcoef,2).\n 802 = size(z) /= size(bcoef,3).\n 803 = size(q) /= size(bcoef,4).\n 804 = size(r) /= size(bcoef,5). public pure subroutine db5val (xval, yval, zval, qval, rval, idx, idy, idz, idq, idr, tx, ty, tz, tq, tr, nx, ny, nz, nq, nr, kx, ky, kz, kq, kr, bcoef, f, iflag, inbvx, inbvy, inbvz, inbvq, inbvr, iloy, iloz, iloq, ilor) Evaluates the tensor product piecewise polynomial Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. real(kind=wp), intent(in) :: yval y coordinate of evaluation point. real(kind=wp), intent(in) :: zval z coordinate of evaluation point. real(kind=wp), intent(in) :: qval q coordinate of evaluation point. real(kind=wp), intent(in) :: rval r coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. integer, intent(in) :: idy y derivative of piecewise polynomial to evaluate. integer, intent(in) :: idz z derivative of piecewise polynomial to evaluate. integer, intent(in) :: idq q derivative of piecewise polynomial to evaluate. integer, intent(in) :: idr r derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db5ink ) real(kind=wp), intent(in), dimension(ny+ky) :: ty sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to db5ink ) real(kind=wp), intent(in), dimension(nz+kz) :: tz sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to db5ink ) real(kind=wp), intent(in), dimension(nq+kq) :: tq sequence of knots defining the piecewise polynomial in the q direction. (same as in last call to db5ink ) real(kind=wp), intent(in), dimension(nr+kr) :: tr sequence of knots defining the piecewise polynomial in the r direction. (same as in last call to db5ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db5ink ) integer, intent(in) :: ny the number of interpolation points in y. (same as in last call to db5ink ) integer, intent(in) :: nz the number of interpolation points in z. (same as in last call to db5ink ) integer, intent(in) :: nq the number of interpolation points in q. (same as in last call to db5ink ) integer, intent(in) :: nr the number of interpolation points in r. (same as in last call to db5ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db5ink ) integer, intent(in) :: ky order of polynomial pieces in y. (same as in last call to db5ink ) integer, intent(in) :: kz order of polynomial pieces in z. (same as in last call to db5ink ) integer, intent(in) :: kq order of polynomial pieces in q. (same as in last call to db5ink ) integer, intent(in) :: kr order of polynomial pieces in r. (same as in last call to db5ink ) real(kind=wp), intent(in), dimension(nx,ny,nz,nq,nr) :: bcoef the b-spline coefficients computed by db5ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvq initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvr initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloq initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: ilor initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. public pure subroutine db6ink (x, nx, y, ny, z, nz, q, nq, r, nr, s, ns, fcn, kx, ky, kz, kq, kr, ks, iknot, tx, ty, tz, tq, tr, ts, bcoef, iflag) Determines the parameters of a function that interpolates Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x nx array of x abcissae. must be strictly increasing. integer, intent(in) :: nx number of x abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: y ny array of y abcissae. must be strictly increasing. integer, intent(in) :: ny number of y abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: z nz array of z abcissae. must be strictly increasing. integer, intent(in) :: nz number of z abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: q nq array of q abcissae. must be strictly increasing. integer, intent(in) :: nq number of q abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: r nr array of r abcissae. must be strictly increasing. integer, intent(in) :: nr number of r abcissae (>= 3) real(kind=wp), intent(in), dimension(:) :: s ns array of s abcissae. must be strictly increasing. integer, intent(in) :: ns number of s abcissae (>= 3) real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: fcn (nx,ny,nz,nq,nr,ns) matrix of function values to interpolate. fcn(i,j,k,q,r,s) should\n   contain the function value at the point (x(i),y(j),z(k),q(l),r(m),s(n)) integer, intent(in) :: kx the order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: ky the order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) integer, intent(in) :: kz the order of spline pieces in z (>= 2, < nz). (order = polynomial degree + 1) integer, intent(in) :: kq the order of spline pieces in q (>= 2, < nq). (order = polynomial degree + 1) integer, intent(in) :: kr the order of spline pieces in r (>= 2, < nr). (order = polynomial degree + 1) integer, intent(in) :: ks the order of spline pieces in s (>= 2, < ns). (order = polynomial degree + 1) integer, intent(in) :: iknot 0 = knot sequence chosen by db1ink .\n 1 = knot sequence chosen by user. real(kind=wp), intent(inout), dimension(:) :: tx The nx+kx knots in the x direction for the spline interpolant.\n   If iknot=0 these are chosen by db6ink .\n   If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: ty The ny+ky knots in the y direction for the spline interpolant.\n    If iknot=0 these are chosen by db6ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tz The nz+kz knots in the z direction for the spline interpolant.\n    If iknot=0 these are chosen by db6ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tq The nq+kq knots in the q direction for the spline interpolant.\n    If iknot=0 these are chosen by db6ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: tr The nr+kr knots in the r direction for the spline interpolant.\n    If iknot=0 these are chosen by db6ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(:) :: ts The ns+ks knots in the s direction for the spline interpolant.\n    If iknot=0 these are chosen by db6ink .\n    If iknot=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(out), dimension(:,:,:,:,:,:) :: bcoef (nx,ny,nz,nq,nr,ns) matrix of coefficients of the b-spline interpolant. integer, intent(out) :: iflag 0 = successful execution.\n  2 = iknot out of range.\n  3 = nx out of range.\n  4 = kx out of range.\n  5 = x not strictly increasing.\n  6 = tx not non-decreasing.\n  7 = ny out of range.\n  8 = ky out of range.\n  9 = y not strictly increasing.\n 10 = ty not non-decreasing.\n 11 = nz out of range.\n 12 = kz out of range.\n 13 = z not strictly increasing.\n 14 = tz not non-decreasing.\n 15 = nq out of range.\n 16 = kq out of range.\n 17 = q not strictly increasing.\n 18 = tq not non-decreasing.\n 19 = nr out of range.\n 20 = kr out of range.\n 21 = r not strictly increasing.\n 22 = tr not non-decreasing.\n 23 = ns out of range.\n 24 = ks out of range.\n 25 = s not strictly increasing.\n 26 = ts not non-decreasing.\n 700 = size(x) /= size(fcn,1).\n 701 = size(y) /= size(fcn,2).\n 702 = size(z) /= size(fcn,3).\n 703 = size(q) /= size(fcn,4).\n 704 = size(r) /= size(fcn,5).\n 705 = size(s) /= size(fcn,6).\n 706 = size(x) /= nx.\n 707 = size(y) /= ny.\n 708 = size(z) /= nz.\n 709 = size(q) /= nq.\n 710 = size(r) /= nr.\n 711 = size(s) /= ns.\n 712 = size(tx) /= nx+kx.\n 713 = size(ty) /= ny+ky.\n 714 = size(tz) /= nz+kz.\n 715 = size(tq) /= nq+kq.\n 716 = size(tr) /= nr+kr.\n 717 = size(ts) /= ns+ks.\n 800 = size(x) /= size(bcoef,1).\n 801 = size(y) /= size(bcoef,2).\n 802 = size(z) /= size(bcoef,3).\n 803 = size(q) /= size(bcoef,4).\n 804 = size(r) /= size(bcoef,5).\n 805 = size(s) /= size(bcoef,6). public pure subroutine db6val (xval, yval, zval, qval, rval, sval, idx, idy, idz, idq, idr, ids, tx, ty, tz, tq, tr, ts, nx, ny, nz, nq, nr, ns, kx, ky, kz, kq, kr, ks, bcoef, f, iflag, inbvx, inbvy, inbvz, inbvq, inbvr, inbvs, iloy, iloz, iloq, ilor, ilos) Evaluates the tensor product piecewise polynomial Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. real(kind=wp), intent(in) :: yval y coordinate of evaluation point. real(kind=wp), intent(in) :: zval z coordinate of evaluation point. real(kind=wp), intent(in) :: qval q coordinate of evaluation point. real(kind=wp), intent(in) :: rval r coordinate of evaluation point. real(kind=wp), intent(in) :: sval s coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. integer, intent(in) :: idy y derivative of piecewise polynomial to evaluate. integer, intent(in) :: idz z derivative of piecewise polynomial to evaluate. integer, intent(in) :: idq q derivative of piecewise polynomial to evaluate. integer, intent(in) :: idr r derivative of piecewise polynomial to evaluate. integer, intent(in) :: ids s derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db6ink ) real(kind=wp), intent(in), dimension(ny+ky) :: ty sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to db6ink ) real(kind=wp), intent(in), dimension(nz+kz) :: tz sequence of knots defining the piecewise polynomial in the z direction. (same as in last call to db6ink ) real(kind=wp), intent(in), dimension(nq+kq) :: tq sequence of knots defining the piecewise polynomial in the q direction. (same as in last call to db6ink ) real(kind=wp), intent(in), dimension(nr+kr) :: tr sequence of knots defining the piecewise polynomial in the r direction. (same as in last call to db6ink ) real(kind=wp), intent(in), dimension(ns+ks) :: ts sequence of knots defining the piecewise polynomial in the s direction. (same as in last call to db6ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db6ink ) integer, intent(in) :: ny the number of interpolation points in y. (same as in last call to db6ink ) integer, intent(in) :: nz the number of interpolation points in z. (same as in last call to db6ink ) integer, intent(in) :: nq the number of interpolation points in q. (same as in last call to db6ink ) integer, intent(in) :: nr the number of interpolation points in r. (same as in last call to db6ink ) integer, intent(in) :: ns the number of interpolation points in s. (same as in last call to db6ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db6ink ) integer, intent(in) :: ky order of polynomial pieces in y. (same as in last call to db6ink ) integer, intent(in) :: kz order of polynomial pieces in z. (same as in last call to db6ink ) integer, intent(in) :: kq order of polynomial pieces in q. (same as in last call to db6ink ) integer, intent(in) :: kr order of polynomial pieces in r. (same as in last call to db6ink ) integer, intent(in) :: ks order of polynomial pieces in s. (same as in last call to db6ink ) real(kind=wp), intent(in), dimension(nx,ny,nz,nq,nr,ns) :: bcoef the b-spline coefficients computed by db6ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvq initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvr initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvs initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloz initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloq initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: ilor initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: ilos initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user.","tags":"","loc":"module/bspline_sub_module.html","title":"bspline_sub_module – Photodissociation of water"},{"text":"Uses bspline_oo_module bspline_sub_module Contents None","tags":"","loc":"module/bspline_module.html","title":"bspline_module – Photodissociation of water"},{"text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Contents Subroutines interp hunt locate Subroutines public subroutine interp (xa, ya, n, x, y) Arguments Type Intent Optional Attributes Name double precision, intent(in), dimension(n) :: xa double precision, intent(in), dimension(n) :: ya integer, intent(in) :: n double precision :: x double precision :: y public subroutine hunt (xx, n, x, jlo) Arguments Type Intent Optional Attributes Name real(kind=8) :: xx (n) integer :: n real(kind=8) :: x integer :: jlo public subroutine locate (xx, n, x, j) Arguments Type Intent Optional Attributes Name real(kind=8) :: xx (n) integer :: n real(kind=8) :: x integer :: j","tags":"","loc":"module/interpolation.html","title":"interpolation – Photodissociation of water"},{"text":"Uses iso_fortran_env iso_fortran_env bspline_sub_module Contents Interfaces bspline_1d bspline_2d bspline_3d bspline_4d bspline_5d bspline_6d Derived Types bspline_class bspline_1d bspline_2d bspline_3d bspline_4d bspline_5d bspline_6d Interfaces public interface bspline_1d private pure elemental function bspline_1d_constructor_empty() result(me) Arguments None Return Value type( bspline_1d ) private pure function bspline_1d_constructor_auto_knots(x, fcn, kx) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: fcn integer, intent(in) :: kx Return Value type( bspline_1d ) private pure function bspline_1d_constructor_specify_knots(x, fcn, kx, tx) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: fcn integer, intent(in) :: kx real(kind=wp), intent(in), dimension(:) :: tx Return Value type( bspline_1d ) public interface bspline_2d private elemental function bspline_2d_constructor_empty() result(me) Arguments None Return Value type( bspline_2d ) private pure function bspline_2d_constructor_auto_knots(x, y, fcn, kx, ky) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky Return Value type( bspline_2d ) private pure function bspline_2d_constructor_specify_knots(x, y, fcn, kx, ky, tx, ty) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty Return Value type( bspline_2d ) public interface bspline_3d private elemental function bspline_3d_constructor_empty() result(me) Arguments None Return Value type( bspline_3d ) private pure function bspline_3d_constructor_auto_knots(x, y, z, fcn, kx, ky, kz) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz Return Value type( bspline_3d ) private pure function bspline_3d_constructor_specify_knots(x, y, z, fcn, kx, ky, kz, tx, ty, tz) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz Return Value type( bspline_3d ) public interface bspline_4d private elemental function bspline_4d_constructor_empty() result(me) Arguments None Return Value type( bspline_4d ) private pure function bspline_4d_constructor_auto_knots(x, y, z, q, fcn, kx, ky, kz, kq) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq Return Value type( bspline_4d ) private pure function bspline_4d_constructor_specify_knots(x, y, z, q, fcn, kx, ky, kz, kq, tx, ty, tz, tq) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz real(kind=wp), intent(in), dimension(:) :: tq Return Value type( bspline_4d ) public interface bspline_5d private elemental function bspline_5d_constructor_empty() result(me) Arguments None Return Value type( bspline_5d ) private pure function bspline_5d_constructor_auto_knots(x, y, z, q, r, fcn, kx, ky, kz, kq, kr) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr Return Value type( bspline_5d ) private pure function bspline_5d_constructor_specify_knots(x, y, z, q, r, fcn, kx, ky, kz, kq, kr, tx, ty, tz, tq, tr) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz real(kind=wp), intent(in), dimension(:) :: tq real(kind=wp), intent(in), dimension(:) :: tr Return Value type( bspline_5d ) public interface bspline_6d private elemental function bspline_6d_constructor_empty() result(me) Arguments None Return Value type( bspline_6d ) private pure function bspline_6d_constructor_auto_knots(x, y, z, q, r, s, fcn, kx, ky, kz, kq, kr, ks) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr integer, intent(in) :: ks Return Value type( bspline_6d ) private pure function bspline_6d_constructor_specify_knots(x, y, z, q, r, s, fcn, kx, ky, kz, kq, kr, ks, tx, ty, tz, tq, tr, ts) result(me) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: fcn integer, intent(in) :: kx integer, intent(in) :: ky integer, intent(in) :: kz integer, intent(in) :: kq integer, intent(in) :: kr integer, intent(in) :: ks real(kind=wp), intent(in), dimension(:) :: tx real(kind=wp), intent(in), dimension(:) :: ty real(kind=wp), intent(in), dimension(:) :: tz real(kind=wp), intent(in), dimension(:) :: tq real(kind=wp), intent(in), dimension(:) :: tr real(kind=wp), intent(in), dimension(:) :: ts Return Value type( bspline_6d ) Derived Types type, public, abstract :: bspline_class Base class for the b-spline types Type-Bound Procedures procedure(destroy_func), public :: destroy destructor procedure, public, non_overridable :: status_ok returns true if the last iflag status code was =0 . procedure, public, non_overridable :: status_message => get_bspline_status_message retrieve the last status message procedure, public, non_overridable :: clear_flag => clear_bspline_flag to reset the iflag saved in the class. type, public, extends( bspline_class ) :: bspline_1d Class for 1d b-spline interpolation. Constructor private pure,elemental function bspline_1d_constructor_empty () private pure function bspline_1d_constructor_auto_knots (x, fcn, kx) private pure function bspline_1d_constructor_specify_knots (x, fcn, kx, tx) Finalizations Procedures final :: finalize_1d Type-Bound Procedures procedure, public, non_overridable :: status_ok returns true if the last iflag status code was =0 . procedure, public, non_overridable :: status_message => get_bspline_status_message retrieve the last status message procedure, public, non_overridable :: clear_flag => clear_bspline_flag to reset the iflag saved in the class. generic, public :: initialize => initialize_1d_auto_knots, initialize_1d_specify_knots procedure, public :: evaluate => evaluate_1d procedure, public :: destroy => destroy_1d type, public, extends( bspline_class ) :: bspline_2d Class for 2d b-spline interpolation. Constructor private elemental function bspline_2d_constructor_empty () private pure function bspline_2d_constructor_auto_knots (x, y, fcn, kx, ky) private pure function bspline_2d_constructor_specify_knots (x, y, fcn, kx, ky, tx, ty) Finalizations Procedures final :: finalize_2d Type-Bound Procedures procedure, public, non_overridable :: status_ok returns true if the last iflag status code was =0 . procedure, public, non_overridable :: status_message => get_bspline_status_message retrieve the last status message procedure, public, non_overridable :: clear_flag => clear_bspline_flag to reset the iflag saved in the class. generic, public :: initialize => initialize_2d_auto_knots, initialize_2d_specify_knots procedure, public :: evaluate => evaluate_2d procedure, public :: destroy => destroy_2d type, public, extends( bspline_class ) :: bspline_3d Class for 3d b-spline interpolation. Constructor private elemental function bspline_3d_constructor_empty () private pure function bspline_3d_constructor_auto_knots (x, y, z, fcn, kx, ky, kz) private pure function bspline_3d_constructor_specify_knots (x, y, z, fcn, kx, ky, kz, tx, ty, tz) Finalizations Procedures final :: finalize_3d Type-Bound Procedures procedure, public, non_overridable :: status_ok returns true if the last iflag status code was =0 . procedure, public, non_overridable :: status_message => get_bspline_status_message retrieve the last status message procedure, public, non_overridable :: clear_flag => clear_bspline_flag to reset the iflag saved in the class. generic, public :: initialize => initialize_3d_auto_knots, initialize_3d_specify_knots procedure, public :: evaluate => evaluate_3d procedure, public :: destroy => destroy_3d type, public, extends( bspline_class ) :: bspline_4d Class for 4d b-spline interpolation. Constructor private elemental function bspline_4d_constructor_empty () private pure function bspline_4d_constructor_auto_knots (x, y, z, q, fcn, kx, ky, kz, kq) private pure function bspline_4d_constructor_specify_knots (x, y, z, q, fcn, kx, ky, kz, kq, tx, ty, tz, tq) Finalizations Procedures final :: finalize_4d Type-Bound Procedures procedure, public, non_overridable :: status_ok returns true if the last iflag status code was =0 . procedure, public, non_overridable :: status_message => get_bspline_status_message retrieve the last status message procedure, public, non_overridable :: clear_flag => clear_bspline_flag to reset the iflag saved in the class. generic, public :: initialize => initialize_4d_auto_knots, initialize_4d_specify_knots procedure, public :: evaluate => evaluate_4d procedure, public :: destroy => destroy_4d type, public, extends( bspline_class ) :: bspline_5d Class for 5d b-spline interpolation. Constructor private elemental function bspline_5d_constructor_empty () private pure function bspline_5d_constructor_auto_knots (x, y, z, q, r, fcn, kx, ky, kz, kq, kr) private pure function bspline_5d_constructor_specify_knots (x, y, z, q, r, fcn, kx, ky, kz, kq, kr, tx, ty, tz, tq, tr) Finalizations Procedures final :: finalize_5d Type-Bound Procedures procedure, public, non_overridable :: status_ok returns true if the last iflag status code was =0 . procedure, public, non_overridable :: status_message => get_bspline_status_message retrieve the last status message procedure, public, non_overridable :: clear_flag => clear_bspline_flag to reset the iflag saved in the class. generic, public :: initialize => initialize_5d_auto_knots, initialize_5d_specify_knots procedure, public :: evaluate => evaluate_5d procedure, public :: destroy => destroy_5d type, public, extends( bspline_class ) :: bspline_6d Class for 6d b-spline interpolation. Constructor private elemental function bspline_6d_constructor_empty () private pure function bspline_6d_constructor_auto_knots (x, y, z, q, r, s, fcn, kx, ky, kz, kq, kr, ks) private pure function bspline_6d_constructor_specify_knots (x, y, z, q, r, s, fcn, kx, ky, kz, kq, kr, ks, tx, ty, tz, tq, tr, ts) Finalizations Procedures final :: finalize_6d Type-Bound Procedures procedure, public, non_overridable :: status_ok returns true if the last iflag status code was =0 . procedure, public, non_overridable :: status_message => get_bspline_status_message retrieve the last status message procedure, public, non_overridable :: clear_flag => clear_bspline_flag to reset the iflag saved in the class. generic, public :: initialize => initialize_6d_auto_knots, initialize_6d_specify_knots procedure, public :: evaluate => evaluate_6d procedure, public :: destroy => destroy_6d","tags":"","loc":"module/bspline_oo_module.html","title":"bspline_oo_module – Photodissociation of water"},{"text":"Contents Variables PI Functions rand_uniform rand_normal rand_exponential rand_gamma rand_chi_square rand_inverse_gamma rand_weibull rand_cauchy rand_student_t rand_laplace rand_log_normal rand_beta Variables Type Visibility Attributes Name Initial double precision, public, parameter :: PI = 3.141592653589793238462 Functions public function rand_uniform (a, b) result(c) Arguments Type Intent Optional Attributes Name double precision :: a double precision :: b Return Value double precision public function rand_normal (mean, stdev) result(c) Arguments Type Intent Optional Attributes Name double precision :: mean double precision :: stdev Return Value double precision public function rand_exponential (mean) result(c) Arguments Type Intent Optional Attributes Name double precision :: mean Return Value double precision public recursive function rand_gamma (SHAPE, scale) result(ans) Arguments Type Intent Optional Attributes Name double precision :: SHAPE double precision :: scale Return Value real public function rand_chi_square (dof) result(ans) Arguments Type Intent Optional Attributes Name double precision :: dof Return Value double precision public function rand_inverse_gamma (SHAPE, scale) result(ans) Arguments Type Intent Optional Attributes Name double precision :: SHAPE double precision :: scale Return Value double precision public function rand_weibull (SHAPE, scale) result(ans) Arguments Type Intent Optional Attributes Name double precision :: SHAPE double precision :: scale Return Value double precision public function rand_cauchy (median, scale) result(ans) Arguments Type Intent Optional Attributes Name double precision :: median double precision :: scale Return Value double precision public function rand_student_t (dof) result(ans) Arguments Type Intent Optional Attributes Name double precision :: dof Return Value double precision public function rand_laplace (mean, scale) result(ans) Arguments Type Intent Optional Attributes Name double precision :: mean double precision :: scale Return Value double precision public function rand_log_normal (mu, sigma) result(ans) Arguments Type Intent Optional Attributes Name double precision :: mu double precision :: sigma Return Value double precision public function rand_beta (a, b) result(ans) Arguments Type Intent Optional Attributes Name double precision :: a double precision :: b Return Value double precision","tags":"","loc":"module/rdistributions.html","title":"RDistributions – Photodissociation of water"},{"text":"The program solves classical Newton's Eq. for H2O \\\n Non-adiabatic transitions take place according to Landau-Zener Surface Hopping algorithm (see J. Chem. Phys. 142, 104307 (2015)) \\\n The PES must be given as follows rOH1, rOH2, angle_H1OH2, energies Contents Variables npart xyz vxyz mass r1 r2 theta ti tf dt dr fsta fpot i j l Source Code dynamic_h2o Variables Type Attributes Name Initial integer, parameter :: npart = 3 double precision, dimension(3,npart) :: xyz double precision, dimension(3,npart) :: vxyz double precision, dimension(npart) :: mass double precision :: r1 double precision :: r2 double precision :: theta double precision :: ti double precision :: tf double precision :: dt double precision :: dr integer :: fsta character(len=64) :: fpot integer :: i integer :: j integer :: l Source Code program dynamic_h2o implicit none integer , parameter :: npart = 3 double precision , dimension ( 3 , npart ) :: xyz , vxyz double precision , dimension ( npart ) :: mass double precision :: r1 , r2 , theta double precision :: ti , tf double precision :: dt , dr integer :: fsta character ( 64 ) :: fpot integer :: i , j , l ! reads the initial conditions write ( * , * ) \"!!!  Enter Oxygen first !!!\" read ( * , * ) dt , dr read ( * , * ) fpot , tf , fsta tf = tf * 41 d0 do i = 1 , npart read ( * , * ) mass ( i ), xyz ( 1 , i ), xyz ( 2 , i ), xyz ( 3 , i ), vxyz ( 1 , i ), vxyz ( 2 , i ), vxyz ( 3 , i ) write ( 100 , '(6(f20.15,1X))' ) xyz ( 1 , i ), xyz ( 2 , i ), xyz ( 3 , i ), vxyz ( 1 , i ), vxyz ( 2 , i ), vxyz ( 3 , i ) mass ( i ) = mass ( i ) * 183 6.15d0 enddo write ( 100 , * ) if ( mass ( 1 ) /= 1 6.0d0 * 183 6.15d0 ) then write ( * , * ) \"I said !!!  Enter Oxygen first !!!\" stop endif call compute_dist ( npart , xyz , r1 , r2 , theta ) write ( 10 , * ) r1 , r2 , theta ! starts with the dynamics ti = 0 d0 call dyn ( npart , mass , xyz , vxyz , ti , tf , fpot , fsta , dt , dr ) call compute_dist ( npart , xyz , r1 , r2 , theta ) write ( * , * ) r1 , r2 , theta write ( * , * ) do i = 1 , npart write ( 100 , '(6(f20.10,1X))' ) xyz (:, i ), vxyz (:, i ) enddo write ( 100 , * ) end program dynamic_h2o","tags":"","loc":"program/dynamic_h2o.html","title":"dynamic_h2o – Photodissociation of water"}]}